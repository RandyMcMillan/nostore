(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/@scure/bip39/wordlists/english.js
  var require_english = __commonJS({
    "node_modules/@scure/bip39/wordlists/english.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wordlist = void 0;
      exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
      function number2(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports.number = number2;
      function bool2(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports.bool = bool2;
      function bytes2(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new TypeError("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports.bytes = bytes2;
      function hash2(hash3) {
        if (typeof hash3 !== "function" || typeof hash3.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number2(hash3.outputLen);
        number2(hash3.blockLen);
      }
      exports.hash = hash2;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports.output = output2;
      var assert2 = {
        number: number2,
        bool: bool2,
        bytes: bytes2,
        hash: hash2,
        exists: exists2,
        output: output2
      };
      exports.default = assert2;
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js
  var require_cryptoBrowser = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = {
        node: void 0,
        web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
      };
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js
  var require_utils = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
      var crypto_1 = require_cryptoBrowser();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.u8 = u8;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports.u32 = u32;
      var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports.createView = createView3;
      var rotr3 = (word, shift) => word << 32 - shift | word >>> shift;
      exports.rotr = rotr3;
      exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes4 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex3(uint8a) {
        if (!(uint8a instanceof Uint8Array))
          throw new Error("Uint8Array expected");
        let hex2 = "";
        for (let i = 0; i < uint8a.length; i++) {
          hex2 += hexes4[uint8a[i]];
        }
        return hex2;
      }
      exports.bytesToHex = bytesToHex3;
      function hexToBytes3(hex2) {
        if (typeof hex2 !== "string") {
          throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
        }
        if (hex2.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const array = new Uint8Array(hex2.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex2.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports.hexToBytes = hexToBytes3;
      var nextTick3 = async () => {
      };
      exports.nextTick = nextTick3;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      exports.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string") {
          throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
        }
        return new TextEncoder().encode(str);
      }
      exports.utf8ToBytes = utf8ToBytes3;
      function toBytes3(data2) {
        if (typeof data2 === "string")
          data2 = utf8ToBytes3(data2);
        if (!(data2 instanceof Uint8Array))
          throw new TypeError(`Expected input type is Uint8Array (got ${typeof data2})`);
        return data2;
      }
      exports.toBytes = toBytes3;
      function concatBytes3(...arrays) {
        if (!arrays.every((a) => a instanceof Uint8Array))
          throw new Error("Uint8Array list expected");
        if (arrays.length === 1)
          return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      exports.concatBytes = concatBytes3;
      var Hash3 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports.Hash = Hash3;
      var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
          throw new TypeError("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports.checkOpts = checkOpts;
      function wrapConstructor3(hashConstructor) {
        const hashC = (message) => hashConstructor().update(toBytes3(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        return hashC;
      }
      exports.wrapConstructor = wrapConstructor3;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function randomBytes2(bytesLength = 32) {
        if (crypto_1.crypto.web) {
          return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto_1.crypto.node) {
          return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      }
      exports.randomBytes = randomBytes2;
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js
  var require_hmac = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils();
      var HMAC3 = class extends utils_js_1.Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.hash(hash2);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new TypeError("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          pad.fill(0);
        }
        update(buf) {
          _assert_js_1.default.exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      var hmac3 = (hash2, key, message) => new HMAC3(hash2, key).update(message).digest();
      exports.hmac = hmac3;
      exports.hmac.create = (hash2, key) => new HMAC3(hash2, key);
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pbkdf2Async = exports.pbkdf2 = void 0;
      var _assert_js_1 = require_assert();
      var hmac_js_1 = require_hmac();
      var utils_js_1 = require_utils();
      function pbkdf2Init(hash2, _password, _salt, _opts) {
        _assert_js_1.default.hash(hash2);
        const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
        const { c, dkLen, asyncTick } = opts;
        _assert_js_1.default.number(c);
        _assert_js_1.default.number(dkLen);
        _assert_js_1.default.number(asyncTick);
        if (c < 1)
          throw new Error("PBKDF2: iterations (c) should be >= 1");
        const password = (0, utils_js_1.toBytes)(_password);
        const salt = (0, utils_js_1.toBytes)(_salt);
        const DK = new Uint8Array(dkLen);
        const PRF = hmac_js_1.hmac.create(hash2, password);
        const PRFSalt = PRF._cloneInto().update(salt);
        return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
      }
      function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
        PRF.destroy();
        PRFSalt.destroy();
        if (prfW)
          prfW.destroy();
        u.fill(0);
        return DK;
      }
      function pbkdf2(hash2, password, salt, opts) {
        const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          for (let ui = 1; ui < c; ui++) {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
              Ti[i] ^= u[i];
          }
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
      exports.pbkdf2 = pbkdf2;
      async function pbkdf2Async(hash2, password, salt, opts) {
        const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
          Ti.set(u.subarray(0, Ti.length));
          await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i2 = 0; i2 < Ti.length; i2++)
              Ti[i2] ^= u[i2];
          });
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
      }
      exports.pbkdf2Async = pbkdf2Async;
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js
  var require_sha2 = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2 = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils();
      function setBigUint643(view, byteOffset, value, isLE3) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE3);
        const _32n2 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n2 & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE3 ? 4 : 0;
        const l = isLE3 ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE3);
        view.setUint32(byteOffset + l, wl, isLE3);
      }
      var SHA23 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE3) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE3;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data2) {
          _assert_js_1.default.exists(this);
          const { view, buffer, blockLen } = this;
          data2 = (0, utils_js_1.toBytes)(data2);
          const len = data2.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_js_1.createView)(data2);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data2.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data2.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.output(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE: isLE3 } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE3);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
      };
      exports.SHA2 = SHA23;
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.sha256 = void 0;
      var _sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var Chi3 = (a, b, c) => a & b ^ ~a & c;
      var Maj3 = (a, b, c) => a & b ^ a & c ^ b & c;
      var SHA256_K3 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV3 = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W3 = new Uint32Array(64);
      var SHA2563 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV3[0] | 0;
          this.B = IV3[1] | 0;
          this.C = IV3[2] | 0;
          this.D = IV3[3] | 0;
          this.E = IV3[4] | 0;
          this.F = IV3[5] | 0;
          this.G = IV3[6] | 0;
          this.H = IV3[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W3[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W3[i - 15];
            const W2 = SHA256_W3[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W3[i] = s1 + SHA256_W3[i - 7] + s0 + SHA256_W3[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = H + sigma1 + Chi3(E, F, G) + SHA256_K3[i] + SHA256_W3[i] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = sigma0 + Maj3(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W3.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA2242 = class extends SHA2563 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2563());
      exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2242());
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
      var U32_MASK642 = BigInt(2 ** 32 - 1);
      var _32n2 = BigInt(32);
      function fromBig2(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
        return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
      }
      exports.fromBig = fromBig2;
      function split2(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig2(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports.split = split2;
      var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
      exports.toBig = toBig2;
      var shrSH2 = (h, l, s) => h >>> s;
      var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
      var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
      var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
      var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
      var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
      var rotr32H2 = (h, l) => l;
      var rotr32L2 = (h, l) => h;
      var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
      var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
      var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
      var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
      function add3(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports.add = add3;
      var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      var u642 = {
        fromBig: fromBig2,
        split: split2,
        toBig: exports.toBig,
        shrSH: shrSH2,
        shrSL: shrSL2,
        rotrSH: rotrSH2,
        rotrSL: rotrSL2,
        rotrBH: rotrBH2,
        rotrBL: rotrBL2,
        rotr32H: rotr32H2,
        rotr32L: rotr32L2,
        rotlSH: rotlSH2,
        rotlSL: rotlSL2,
        rotlBH: rotlBH2,
        rotlBL: rotlBL2,
        add: add3,
        add3L: add3L2,
        add3H: add3H2,
        add4L: add4L2,
        add4H: add4H2,
        add5H: add5H2,
        add5L: add5L2
      };
      exports.default = u642;
    }
  });

  // node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
      var _sha2_js_1 = require_sha2();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils();
      var [SHA512_Kh2, SHA512_Kl2] = _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n)));
      var SHA512_W_H2 = new Uint32Array(80);
      var SHA512_W_L2 = new Uint32Array(80);
      var SHA5122 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H2[i] = view.getUint32(offset);
            SHA512_W_L2[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H2[i - 15] | 0;
            const W15l = SHA512_W_L2[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H2[i - 2] | 0;
            const W2l = SHA512_W_L2[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L2[i - 7], SHA512_W_L2[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i - 7], SHA512_W_H2[i - 16]);
            SHA512_W_H2[i] = SUMh | 0;
            SHA512_W_L2[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i], SHA512_W_L2[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i], SHA512_W_H2[i]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H2.fill(0);
          SHA512_W_L2.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports.SHA512 = SHA5122;
      var SHA512_2242 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_2562 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA3842 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5122());
      exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2242());
      exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2562());
      exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3842());
    }
  });

  // node_modules/@scure/base/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@scure/base/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
      function assertNumber3(n) {
        if (!Number.isSafeInteger(n))
          throw new Error(`Wrong integer: ${n}`);
      }
      exports.assertNumber = assertNumber3;
      function chain2(...args) {
        const wrap = (a, b) => (c) => a(b(c));
        const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
        const decode2 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
        return { encode, decode: decode2 };
      }
      function alphabet2(alphabet3) {
        return {
          encode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("alphabet.encode input should be an array of numbers");
            return digits.map((i) => {
              assertNumber3(i);
              if (i < 0 || i >= alphabet3.length)
                throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet3.length})`);
              return alphabet3[i];
            });
          },
          decode: (input) => {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("alphabet.decode input should be array of strings");
            return input.map((letter) => {
              if (typeof letter !== "string")
                throw new Error(`alphabet.decode: not string element=${letter}`);
              const index = alphabet3.indexOf(letter);
              if (index === -1)
                throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
              return index;
            });
          }
        };
      }
      function join2(separator = "") {
        if (typeof separator !== "string")
          throw new Error("join separator should be string");
        return {
          encode: (from) => {
            if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
              throw new Error("join.encode input should be array of strings");
            for (let i of from)
              if (typeof i !== "string")
                throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
          },
          decode: (to) => {
            if (typeof to !== "string")
              throw new Error("join.decode input should be string");
            return to.split(separator);
          }
        };
      }
      function padding2(bits, chr = "=") {
        assertNumber3(bits);
        if (typeof chr !== "string")
          throw new Error("padding chr should be string");
        return {
          encode(data2) {
            if (!Array.isArray(data2) || data2.length && typeof data2[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i of data2)
              if (typeof i !== "string")
                throw new Error(`padding.encode: non-string input=${i}`);
            while (data2.length * bits % 8)
              data2.push(chr);
            return data2;
          },
          decode(input) {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i of input)
              if (typeof i !== "string")
                throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if (end * bits % 8)
              throw new Error("Invalid padding: string should have whole number of bytes");
            for (; end > 0 && input[end - 1] === chr; end--) {
              if (!((end - 1) * bits % 8))
                throw new Error("Invalid padding: string has too much padding");
            }
            return input.slice(0, end);
          }
        };
      }
      function normalize2(fn) {
        if (typeof fn !== "function")
          throw new Error("normalize fn should be function");
        return { encode: (from) => from, decode: (to) => fn(to) };
      }
      function convertRadix3(data2, from, to) {
        if (from < 2)
          throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
        if (to < 2)
          throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
        if (!Array.isArray(data2))
          throw new Error("convertRadix: data should be array");
        if (!data2.length)
          return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data2);
        digits.forEach((d) => {
          assertNumber3(d);
          if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
        });
        while (true) {
          let carry = 0;
          let done = true;
          for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
              throw new Error("convertRadix: carry overflow");
            }
            carry = digitBase % to;
            digits[i] = Math.floor(digitBase / to);
            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
              throw new Error("convertRadix: carry overflow");
            if (!done)
              continue;
            else if (!digits[i])
              pos = i;
            else
              done = false;
          }
          res.push(carry);
          if (done)
            break;
        }
        for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++)
          res.push(0);
        return res.reverse();
      }
      var gcd2 = (a, b) => !b ? a : gcd2(b, a % b);
      var radix2carry2 = (from, to) => from + (to - gcd2(from, to));
      function convertRadix22(data2, from, to, padding3) {
        if (!Array.isArray(data2))
          throw new Error("convertRadix2: data should be array");
        if (from <= 0 || from > 32)
          throw new Error(`convertRadix2: wrong from=${from}`);
        if (to <= 0 || to > 32)
          throw new Error(`convertRadix2: wrong to=${to}`);
        if (radix2carry2(from, to) > 32) {
          throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry2(from, to)}`);
        }
        let carry = 0;
        let pos = 0;
        const mask = 2 ** to - 1;
        const res = [];
        for (const n of data2) {
          assertNumber3(n);
          if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
          carry = carry << from | n;
          if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
          pos += from;
          for (; pos >= to; pos -= to)
            res.push((carry >> pos - to & mask) >>> 0);
          carry &= 2 ** pos - 1;
        }
        carry = carry << to - pos & mask;
        if (!padding3 && pos >= from)
          throw new Error("Excess padding");
        if (!padding3 && carry)
          throw new Error(`Non-zero padding: ${carry}`);
        if (padding3 && pos > 0)
          res.push(carry >>> 0);
        return res;
      }
      function radix3(num) {
        assertNumber3(num);
        return {
          encode: (bytes2) => {
            if (!(bytes2 instanceof Uint8Array))
              throw new Error("radix.encode input should be Uint8Array");
            return convertRadix3(Array.from(bytes2), 2 ** 8, num);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(convertRadix3(digits, num, 2 ** 8));
          }
        };
      }
      function radix22(bits, revPadding = false) {
        assertNumber3(bits);
        if (bits <= 0 || bits > 32)
          throw new Error("radix2: bits should be in (0..32]");
        if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (bytes2) => {
            if (!(bytes2 instanceof Uint8Array))
              throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix22(Array.from(bytes2), 8, bits, !revPadding);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
          }
        };
      }
      function unsafeWrapper2(fn) {
        if (typeof fn !== "function")
          throw new Error("unsafeWrapper fn should be function");
        return function(...args) {
          try {
            return fn.apply(null, args);
          } catch (e) {
          }
        };
      }
      function checksum2(len, fn) {
        assertNumber3(len);
        if (typeof fn !== "function")
          throw new Error("checksum fn should be function");
        return {
          encode(data2) {
            if (!(data2 instanceof Uint8Array))
              throw new Error("checksum.encode: input should be Uint8Array");
            const checksum3 = fn(data2).slice(0, len);
            const res = new Uint8Array(data2.length + len);
            res.set(data2);
            res.set(checksum3, data2.length);
            return res;
          },
          decode(data2) {
            if (!(data2 instanceof Uint8Array))
              throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data2.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data2.slice(-len);
            for (let i = 0; i < len; i++)
              if (newChecksum[i] !== oldChecksum[i])
                throw new Error("Invalid checksum");
            return payload;
          }
        };
      }
      exports.utils = { alphabet: alphabet2, chain: chain2, checksum: checksum2, radix: radix3, radix2: radix22, join: join2, padding: padding2 };
      exports.base16 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
      exports.base32 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
      exports.base32hex = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
      exports.base32crockford = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
      exports.base64 = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
      exports.base64url = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
      var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
      exports.base58 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports.base58flickr = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
      exports.base58xrp = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
      var XMR_BLOCK_LEN2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
      exports.base58xmr = {
        encode(data2) {
          let res = "";
          for (let i = 0; i < data2.length; i += 8) {
            const block = data2.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN2[block.length], "1");
          }
          return res;
        },
        decode(str) {
          let res = [];
          for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN2.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
              if (block[j] !== 0)
                throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
          }
          return Uint8Array.from(res);
        }
      };
      var base58check3 = (sha2563) => chain2(checksum2(4, (data2) => sha2563(sha2563(data2))), exports.base58);
      exports.base58check = base58check3;
      var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
      var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function bech32Polymod2(pre) {
        const b = pre >> 25;
        let chk = (pre & 33554431) << 5;
        for (let i = 0; i < POLYMOD_GENERATORS2.length; i++) {
          if ((b >> i & 1) === 1)
            chk ^= POLYMOD_GENERATORS2[i];
        }
        return chk;
      }
      function bechChecksum2(prefix2, words, encodingConst = 1) {
        const len = prefix2.length;
        let chk = 1;
        for (let i = 0; i < len; i++) {
          const c = prefix2.charCodeAt(i);
          if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix2})`);
          chk = bech32Polymod2(chk) ^ c >> 5;
        }
        chk = bech32Polymod2(chk);
        for (let i = 0; i < len; i++)
          chk = bech32Polymod2(chk) ^ prefix2.charCodeAt(i) & 31;
        for (let v of words)
          chk = bech32Polymod2(chk) ^ v;
        for (let i = 0; i < 6; i++)
          chk = bech32Polymod2(chk);
        chk ^= encodingConst;
        return BECH_ALPHABET2.encode(convertRadix22([chk % 2 ** 30], 30, 5, false));
      }
      function genBech322(encoding) {
        const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
        const _words = radix22(5);
        const fromWords = _words.decode;
        const toWords = _words.encode;
        const fromWordsUnsafe = unsafeWrapper2(fromWords);
        function encode(prefix2, words, limit = 90) {
          if (typeof prefix2 !== "string")
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix2}`);
          if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
          const actualLength = prefix2.length + 7 + words.length;
          if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
          prefix2 = prefix2.toLowerCase();
          return `${prefix2}1${BECH_ALPHABET2.encode(words)}${bechChecksum2(prefix2, words, ENCODING_CONST)}`;
        }
        function decode2(str, limit = 90) {
          if (typeof str !== "string")
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
          if (str.length < 8 || limit !== false && str.length > limit)
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
          const lowered = str.toLowerCase();
          if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
          str = lowered;
          const sepIndex = str.lastIndexOf("1");
          if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
          const prefix2 = str.slice(0, sepIndex);
          const _words2 = str.slice(sepIndex + 1);
          if (_words2.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const words = BECH_ALPHABET2.decode(_words2).slice(0, -6);
          const sum = bechChecksum2(prefix2, words, ENCODING_CONST);
          if (!_words2.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
          return { prefix: prefix2, words };
        }
        const decodeUnsafe = unsafeWrapper2(decode2);
        function decodeToBytes(str) {
          const { prefix: prefix2, words } = decode2(str, false);
          return { prefix: prefix2, words, bytes: fromWords(words) };
        }
        return { encode, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
      }
      exports.bech32 = genBech322("bech32");
      exports.bech32m = genBech322("bech32m");
      exports.utf8 = {
        encode: (data2) => new TextDecoder().decode(data2),
        decode: (str) => new TextEncoder().encode(str)
      };
      exports.hex = chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s) => {
        if (typeof s !== "string" || s.length % 2)
          throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
      }));
      var CODERS2 = {
        utf8: exports.utf8,
        hex: exports.hex,
        base16: exports.base16,
        base32: exports.base32,
        base64: exports.base64,
        base64url: exports.base64url,
        base58: exports.base58,
        base58xmr: exports.base58xmr
      };
      var coderTypeError2 = `Invalid encoding type. Available types: ${Object.keys(CODERS2).join(", ")}`;
      var bytesToString = (type, bytes2) => {
        if (typeof type !== "string" || !CODERS2.hasOwnProperty(type))
          throw new TypeError(coderTypeError2);
        if (!(bytes2 instanceof Uint8Array))
          throw new TypeError("bytesToString() expects Uint8Array");
        return CODERS2[type].encode(bytes2);
      };
      exports.bytesToString = bytesToString;
      exports.str = exports.bytesToString;
      var stringToBytes = (type, str) => {
        if (!CODERS2.hasOwnProperty(type))
          throw new TypeError(coderTypeError2);
        if (typeof str !== "string")
          throw new TypeError("stringToBytes() expects string");
        return CODERS2[type].decode(str);
      };
      exports.stringToBytes = stringToBytes;
      exports.bytes = exports.stringToBytes;
    }
  });

  // node_modules/@scure/bip39/index.js
  var require_bip39 = __commonJS({
    "node_modules/@scure/bip39/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
      var _assert_1 = require_assert();
      var pbkdf2_1 = require_pbkdf2();
      var sha256_1 = require_sha256();
      var sha512_1 = require_sha512();
      var utils_1 = require_utils();
      var base_1 = require_lib();
      var isJapanese = (wordlist2) => wordlist2[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
      function nfkd(str) {
        if (typeof str !== "string")
          throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
        return str.normalize("NFKD");
      }
      function normalize2(str) {
        const norm = nfkd(str);
        const words = norm.split(" ");
        if (![12, 15, 18, 21, 24].includes(words.length))
          throw new Error("Invalid mnemonic");
        return { nfkd: norm, words };
      }
      function assertEntropy(entropy) {
        _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
      }
      function generateMnemonic2(wordlist2, strength = 128) {
        _assert_1.default.number(strength);
        if (strength % 32 !== 0 || strength > 256)
          throw new TypeError("Invalid entropy");
        return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist2);
      }
      exports.generateMnemonic = generateMnemonic2;
      var calcChecksum = (entropy) => {
        const bitsLeft = 8 - entropy.length / 4;
        return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
      };
      function getCoder(wordlist2) {
        if (!Array.isArray(wordlist2) || wordlist2.length !== 2 ** 11 || typeof wordlist2[0] !== "string")
          throw new Error("Worlist: expected array of 2048 strings");
        wordlist2.forEach((i) => {
          if (typeof i !== "string")
            throw new Error(`Wordlist: non-string element: ${i}`);
        });
        return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist2));
      }
      function mnemonicToEntropy(mnemonic, wordlist2) {
        const { words } = normalize2(mnemonic);
        const entropy = getCoder(wordlist2).decode(words);
        assertEntropy(entropy);
        return entropy;
      }
      exports.mnemonicToEntropy = mnemonicToEntropy;
      function entropyToMnemonic(entropy, wordlist2) {
        assertEntropy(entropy);
        const words = getCoder(wordlist2).encode(entropy);
        return words.join(isJapanese(wordlist2) ? "\u3000" : " ");
      }
      exports.entropyToMnemonic = entropyToMnemonic;
      function validateMnemonic2(mnemonic, wordlist2) {
        try {
          mnemonicToEntropy(mnemonic, wordlist2);
        } catch (e) {
          return false;
        }
        return true;
      }
      exports.validateMnemonic = validateMnemonic2;
      var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
      function mnemonicToSeed(mnemonic, passphrase = "") {
        return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
      }
      exports.mnemonicToSeed = mnemonicToSeed;
      function mnemonicToSeedSync2(mnemonic, passphrase = "") {
        return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
      }
      exports.mnemonicToSeedSync = mnemonicToSeedSync2;
    }
  });

  // node_modules/alpinejs/dist/module.esm.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
    queue.length = 0;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i) => i());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i) => i());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var recordQueue = [];
  var willProcessRecordQueue = false;
  function flushObserver() {
    recordQueue = recordQueue.concat(observer.takeRecords());
    if (recordQueue.length && !willProcessRecordQueue) {
      willProcessRecordQueue = true;
      queueMicrotask(() => {
        processRecordQueue();
        willProcessRecordQueue = false;
      });
    }
  }
  function processRecordQueue() {
    onMutate(recordQueue);
    recordQueue.length = 0;
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = [];
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i = 0; i < mutations.length; i++) {
      if (mutations[i].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i].type === "childList") {
        mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
        mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
      }
      if (mutations[i].type === "attributes") {
        let el = mutations[i].target;
        let name = mutations[i].attributeName;
        let oldValue = mutations[i].oldValue;
        let add22 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add22();
        } else if (el.hasAttribute(name)) {
          remove();
          add22();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i) => i(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.includes(node))
        continue;
      onElRemoveds.forEach((i) => i(node));
      if (node._x_cleanups) {
        while (node._x_cleanups.length)
          node._x_cleanups.pop()();
      }
    }
    addedNodes.forEach((node) => {
      node._x_ignoreSelf = true;
      node._x_ignore = true;
    });
    for (let node of addedNodes) {
      if (removedNodes.includes(node))
        continue;
      if (!node.isConnected)
        continue;
      delete node._x_ignoreSelf;
      delete node._x_ignore;
      onElAddeds.forEach((i) => i(node));
      node._x_ignore = true;
      node._x_ignoreSelf = true;
    }
    addedNodes.forEach((node) => {
      delete node._x_ignoreSelf;
      delete node._x_ignore;
    });
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
    };
  }
  function refreshScope(element, scope2) {
    let existingScope = element._x_dataStack[0];
    Object.entries(scope2).forEach(([key, value]) => {
      existingScope[key] = value;
    });
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    let thisProxy = new Proxy({}, {
      ownKeys: () => {
        return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
      },
      has: (target, name) => {
        return objects.some((obj) => obj.hasOwnProperty(name));
      },
      get: (target, name) => {
        return (objects.find((obj) => {
          if (obj.hasOwnProperty(name)) {
            let descriptor = Object.getOwnPropertyDescriptor(obj, name);
            if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {
              return true;
            }
            if ((descriptor.get || descriptor.set) && descriptor.enumerable) {
              let getter = descriptor.get;
              let setter = descriptor.set;
              let property = descriptor;
              getter = getter && getter.bind(thisProxy);
              setter = setter && setter.bind(thisProxy);
              if (getter)
                getter._x_alreadyBound = true;
              if (setter)
                setter._x_alreadyBound = true;
              Object.defineProperty(obj, name, {
                ...property,
                get: getter,
                set: setter
              });
            }
            return true;
          }
          return false;
        }) || {})[name];
      },
      set: (target, name, value) => {
        let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
        if (closestObjectWithKey) {
          closestObjectWithKey[name] = value;
        } else {
          objects[objects.length - 1][name] = value;
        }
        return true;
      }
    });
    return thisProxy;
  }
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          let [utilities, cleanup2] = getElementBoundUtilities(el);
          utilities = { interceptor, ...utilities };
          onElRemoved(el, cleanup2);
          return callback(el, utilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e) {
      handleError(e, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    Object.assign(error2, { el, expression });
    console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    callback();
    shouldAutoEvaluateFunctions = cache;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)\s/.test(expression) ? `(() => { ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        return new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i) => i());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler3 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler3.inline && handler3.inline(el, directive2, utilities);
      handler3 = handler3.bind(handler3, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i) => i;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i) => i.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "radio",
    "tabs",
    "switch",
    "disclosure",
    "menu",
    "listbox",
    "list",
    "item",
    "combobox",
    "bind",
    "init",
    "for",
    "mask",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a, b) {
    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(new CustomEvent(name, {
      detail,
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback, false);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  function start() {
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  function initTree(el, walker = walk) {
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        directives(el2, el2.attributes).forEach((handle) => handle());
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root) {
    walk(root, (el) => cleanupAttributes(el));
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split2 = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split2 = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool2]) => bool2 ? split2(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool2]) => !bool2 ? split2(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i) => {
      if (el.classList.contains(i)) {
        el.classList.remove(i);
        removed.push(i);
      }
    });
    forAdd.forEach((i) => {
      if (!el.classList.contains(i)) {
        el.classList.add(i);
        added.push(i);
      }
    });
    return () => {
      removed.forEach((i) => el.classList.add(i));
      added.forEach((i) => el.classList.remove(i));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (!expression) {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      enter: (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      leave: (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0);
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick22 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick22(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick22(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i]) => i());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e) => {
            if (!e.isFromCancelledTransition)
              throw e;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (el.type === "radio") {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    } else if (el.type === "checkbox") {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function isBooleanAttr(attrName) {
    const booleanAttributes = [
      "disabled",
      "checked",
      "required",
      "readonly",
      "hidden",
      "open",
      "selected",
      "autofocus",
      "itemscope",
      "multiple",
      "novalidate",
      "allowfullscreen",
      "allowpaymentrequest",
      "formnovalidate",
      "autoplay",
      "controls",
      "loop",
      "muted",
      "playsinline",
      "default",
      "ismap",
      "reversed",
      "async",
      "defer",
      "nomodule"
    ];
    return booleanAttributes.includes(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function plugin(callback) {
    callback(alpine_default);
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
    initInterceptors(stores[name]);
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.10.5",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    setReactivityEngine,
    closestDataStack,
    skipDuringClone,
    addRootSelector,
    addInitSelector,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    setEvaluator,
    mergeProxies,
    findClosest,
    closestRoot,
    interceptor,
    transition,
    setStyles,
    mutateDom,
    directive,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    bound: getBinding,
    $data: scope,
    data,
    bind: bind2
  };
  var alpine_default = Alpine;
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var extend = Object.assign;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add22 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add22);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add22(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add22(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add22(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add22(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add22(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add22(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add22(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add22(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = method.apply(arr, args);
      if (res === -1 || res === false) {
        return method.apply(arr, args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    const method = Array.prototype[key];
    arrayInstrumentations[key] = function(...args) {
      pauseTracking();
      const res = method.apply(this, args);
      resetTracking();
      return res;
    };
  });
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  var mutableInstrumentations = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  var shallowInstrumentations = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  var readonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  var shallowReadonlyInstrumentations = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
  });
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed["__v_raw"]) || observed;
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, effect: effect3 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let firstTime = true;
    let oldValue;
    let effectReference = effect3(() => evaluate2((value) => {
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    }));
    el._x_effects.delete(effectReference);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    let currentEl = el;
    while (currentEl) {
      if (currentEl._x_refs)
        refObjects.push(currentEl._x_refs);
      currentEl = currentEl.parentNode;
    }
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el) => (name, key = null) => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i) => result = i);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { __placeholder: val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      effect3(() => innerSet(outerGet()));
      effect3(() => outerSet(innerGet()));
    });
  });
  directive("teleport", (el, { expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = document.querySelector(expression);
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e) => {
          e.stopPropagation();
          el.dispatchEvent(new e.constructor(e.type, e));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      target.appendChild(clone2);
      initTree(clone2);
      clone2._x_ignore = true;
    });
    cleanup2(() => clone2.remove());
  });
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", (el, { expression }, { effect: effect3 }) => effect3(evaluateLater(el, expression)));
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler3 = (e) => callback(e);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("prevent"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.preventDefault();
        next(e);
      });
    if (modifiers.includes("stop"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.stopPropagation();
        next(e);
      });
    if (modifiers.includes("self"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.target === el && next(e);
      });
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler3 = wrapHandler(handler3, (next, e) => {
        if (el.contains(e.target))
          return;
        if (e.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e);
      });
    }
    if (modifiers.includes("once")) {
      handler3 = wrapHandler(handler3, (next, e) => {
        next(e);
        listenerTarget.removeEventListener(event, handler3, options);
      });
    }
    handler3 = wrapHandler(handler3, (next, e) => {
      if (isKeyEvent(event)) {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
          return;
        }
      }
      next(e);
    });
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = debounce(handler3, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = throttle(handler3, wait);
    }
    listenerTarget.addEventListener(event, handler3, options);
    return () => {
      listenerTarget.removeEventListener(event, handler3, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter((i) => {
      return !["window", "document", "prevent", "stop", "once"].includes(i);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyToModifiers(e.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      ctrl: "control",
      slash: "/",
      space: "-",
      spacebar: "-",
      cmd: "meta",
      esc: "escape",
      up: "arrow-up",
      down: "arrow-down",
      left: "arrow-left",
      right: "arrow-right",
      period: ".",
      equal: "="
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    let evaluateAssignment = evaluateLater(el, assignmentExpression);
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);
    let removeListener = on(el, event, modifiers, (e) => {
      evaluateAssignment(() => {
      }, { scope: {
        $event: e,
        rightSideOfExpression: assigmentFunction
      } });
    });
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);
    el._x_model = {
      get() {
        let result;
        evaluate2((value) => result = value);
        return result;
      },
      set(value) {
        evaluateSetModel(() => {
        }, { scope: { __placeholder: value } });
      }
    };
    el._x_forceModelUpdate = () => {
      evaluate2((value) => {
        if (value === void 0 && expression.match(/\./))
          value = "";
        window.fromModel = true;
        mutateDom(() => bind(el, "value", value));
        delete window.fromModel;
      });
    };
    effect3(() => {
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate();
    });
  });
  function generateAssignmentFunction(el, modifiers, expression) {
    if (el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    return (event, currentValue) => {
      return mutateDom(() => {
        if (event instanceof CustomEvent && event.detail !== void 0) {
          return event.detail || event.target.value;
        } else if (el.type === "checkbox") {
          if (Array.isArray(currentValue)) {
            let newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;
            return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
          } else {
            return event.target.checked;
          }
        } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
          return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          }) : Array.from(event.target.selectedOptions).map((option) => {
            return option.value || option.text;
          });
        } else {
          let rawValue = event.target.value;
          return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
        }
      });
    };
  }
  function safeParseNumber(rawValue) {
    let number2 = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number2) ? number2 : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  directive("bind", (el, { value, modifiers, expression, original }, { effect: effect3 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
  });
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", skipDuringClone((el, { expression }, { cleanup: cleanup2 }) => {
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  }));
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once((value) => value ? show() : hide(), (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    });
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(el, el._x_keyExpression || "index");
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => el2.remove());
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i) => typeof i === "object" && !Array.isArray(i);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i) => i + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i = 0; i < items.length; i++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
          evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i = 0; i < prevKeys.length; i++) {
        let key = prevKeys[i];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i, 0, key);
          adds.push([lastKey, i]);
        } else if (prevIndex !== i) {
          let keyInSpot = prevKeys.splice(i, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i = 0; i < removes.length; i++) {
        let key = removes[i];
        if (!!lookup[key]._x_effects) {
          lookup[key]._x_effects.forEach(dequeueJob);
        }
        lookup[key].remove();
        lookup[key] = null;
        delete lookup[key];
      }
      for (let i = 0; i < moves.length; i++) {
        let [keyInSpot, keyForSpot] = moves[i];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i = 0; i < adds.length; i++) {
        let [lastKey2, index] = adds[i];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        addScopeToNode(clone2, reactive(scope2), templateEl);
        mutateDom(() => {
          lastEl.after(clone2);
          initTree(clone2);
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i = 0; i < sames.length; i++) {
        refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
      names.forEach((name, i) => {
        scopeVariables[name] = item[i];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler2() {
  }
  handler2.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler2);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        initTree(clone2);
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        walk(clone2, (node) => {
          if (!!node._x_effects) {
            node._x_effects.forEach(dequeueJob);
          }
        });
        clone2.remove();
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e) => {
      evaluate2(() => {
      }, { scope: { $event: e }, params: [e] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName2, slug) {
    directive(directiveName2, (el) => warn(`You can't use [x-${directiveName2}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default = alpine_default;
  var module_default = src_default;

  // Shared (Extension)/Resources/utilities/utils.js
  var storage = browser.storage.local;
  var RECOMMENDED_RELAYS = [
    new URL("wss://relay.damus.io"),
    new URL("wss://relay.snort.social"),
    new URL("wss://nos.lol"),
    new URL("wss://brb.io"),
    new URL("wss://nostr.orangepill.dev")
  ];
  async function getProfiles() {
    let profiles = await storage.get({ profiles: [] });
    return profiles.profiles;
  }
  async function generatePrivateKey() {
    return await browser.runtime.sendMessage({ kind: "generatePrivateKey" });
  }
  async function generateProfile(name = "Default") {
    return {
      name,
      privKey: await generatePrivateKey(),
      hosts: {},
      relays: [],
      delegate: false,
      relayReminder: true
    };
  }
  function validateKey(key) {
    const hexMatch = /^[\da-f]{64}$/i.test(key);
    const b32Match = /^nsec1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}$/.test(key);
    return hexMatch || b32Match;
  }

  // node_modules/@noble/secp256k1/lib/esm/index.js
  var nodeCrypto = __toESM(require_crypto(), 1);
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _3n = BigInt(3);
  var _8n = BigInt(8);
  var CURVE = Object.freeze({
    a: _0n,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: _1n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  var divNearest = (a, b) => (a + b / _2n) / b;
  var endo = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(k) {
      const { n } = CURVE;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  };
  var fieldLen = 32;
  var groupLen = 32;
  var hashLen = 32;
  var compressedLen = fieldLen + 1;
  var uncompressedLen = 2 * fieldLen + 1;
  function weierstrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
  }
  var USE_ENDOMORPHISM = CURVE.a === _0n;
  var ShaError = class extends Error {
    constructor(message) {
      super(message);
    }
  };
  function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
  }
  var JacobianPoint = class {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    static fromAffine(p) {
      if (!(p instanceof Point)) {
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      }
      if (p.equals(Point.ZERO))
        return JacobianPoint.ZERO;
      return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
      const toInv = invertBatch(points.map((p) => p.z));
      return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      const Z1Z1 = mod(Z1 * Z1);
      const Z2Z2 = mod(Z2 * Z2);
      const U1 = mod(X1 * Z2Z2);
      const U2 = mod(X2 * Z1Z1);
      const S1 = mod(mod(Y1 * Z2) * Z2Z2);
      const S2 = mod(mod(Y2 * Z1) * Z1Z1);
      return U1 === U2 && S1 === S2;
    }
    negate() {
      return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
      const { x: X1, y: Y1, z: Z1 } = this;
      const A = mod(X1 * X1);
      const B = mod(Y1 * Y1);
      const C = mod(B * B);
      const x1b = X1 + B;
      const D = mod(_2n * (mod(x1b * x1b) - A - C));
      const E = mod(_3n * A);
      const F = mod(E * E);
      const X3 = mod(F - _2n * D);
      const Y3 = mod(E * (D - X3) - _8n * C);
      const Z3 = mod(_2n * Y1 * Z1);
      return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
      assertJacPoint(other);
      const { x: X1, y: Y1, z: Z1 } = this;
      const { x: X2, y: Y2, z: Z2 } = other;
      if (X2 === _0n || Y2 === _0n)
        return this;
      if (X1 === _0n || Y1 === _0n)
        return other;
      const Z1Z1 = mod(Z1 * Z1);
      const Z2Z2 = mod(Z2 * Z2);
      const U1 = mod(X1 * Z2Z2);
      const U2 = mod(X2 * Z1Z1);
      const S1 = mod(mod(Y1 * Z2) * Z2Z2);
      const S2 = mod(mod(Y2 * Z1) * Z1Z1);
      const H = mod(U2 - U1);
      const r = mod(S2 - S1);
      if (H === _0n) {
        if (r === _0n) {
          return this.double();
        } else {
          return JacobianPoint.ZERO;
        }
      }
      const HH = mod(H * H);
      const HHH = mod(H * HH);
      const V = mod(U1 * HH);
      const X3 = mod(r * r - HHH - _2n * V);
      const Y3 = mod(r * (V - X3) - S1 * HHH);
      const Z3 = mod(Z1 * Z2 * H);
      return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
      const P0 = JacobianPoint.ZERO;
      if (typeof scalar === "bigint" && scalar === _0n)
        return P0;
      let n = normalizeScalar(scalar);
      if (n === _1n)
        return this;
      if (!USE_ENDOMORPHISM) {
        let p = P0;
        let d2 = this;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d2);
          d2 = d2.double();
          n >>= _1n;
        }
        return p;
      }
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = P0;
      let k2p = P0;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
          k1p = k1p.add(d);
        if (k2 & _1n)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n;
        k2 >>= _1n;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
      return k1p.add(k2p);
    }
    precomputeWindow(W) {
      const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
      const points = [];
      let p = this;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < 2 ** (W - 1); i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    }
    wNAF(n, affinePoint) {
      if (!affinePoint && this.equals(JacobianPoint.BASE))
        affinePoint = Point.BASE;
      const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
      if (256 % W) {
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      }
      let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
      if (!precomputes) {
        precomputes = this.precomputeWindow(W);
        if (affinePoint && W !== 1) {
          precomputes = JacobianPoint.normalizeZ(precomputes);
          pointPrecomputes.set(affinePoint, precomputes);
        }
      }
      let p = JacobianPoint.ZERO;
      let f2 = JacobianPoint.BASE;
      const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
      const windowSize = 2 ** (W - 1);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    }
    multiply(scalar, affinePoint) {
      let n = normalizeScalar(scalar);
      let point;
      let fake;
      if (USE_ENDOMORPHISM) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
        let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
        k1p = constTimeNegate(k1neg, k1p);
        k2p = constTimeNegate(k2neg, k2p);
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n, affinePoint);
        point = p;
        fake = f2;
      }
      return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ) {
      const { x, y, z } = this;
      const is0 = this.equals(JacobianPoint.ZERO);
      if (invZ == null)
        invZ = is0 ? _8n : invert(z);
      const iz1 = invZ;
      const iz2 = mod(iz1 * iz1);
      const iz3 = mod(iz2 * iz1);
      const ax = mod(x * iz2);
      const ay = mod(y * iz3);
      const zz = mod(z * iz1);
      if (is0)
        return Point.ZERO;
      if (zz !== _1n)
        throw new Error("invZ was invalid");
      return new Point(ax, ay);
    }
  };
  JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
  JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
  function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var Point = class {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    hasEvenY() {
      return this.y % _2n === _0n;
    }
    static fromCompressedHex(bytes2) {
      const isShort = bytes2.length === 32;
      const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
      if (!isValidFieldElement(x))
        throw new Error("Point is not on curve");
      const y2 = weierstrass(x);
      let y = sqrtMod(y2);
      const isYOdd = (y & _1n) === _1n;
      if (isShort) {
        if (isYOdd)
          y = mod(-y);
      } else {
        const isFirstByteOdd = (bytes2[0] & 1) === 1;
        if (isFirstByteOdd !== isYOdd)
          y = mod(-y);
      }
      const point = new Point(x, y);
      point.assertValidity();
      return point;
    }
    static fromUncompressedHex(bytes2) {
      const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
      const y = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
      const point = new Point(x, y);
      point.assertValidity();
      return point;
    }
    static fromHex(hex2) {
      const bytes2 = ensureBytes(hex2);
      const len = bytes2.length;
      const header = bytes2[0];
      if (len === fieldLen)
        return this.fromCompressedHex(bytes2);
      if (len === compressedLen && (header === 2 || header === 3)) {
        return this.fromCompressedHex(bytes2);
      }
      if (len === uncompressedLen && header === 4)
        return this.fromUncompressedHex(bytes2);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
      const { r, s } = normalizeSignature(signature);
      if (![0, 1, 2, 3].includes(recovery))
        throw new Error("Cannot recover: invalid recovery bit");
      const h = truncateHash(ensureBytes(msgHash));
      const { n } = CURVE;
      const radj = recovery === 2 || recovery === 3 ? r + n : r;
      const rinv = invert(radj, n);
      const u1 = mod(-h * rinv, n);
      const u2 = mod(s * rinv, n);
      const prefix2 = recovery & 1 ? "03" : "02";
      const R = Point.fromHex(prefix2 + numTo32bStr(radj));
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("Cannot recover signature: point at infinify");
      Q.assertValidity();
      return Q;
    }
    toRawBytes(isCompressed = false) {
      return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
      const x = numTo32bStr(this.x);
      if (isCompressed) {
        const prefix2 = this.hasEvenY() ? "02" : "03";
        return `${prefix2}${x}`;
      } else {
        return `04${x}${numTo32bStr(this.y)}`;
      }
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const msg = "Point is not on elliptic curve";
      const { x, y } = this;
      if (!isValidFieldElement(x) || !isValidFieldElement(y))
        throw new Error(msg);
      const left = mod(y * y);
      const right = weierstrass(x);
      if (mod(left - right) !== _0n)
        throw new Error(msg);
    }
    equals(other) {
      return this.x === other.x && this.y === other.y;
    }
    negate() {
      return new Point(this.x, mod(-this.y));
    }
    double() {
      return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const P = JacobianPoint.fromAffine(this);
      const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
      const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
      const sum = aP.add(bQ);
      return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
    }
  };
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
  Point.ZERO = new Point(_0n, _0n);
  function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
  }
  function parseDERInt(data2) {
    if (data2.length < 2 || data2[0] !== 2) {
      throw new Error(`Invalid signature integer tag: ${bytesToHex(data2)}`);
    }
    const len = data2[1];
    const res = data2.subarray(2, len + 2);
    if (!len || res.length !== len) {
      throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0 && res[1] <= 127) {
      throw new Error("Invalid signature integer: trailing length");
    }
    return { data: bytesToNumber(res), left: data2.subarray(len + 2) };
  }
  function parseDERSignature(data2) {
    if (data2.length < 2 || data2[0] != 48) {
      throw new Error(`Invalid signature tag: ${bytesToHex(data2)}`);
    }
    if (data2[1] !== data2.length - 2) {
      throw new Error("Invalid signature: incorrect length");
    }
    const { data: r, left: sBytes } = parseDERInt(data2.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
      throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
  }
  var Signature = class {
    constructor(r, s) {
      this.r = r;
      this.s = s;
      this.assertValidity();
    }
    static fromCompact(hex2) {
      const arr = hex2 instanceof Uint8Array;
      const name = "Signature.fromCompact";
      if (typeof hex2 !== "string" && !arr)
        throw new TypeError(`${name}: Expected string or Uint8Array`);
      const str = arr ? bytesToHex(hex2) : hex2;
      if (str.length !== 128)
        throw new Error(`${name}: Expected 64-byte hex`);
      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex2) {
      const arr = hex2 instanceof Uint8Array;
      if (typeof hex2 !== "string" && !arr)
        throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
      const { r, s } = parseDERSignature(arr ? hex2 : hexToBytes(hex2));
      return new Signature(r, s);
    }
    static fromHex(hex2) {
      return this.fromDER(hex2);
    }
    assertValidity() {
      const { r, s } = this;
      if (!isWithinCurveOrder(r))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!isWithinCurveOrder(s))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const HALF = CURVE.n >> _1n;
      return this.s > HALF;
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      const sHex = sliceDER(numberToHexUnpadded(this.s));
      const rHex = sliceDER(numberToHexUnpadded(this.r));
      const sHexL = sHex.length / 2;
      const rHexL = rHex.length / 2;
      const sLen = numberToHexUnpadded(sHexL);
      const rLen = numberToHexUnpadded(rHexL);
      const length = numberToHexUnpadded(rHexL + sHexL + 4);
      return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
  };
  function concatBytes(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  }
  var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let hex2 = "";
    for (let i = 0; i < uint8a.length; i++) {
      hex2 += hexes[uint8a[i]];
    }
    return hex2;
  }
  var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function numTo32bStr(num) {
    if (typeof num !== "bigint")
      throw new Error("Expected bigint");
    if (!(_0n <= num && num < POW_2_256))
      throw new Error("Expected number 0 <= n < 2^256");
    return num.toString(16).padStart(64, "0");
  }
  function numTo32b(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return b;
  }
  function numberToHexUnpadded(num) {
    const hex2 = num.toString(16);
    return hex2.length & 1 ? `0${hex2}` : hex2;
  }
  function hexToNumber(hex2) {
    if (typeof hex2 !== "string") {
      throw new TypeError("hexToNumber: expected string, got " + typeof hex2);
    }
    return BigInt(`0x${hex2}`);
  }
  function hexToBytes(hex2) {
    if (typeof hex2 !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
    }
    if (hex2.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + hex2.length);
    const array = new Uint8Array(hex2.length / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex2.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumber(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function ensureBytes(hex2) {
    return hex2 instanceof Uint8Array ? Uint8Array.from(hex2) : hexToBytes(hex2);
  }
  function normalizeScalar(num) {
    if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
      return BigInt(num);
    if (typeof num === "bigint" && isWithinCurveOrder(num))
      return num;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
  }
  function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
      res *= res;
      res %= P;
    }
    return res;
  }
  function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = x * x * x % P;
    const b3 = b2 * b2 * x % P;
    const b6 = pow2(b3, _3n) * b3 % P;
    const b9 = pow2(b6, _3n) * b3 % P;
    const b11 = pow2(b9, _2n) * b2 % P;
    const b22 = pow2(b11, _11n) * b11 % P;
    const b44 = pow2(b22, _22n) * b22 % P;
    const b88 = pow2(b44, _44n) * b44 % P;
    const b176 = pow2(b88, _88n) * b88 % P;
    const b220 = pow2(b176, _44n) * b44 % P;
    const b223 = pow2(b220, _3n) * b3 % P;
    const t1 = pow2(b223, _23n) * b22 % P;
    const t2 = pow2(t1, _6n) * b2 % P;
    const rt = pow2(t2, _2n);
    const xc = rt * rt % P;
    if (xc !== x)
      throw new Error("Cannot find square root");
    return rt;
  }
  function invert(number2, modulo = CURVE.P) {
    if (number2 === _0n || modulo <= _0n) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd2 = b;
    if (gcd2 !== _1n)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (num === _0n)
        return acc;
      scratch[i] = acc;
      return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
      if (num === _0n)
        return acc;
      scratch[i] = mod(acc * scratch[i], p);
      return mod(acc * num, p);
    }, inverted);
    return scratch;
  }
  function bits2int_2(bytes2) {
    const delta = bytes2.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes2);
    return delta > 0 ? num >> BigInt(delta) : num;
  }
  function truncateHash(hash2, truncateOnly = false) {
    const h = bits2int_2(hash2);
    if (truncateOnly)
      return h;
    const { n } = CURVE;
    return h >= n ? h - n : h;
  }
  var _sha256Sync;
  var _hmacSha256Sync;
  var HmacDrbg = class {
    constructor(hashLen2, qByteLen) {
      this.hashLen = hashLen2;
      this.qByteLen = qByteLen;
      if (typeof hashLen2 !== "number" || hashLen2 < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(hashLen2).fill(1);
      this.k = new Uint8Array(hashLen2).fill(0);
      this.counter = 0;
    }
    hmac(...values) {
      return utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
      return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
      if (typeof _hmacSha256Sync !== "function")
        throw new ShaError("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
      this.v = await this.hmac(this.v);
      if (seed.length === 0)
        return;
      this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
      this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
      this.checkSync();
      this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
      this.v = this.hmacSync(this.v);
      if (seed.length === 0)
        return;
      this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
      this.v = this.hmacSync(this.v);
    }
    async generate() {
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = await this.hmac(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes(...out);
    }
    generateSync() {
      this.checkSync();
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = this.hmacSync(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes(...out);
    }
  };
  function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
  }
  function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
  }
  function kmdToSig(kBytes, m, d, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k))
      return;
    const kinv = invert(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n)
      return;
    const s = mod(kinv * mod(m + d * r, n), n);
    if (s === _0n)
      return;
    let sig = new Signature(r, s);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    if (lowS && sig.hasHighS()) {
      sig = sig.normalizeS();
      recovery ^= 1;
    }
    return { sig, recovery };
  }
  function normalizePrivateKey(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
      num = BigInt(key);
    } else if (typeof key === "string") {
      if (key.length !== 2 * groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = hexToNumber(key);
    } else if (key instanceof Uint8Array) {
      if (key.length !== groupLen)
        throw new Error("Expected 32 bytes of private key");
      num = bytesToNumber(key);
    } else {
      throw new TypeError("Expected valid private key");
    }
    if (!isWithinCurveOrder(num))
      throw new Error("Expected private key: 0 < key < n");
    return num;
  }
  function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
      publicKey.assertValidity();
      return publicKey;
    } else {
      return Point.fromHex(publicKey);
    }
  }
  function normalizeSignature(signature) {
    if (signature instanceof Signature) {
      signature.assertValidity();
      return signature;
    }
    try {
      return Signature.fromDER(signature);
    } catch (error2) {
      return Signature.fromCompact(signature);
    }
  }
  function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === compressedLen * 2 || len === uncompressedLen * 2;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isProbPub(privateA))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!isProbPub(publicB))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
  }
  function bits2int(bytes2) {
    const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
    return bytesToNumber(slice);
  }
  function bits2octets(bytes2) {
    const z1 = bits2int(bytes2);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
  }
  function int2octets(num) {
    return numTo32b(num);
  }
  function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
      throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d), bits2octets(h1)];
    if (extraEntropy != null) {
      if (extraEntropy === true)
        extraEntropy = utils.randomBytes(fieldLen);
      const e = ensureBytes(extraEntropy);
      if (e.length !== fieldLen)
        throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
      seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return { seed, m, d };
  }
  function finalizeSig(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
  }
  function signSync(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    drbg.reseedSync(seed);
    let sig;
    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
      drbg.reseedSync();
    return finalizeSig(sig, opts);
  }
  var vopts = { strict: true };
  function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
      sig = normalizeSignature(signature);
      msgHash = ensureBytes(msgHash);
    } catch (error2) {
      return false;
    }
    const { r, s } = sig;
    if (opts.strict && sig.hasHighS())
      return false;
    const h = truncateHash(msgHash);
    let P;
    try {
      P = normalizePublicKey(publicKey);
    } catch (error2) {
      return false;
    }
    const { n } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R)
      return false;
    const v = mod(R.x, n);
    return v === r;
  }
  function schnorrChallengeFinalize(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
  }
  var SchnorrSignature = class {
    constructor(r, s) {
      this.r = r;
      this.s = s;
      this.assertValidity();
    }
    static fromHex(hex2) {
      const bytes2 = ensureBytes(hex2);
      if (bytes2.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes2.length}`);
      const r = bytesToNumber(bytes2.subarray(0, 32));
      const s = bytesToNumber(bytes2.subarray(32, 64));
      return new SchnorrSignature(r, s);
    }
    assertValidity() {
      const { r, s } = this;
      if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
        throw new Error("Invalid signature");
    }
    toHex() {
      return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
      return hexToBytes(this.toHex());
    }
  };
  function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
  }
  var InternalSchnorrSignature = class {
    constructor(message, privateKey, auxRand = utils.randomBytes()) {
      if (message == null)
        throw new TypeError(`sign: Expected valid message, not "${message}"`);
      this.m = ensureBytes(message);
      const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
      this.px = x;
      this.d = scalar;
      this.rand = ensureBytes(auxRand);
      if (this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(priv) {
      const point = Point.fromPrivateKey(priv);
      const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
      return { point, scalar, x: point.toRawX() };
    }
    initNonce(d, t0h) {
      return numTo32b(d ^ bytesToNumber(t0h));
    }
    finalizeNonce(k0h) {
      const k0 = mod(bytesToNumber(k0h), CURVE.n);
      if (k0 === _0n)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: R, x: rx, scalar: k } = this.getScalar(k0);
      return { R, rx, k };
    }
    finalizeSig(R, k, e, d) {
      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m, d, px, rand } = this;
      const tag = utils.taggedHash;
      const t = this.initNonce(d, await tag(TAGS.aux, rand));
      const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
      const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
      const sig = this.finalizeSig(R, k, e, d);
      if (!await schnorrVerify(sig, m, px))
        this.error();
      return sig;
    }
    calcSync() {
      const { m, d, px, rand } = this;
      const tag = utils.taggedHashSync;
      const t = this.initNonce(d, tag(TAGS.aux, rand));
      const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
      const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
      const sig = this.finalizeSig(R, k, e, d);
      if (!schnorrVerifySync(sig, m, px))
        this.error();
      return sig;
    }
  };
  async function schnorrSign(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
  }
  function schnorrSignSync(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
  }
  function initSchnorrVerify(signature, message, publicKey) {
    const raw2 = signature instanceof SchnorrSignature;
    const sig = raw2 ? signature : SchnorrSignature.fromHex(signature);
    if (raw2)
      sig.assertValidity();
    return {
      ...sig,
      m: ensureBytes(message),
      P: normalizePublicKey(publicKey)
    };
  }
  function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !R.hasEvenY() || R.x !== r)
      return false;
    return true;
  }
  async function schnorrVerify(signature, message, publicKey) {
    try {
      const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
      const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
      return finalizeSchnorrVerify(r, P, s, e);
    } catch (error2) {
      return false;
    }
  }
  function schnorrVerifySync(signature, message, publicKey) {
    try {
      const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
      const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
      return finalizeSchnorrVerify(r, P, s, e);
    } catch (error2) {
      if (error2 instanceof ShaError)
        throw error2;
      return false;
    }
  }
  var schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync
  };
  Point.BASE._setWindowSize(8);
  var crypto2 = {
    node: nodeCrypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
  };
  var TAGS = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  };
  var TAGGED_HASH_PREFIXES = {};
  var utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey(privateKey) {
      try {
        normalizePrivateKey(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash2) => {
      hash2 = ensureBytes(hash2);
      const minLen = groupLen + 8;
      if (hash2.length < minLen || hash2.length > 1024) {
        throw new Error(`Expected valid bytes of private key as per FIPS 186`);
      }
      const num = mod(bytesToNumber(hash2), CURVE.n - _1n) + _1n;
      return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
      if (crypto2.web) {
        return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto2.node) {
        const { randomBytes: randomBytes2 } = crypto2.node;
        return Uint8Array.from(randomBytes2(bytesLength));
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
    precompute(windowSize = 8, point = Point.BASE) {
      const cached = point === Point.BASE ? point : new Point(point.x, point.y);
      cached._setWindowSize(windowSize);
      cached.multiply(_3n);
      return cached;
    },
    sha256: async (...messages) => {
      if (crypto2.web) {
        const buffer = await crypto2.web.subtle.digest("SHA-256", concatBytes(...messages));
        return new Uint8Array(buffer);
      } else if (crypto2.node) {
        const { createHash } = crypto2.node;
        const hash2 = createHash("sha256");
        messages.forEach((m) => hash2.update(m));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have sha256 function");
      }
    },
    hmacSha256: async (key, ...messages) => {
      if (crypto2.web) {
        const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
        const message = concatBytes(...messages);
        const buffer = await crypto2.web.subtle.sign("HMAC", ckey, message);
        return new Uint8Array(buffer);
      } else if (crypto2.node) {
        const { createHmac } = crypto2.node;
        const hash2 = createHmac("sha256", key);
        messages.forEach((m) => hash2.update(m));
        return Uint8Array.from(hash2.digest());
      } else {
        throw new Error("The environment doesn't have hmac-sha256 function");
      }
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (tag, ...messages) => {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages) => {
      if (typeof _sha256Sync !== "function")
        throw new ShaError("sha256Sync is undefined, you need to set it");
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = concatBytes(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return _sha256Sync(tagP, ...messages);
    },
    _JacobianPoint: JacobianPoint
  };
  Object.defineProperties(utils, {
    sha256Sync: {
      configurable: false,
      get() {
        return _sha256Sync;
      },
      set(val) {
        if (!_sha256Sync)
          _sha256Sync = val;
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get() {
        return _hmacSha256Sync;
      },
      set(val) {
        if (!_hmacSha256Sync)
          _hmacSha256Sync = val;
      }
    }
  });

  // node_modules/@noble/hashes/esm/cryptoBrowser.js
  var crypto3 = {
    node: void 0,
    web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
  };

  // node_modules/@noble/hashes/esm/utils.js
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  var nextTick2 = (() => {
    const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
    try {
      if (nodeRequire) {
        const { setImmediate } = nodeRequire("timers");
        return () => new Promise((resolve) => setImmediate(resolve));
      }
    } catch (e) {
    }
    return () => new Promise((resolve) => setTimeout(resolve, 0));
  })();
  function utf8ToBytes(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes(data2);
    if (!(data2 instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data2})`);
    return data2;
  }
  function assertNumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function assertHash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.init !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    assertNumber(hash2.outputLen);
    assertNumber(hash2.blockLen);
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    hashC.init = hashC.create;
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      return new Uint8Array(crypto3.node.randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  }

  // node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data2) {
      if (this.destroyed)
        throw new Error("instance is destroyed");
      const { view, buffer, blockLen, finished } = this;
      if (finished)
        throw new Error("digest() was already called");
      data2 = toBytes(data2);
      const len = data2.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data2);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      if (this.destroyed)
        throw new Error("instance is destroyed");
      if (!(out instanceof Uint8Array) || out.length < this.outputLen)
        throw new Error("_Sha2: Invalid output buffer");
      if (this.finished)
        throw new Error("digest() was already called");
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView(out);
      this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE3));
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = new Uint32Array(64);
  var SHA256 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = wrapConstructor(() => new SHA256());

  // node_modules/@scure/base/lib/esm/index.js
  function assertNumber2(n) {
    if (!Number.isSafeInteger(n))
      throw new Error(`Wrong integer: ${n}`);
  }
  function chain(...args) {
    const wrap = (a, b) => (c) => a(b(c));
    const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
    const decode2 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
    return { encode, decode: decode2 };
  }
  function alphabet(alphabet2) {
    return {
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i) => {
          assertNumber2(i);
          if (i < 0 || i >= alphabet2.length)
            throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
          return alphabet2[i];
        });
      },
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index = alphabet2.indexOf(letter);
          if (index === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
          return index;
        });
      }
    };
  }
  function join(separator = "") {
    if (typeof separator !== "string")
      throw new Error("join separator should be string");
    return {
      encode: (from) => {
        if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
          throw new Error("join.encode input should be array of strings");
        for (let i of from)
          if (typeof i !== "string")
            throw new Error(`join.encode: non-string input=${i}`);
        return from.join(separator);
      },
      decode: (to) => {
        if (typeof to !== "string")
          throw new Error("join.decode input should be string");
        return to.split(separator);
      }
    };
  }
  function padding(bits, chr = "=") {
    assertNumber2(bits);
    if (typeof chr !== "string")
      throw new Error("padding chr should be string");
    return {
      encode(data2) {
        if (!Array.isArray(data2) || data2.length && typeof data2[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i of data2)
          if (typeof i !== "string")
            throw new Error(`padding.encode: non-string input=${i}`);
        while (data2.length * bits % 8)
          data2.push(chr);
        return data2;
      },
      decode(input) {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i of input)
          if (typeof i !== "string")
            throw new Error(`padding.decode: non-string input=${i}`);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          if (!((end - 1) * bits % 8))
            throw new Error("Invalid padding: string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  function normalize(fn) {
    if (typeof fn !== "function")
      throw new Error("normalize fn should be function");
    return { encode: (from) => from, decode: (to) => fn(to) };
  }
  function convertRadix(data2, from, to) {
    if (from < 2)
      throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
      throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data2))
      throw new Error("convertRadix: data should be array");
    if (!data2.length)
      return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data2);
    digits.forEach((d) => {
      assertNumber2(d);
      if (d < 0 || d >= from)
        throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
      let carry = 0;
      let done = true;
      for (let i = pos; i < digits.length; i++) {
        const digit = digits[i];
        const digitBase = from * carry + digit;
        if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
          throw new Error("convertRadix: carry overflow");
        }
        carry = digitBase % to;
        digits[i] = Math.floor(digitBase / to);
        if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
          throw new Error("convertRadix: carry overflow");
        if (!done)
          continue;
        else if (!digits[i])
          pos = i;
        else
          done = false;
      }
      res.push(carry);
      if (done)
        break;
    }
    for (let i = 0; i < data2.length - 1 && data2[i] === 0; i++)
      res.push(0);
    return res.reverse();
  }
  var gcd = (a, b) => !b ? a : gcd(b, a % b);
  var radix2carry = (from, to) => from + (to - gcd(from, to));
  function convertRadix2(data2, from, to, padding2) {
    if (!Array.isArray(data2))
      throw new Error("convertRadix2: data should be array");
    if (from <= 0 || from > 32)
      throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
      throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data2) {
      assertNumber2(n);
      if (n >= 2 ** from)
        throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
      carry = carry << from | n;
      if (pos + from > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to)
        res.push((carry >> pos - to & mask) >>> 0);
      carry &= 2 ** pos - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding2 && pos >= from)
      throw new Error("Excess padding");
    if (!padding2 && carry)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  function radix(num) {
    assertNumber2(num);
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), 2 ** 8, num);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
      }
    };
  }
  function radix2(bits, revPadding = false) {
    assertNumber2(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    if (typeof fn !== "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e) {
      }
    };
  }
  function checksum(len, fn) {
    assertNumber2(len);
    if (typeof fn !== "function")
      throw new Error("checksum fn should be function");
    return {
      encode(data2) {
        if (!(data2 instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const checksum2 = fn(data2).slice(0, len);
        const res = new Uint8Array(data2.length + len);
        res.set(data2);
        res.set(checksum2, data2.length);
        return res;
      },
      decode(data2) {
        if (!(data2 instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data2.slice(0, -len);
        const newChecksum = fn(payload).slice(0, len);
        const oldChecksum = data2.slice(-len);
        for (let i = 0; i < len; i++)
          if (newChecksum[i] !== oldChecksum[i])
            throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
  var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
  var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
  var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
  var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
  var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
  var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  var base58xmr = {
    encode(data2) {
      let res = "";
      for (let i = 0; i < data2.length; i += 8) {
        const block = data2.subarray(i, i + 8);
        res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i = 0; i < str.length; i += 11) {
        const slice = str.slice(i, i + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
        const block = base58.decode(slice);
        for (let j = 0; j < block.length - blockLen; j++) {
          if (block[j] !== 0)
            throw new Error("base58xmr: wrong padding");
        }
        res = res.concat(Array.from(block.slice(block.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  var base58check = (sha2563) => chain(checksum(4, (data2) => sha2563(sha2563(data2))), base58);
  var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
  var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
      if ((b >> i & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
  }
  function bechChecksum(prefix2, words, encodingConst = 1) {
    const len = prefix2.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
      const c = prefix2.charCodeAt(i);
      if (c < 33 || c > 126)
        throw new Error(`Invalid prefix (${prefix2})`);
      chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
      chk = bech32Polymod(chk) ^ prefix2.charCodeAt(i) & 31;
    for (let v of words)
      chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
  }
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix2, words, limit = 90) {
      if (typeof prefix2 !== "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix2}`);
      if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
      const actualLength = prefix2.length + 7 + words.length;
      if (limit !== false && actualLength > limit)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      prefix2 = prefix2.toLowerCase();
      return `${prefix2}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix2, words, ENCODING_CONST)}`;
    }
    function decode2(str, limit = 90) {
      if (typeof str !== "string")
        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
      if (str.length < 8 || limit !== false && str.length > limit)
        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      str = lowered;
      const sepIndex = str.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix2 = str.slice(0, sepIndex);
      const _words2 = str.slice(sepIndex + 1);
      if (_words2.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
      const sum = bechChecksum(prefix2, words, ENCODING_CONST);
      if (!_words2.endsWith(sum))
        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return { prefix: prefix2, words };
    }
    const decodeUnsafe = unsafeWrapper(decode2);
    function decodeToBytes(str) {
      const { prefix: prefix2, words } = decode2(str, false);
      return { prefix: prefix2, words, bytes: fromWords(words) };
    }
    return { encode, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
  }
  var bech32 = genBech32("bech32");
  var bech32m = genBech32("bech32m");
  var utf8 = {
    encode: (data2) => new TextDecoder().decode(data2),
    decode: (str) => new TextEncoder().encode(str)
  };
  var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
    if (typeof s !== "string" || s.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
  }));
  var CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
  };
  var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

  // node_modules/nostr-tools/lib/nostr.esm.js
  var import_english = __toESM(require_english());
  var import_bip39 = __toESM(require_bip39());

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
  };
  var assert_default = assert;

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoBrowser.js
  var crypto4 = {
    node: void 0,
    web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
  };

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js
  var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE2)
    throw new Error("Non little-endian hardware is not supported");
  var hexes3 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex2(uint8a) {
    if (!(uint8a instanceof Uint8Array))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i = 0; i < uint8a.length; i++) {
      hex2 += hexes3[uint8a[i]];
    }
    return hex2;
  }
  function hexToBytes2(hex2) {
    if (typeof hex2 !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
    }
    if (hex2.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex2.length / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex2.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes2(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes2(data2);
    if (!(data2 instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data2})`);
    return data2;
  }
  function concatBytes2(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  }
  var Hash2 = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor2(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash2 {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      assert_default.hash(hash2);
      const key = toBytes2(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new TypeError("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      assert_default.exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
  hmac.create = (hash2, key) => new HMAC(hash2, key);

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint642(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA22 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data2) {
      assert_default.exists(this);
      const { view, buffer, blockLen } = this;
      data2 = toBytes2(data2);
      const len = data2.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data2);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
  var Pi = Id.map((i) => (9 * i + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
      j.push(j[i].map((k) => Rho[k]));
  var shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => new Uint8Array(i));
  var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
  var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
  var rotl = (word, shift) => word << shift | word >>> 32 - shift;
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  var BUF = new Uint32Array(16);
  var RIPEMD160 = class extends SHA22 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        BUF[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = wrapConstructor2(() => new RIPEMD160());

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js
  var Chi2 = (a, b, c) => a & b ^ ~a & c;
  var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K2 = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV2 = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W2 = new Uint32Array(64);
  var SHA2562 = class extends SHA22 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV2[0] | 0;
      this.B = IV2[1] | 0;
      this.C = IV2[2] | 0;
      this.D = IV2[3] | 0;
      this.E = IV2[4] | 0;
      this.F = IV2[5] | 0;
      this.G = IV2[6] | 0;
      this.H = IV2[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W2[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W2[i - 15];
        const W2 = SHA256_W2[i - 2];
        const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
        const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
        SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
        const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
        const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
        const T2 = sigma0 + Maj2(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W2.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var SHA224 = class extends SHA2562 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  };
  var sha2562 = wrapConstructor2(() => new SHA2562());
  var sha224 = wrapConstructor2(() => new SHA224());

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (h, l) => l;
  var rotr32L = (h, l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add2(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add: add2,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js
  var [SHA512_Kh, SHA512_Kl] = u64_default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n)));
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);
  var SHA512 = class extends SHA22 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var SHA512_224 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 2352822216 | 0;
      this.Al = 424955298 | 0;
      this.Bh = 1944164710 | 0;
      this.Bl = 2312950998 | 0;
      this.Ch = 502970286 | 0;
      this.Cl = 855612546 | 0;
      this.Dh = 1738396948 | 0;
      this.Dl = 1479516111 | 0;
      this.Eh = 258812777 | 0;
      this.El = 2077511080 | 0;
      this.Fh = 2011393907 | 0;
      this.Fl = 79989058 | 0;
      this.Gh = 1067287976 | 0;
      this.Gl = 1780299464 | 0;
      this.Hh = 286451373 | 0;
      this.Hl = 2446758561 | 0;
      this.outputLen = 28;
    }
  };
  var SHA512_256 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 573645204 | 0;
      this.Al = 4230739756 | 0;
      this.Bh = 2673172387 | 0;
      this.Bl = 3360449730 | 0;
      this.Ch = 596883563 | 0;
      this.Cl = 1867755857 | 0;
      this.Dh = 2520282905 | 0;
      this.Dl = 1497426621 | 0;
      this.Eh = 2519219938 | 0;
      this.El = 2827943907 | 0;
      this.Fh = 3193839141 | 0;
      this.Fl = 1401305490 | 0;
      this.Gh = 721525244 | 0;
      this.Gl = 746961066 | 0;
      this.Hh = 246885852 | 0;
      this.Hl = 2177182882 | 0;
      this.outputLen = 32;
    }
  };
  var SHA384 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 3418070365 | 0;
      this.Al = 3238371032 | 0;
      this.Bh = 1654270250 | 0;
      this.Bl = 914150663 | 0;
      this.Ch = 2438529370 | 0;
      this.Cl = 812702999 | 0;
      this.Dh = 355462360 | 0;
      this.Dl = 4144912697 | 0;
      this.Eh = 1731405415 | 0;
      this.El = 4290775857 | 0;
      this.Fh = 2394180231 | 0;
      this.Fl = 1750603025 | 0;
      this.Gh = 3675008525 | 0;
      this.Gl = 1694076839 | 0;
      this.Hh = 1203062813 | 0;
      this.Hl = 3204075428 | 0;
      this.outputLen = 48;
    }
  };
  var sha512 = wrapConstructor2(() => new SHA512());
  var sha512_224 = wrapConstructor2(() => new SHA512_224());
  var sha512_256 = wrapConstructor2(() => new SHA512_256());
  var sha384 = wrapConstructor2(() => new SHA384());

  // node_modules/@scure/bip32/lib/esm/index.js
  utils.hmacSha256Sync = (key, ...msgs) => hmac(sha2562, key, utils.concatBytes(...msgs));
  var base58check2 = base58check(sha2562);
  function bytesToNumber2(bytes2) {
    return BigInt(`0x${bytesToHex2(bytes2)}`);
  }
  function numberToBytes(num) {
    return hexToBytes2(num.toString(16).padStart(64, "0"));
  }
  var MASTER_SECRET = utf8ToBytes2("Bitcoin seed");
  var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
  var HARDENED_OFFSET = 2147483648;
  var hash160 = (data2) => ripemd160(sha2562(data2));
  var fromU32 = (data2) => createView2(data2).getUint32(0, false);
  var toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
      throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
    }
    const buf = new Uint8Array(4);
    createView2(buf).setUint32(0, n, false);
    return buf;
  };
  var HDKey = class {
    constructor(opt) {
      this.depth = 0;
      this.index = 0;
      this.chainCode = null;
      this.parentFingerprint = 0;
      if (!opt || typeof opt !== "object") {
        throw new Error("HDKey.constructor must not be called directly");
      }
      this.versions = opt.versions || BITCOIN_VERSIONS;
      this.depth = opt.depth || 0;
      this.chainCode = opt.chainCode;
      this.index = opt.index || 0;
      this.parentFingerprint = opt.parentFingerprint || 0;
      if (!this.depth) {
        if (this.parentFingerprint || this.index) {
          throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
        }
      }
      if (opt.publicKey && opt.privateKey) {
        throw new Error("HDKey: publicKey and privateKey at same time.");
      }
      if (opt.privateKey) {
        if (!utils.isValidPrivateKey(opt.privateKey)) {
          throw new Error("Invalid private key");
        }
        this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber2(opt.privateKey);
        this.privKeyBytes = numberToBytes(this.privKey);
        this.pubKey = getPublicKey(opt.privateKey, true);
      } else if (opt.publicKey) {
        this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
      } else {
        throw new Error("HDKey: no public or private key provided");
      }
      this.pubHash = hash160(this.pubKey);
    }
    get fingerprint() {
      if (!this.pubHash) {
        throw new Error("No publicKey set!");
      }
      return fromU32(this.pubHash);
    }
    get identifier() {
      return this.pubHash;
    }
    get pubKeyHash() {
      return this.pubHash;
    }
    get privateKey() {
      return this.privKeyBytes || null;
    }
    get publicKey() {
      return this.pubKey || null;
    }
    get privateExtendedKey() {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("No private key");
      }
      return base58check2.encode(this.serialize(this.versions.private, concatBytes2(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
      if (!this.pubKey) {
        throw new Error("No public key");
      }
      return base58check2.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
      bytes(seed);
      if (8 * seed.length < 128 || 8 * seed.length > 512) {
        throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
      }
      const I = hmac(sha512, MASTER_SECRET, seed);
      return new HDKey({
        versions,
        chainCode: I.slice(32),
        privateKey: I.slice(0, 32)
      });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
      const keyBuffer = base58check2.decode(base58key);
      const keyView = createView2(keyBuffer);
      const version = keyView.getUint32(0, false);
      const opt = {
        versions,
        depth: keyBuffer[4],
        parentFingerprint: keyView.getUint32(5, false),
        index: keyView.getUint32(9, false),
        chainCode: keyBuffer.slice(13, 45)
      };
      const key = keyBuffer.slice(45);
      const isPriv = key[0] === 0;
      if (version !== versions[isPriv ? "private" : "public"]) {
        throw new Error("Version mismatch");
      }
      if (isPriv) {
        return new HDKey({ ...opt, privateKey: key.slice(1) });
      } else {
        return new HDKey({ ...opt, publicKey: key });
      }
    }
    static fromJSON(json) {
      return HDKey.fromExtendedKey(json.xpriv);
    }
    derive(path) {
      if (!/^[mM]'?/.test(path)) {
        throw new Error('Path must start with "m" or "M"');
      }
      if (/^[mM]'?$/.test(path)) {
        return this;
      }
      const parts = path.replace(/^[mM]'?\//, "").split("/");
      let child = this;
      for (const c of parts) {
        const m = /^(\d+)('?)$/.exec(c);
        if (!m || m.length !== 3) {
          throw new Error(`Invalid child index: ${c}`);
        }
        let idx = +m[1];
        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
          throw new Error("Invalid index");
        }
        if (m[2] === "'") {
          idx += HARDENED_OFFSET;
        }
        child = child.deriveChild(idx);
      }
      return child;
    }
    deriveChild(index) {
      if (!this.pubKey || !this.chainCode) {
        throw new Error("No publicKey or chainCode set");
      }
      let data2 = toU32(index);
      if (index >= HARDENED_OFFSET) {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("Could not derive hardened child key");
        }
        data2 = concatBytes2(new Uint8Array([0]), priv, data2);
      } else {
        data2 = concatBytes2(this.pubKey, data2);
      }
      const I = hmac(sha512, this.chainCode, data2);
      const childTweak = bytesToNumber2(I.slice(0, 32));
      const chainCode = I.slice(32);
      if (!utils.isValidPrivateKey(childTweak)) {
        throw new Error("Tweak bigger than curve order");
      }
      const opt = {
        versions: this.versions,
        chainCode,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint,
        index
      };
      try {
        if (this.privateKey) {
          const added = utils.mod(this.privKey + childTweak, CURVE.n);
          if (!utils.isValidPrivateKey(added)) {
            throw new Error("The tweak was out of range or the resulted private key is invalid");
          }
          opt.privateKey = added;
        } else {
          const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
          if (added.equals(Point.ZERO)) {
            throw new Error("The tweak was equal to negative P, which made the result key invalid");
          }
          opt.publicKey = added.toRawBytes(true);
        }
        return new HDKey(opt);
      } catch (err) {
        return this.deriveChild(index + 1);
      }
    }
    sign(hash2) {
      if (!this.privateKey) {
        throw new Error("No privateKey set!");
      }
      bytes(hash2, 32);
      return signSync(hash2, this.privKey, {
        canonical: true,
        der: false
      });
    }
    verify(hash2, signature) {
      bytes(hash2, 32);
      bytes(signature, 64);
      if (!this.publicKey) {
        throw new Error("No publicKey set!");
      }
      let sig;
      try {
        sig = Signature.fromCompact(signature);
      } catch (error2) {
        return false;
      }
      return verify(sig, hash2, this.publicKey);
    }
    wipePrivateData() {
      this.privKey = void 0;
      if (this.privKeyBytes) {
        this.privKeyBytes.fill(0);
        this.privKeyBytes = void 0;
      }
      return this;
    }
    toJSON() {
      return {
        xpriv: this.privateExtendedKey,
        xpub: this.publicExtendedKey
      };
    }
    serialize(version, key) {
      if (!this.chainCode) {
        throw new Error("No chainCode set");
      }
      bytes(key, 33);
      return concatBytes2(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
  };

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC2 = class extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      assertHash(hash2);
      const key = toBytes(_key);
      this.iHash = hash2.create();
      if (!(this.iHash instanceof Hash))
        throw new TypeError("Expected instance of class which extends utils.Hash");
      const blockLen = this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > this.iHash.blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      if (this.destroyed)
        throw new Error("instance is destroyed");
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      if (this.destroyed)
        throw new Error("instance is destroyed");
      if (!(out instanceof Uint8Array) || out.length !== this.outputLen)
        throw new Error("HMAC: Invalid output buffer");
      if (this.finished)
        throw new Error("digest() was already called");
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac2 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
  hmac2.create = (hash2, key) => new HMAC2(hash2, key);
  hmac2.init = hmac2.create;

  // node_modules/nostr-tools/lib/nostr.esm.js
  var __defProp2 = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  function getPublicKey2(privateKey) {
    return utils.bytesToHex(schnorr.getPublicKey(privateKey));
  }
  var utils_exports = {};
  __export(utils_exports, {
    insertEventIntoAscendingList: () => insertEventIntoAscendingList,
    insertEventIntoDescendingList: () => insertEventIntoDescendingList,
    normalizeURL: () => normalizeURL,
    utf8Decoder: () => utf8Decoder,
    utf8Encoder: () => utf8Encoder
  });
  var utf8Decoder = new TextDecoder("utf-8");
  var utf8Encoder = new TextEncoder();
  function normalizeURL(url) {
    let p = new URL(url);
    p.pathname = p.pathname.replace(/\/+/g, "/");
    if (p.pathname.endsWith("/"))
      p.pathname = p.pathname.slice(0, -1);
    if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
      p.port = "";
    p.searchParams.sort();
    p.hash = "";
    return p.toString();
  }
  function insertEventIntoDescendingList(sortedArray, event) {
    let start2 = 0;
    let end = sortedArray.length - 1;
    let midPoint;
    let position = start2;
    if (end < 0) {
      position = 0;
    } else if (event.created_at < sortedArray[end].created_at) {
      position = end + 1;
    } else if (event.created_at >= sortedArray[start2].created_at) {
      position = start2;
    } else
      while (true) {
        if (end <= start2 + 1) {
          position = end;
          break;
        }
        midPoint = Math.floor(start2 + (end - start2) / 2);
        if (sortedArray[midPoint].created_at > event.created_at) {
          start2 = midPoint;
        } else if (sortedArray[midPoint].created_at < event.created_at) {
          end = midPoint;
        } else {
          position = midPoint;
          break;
        }
      }
    if (sortedArray[position]?.id !== event.id) {
      return [
        ...sortedArray.slice(0, position),
        event,
        ...sortedArray.slice(position)
      ];
    }
    return sortedArray;
  }
  function insertEventIntoAscendingList(sortedArray, event) {
    let start2 = 0;
    let end = sortedArray.length - 1;
    let midPoint;
    let position = start2;
    if (end < 0) {
      position = 0;
    } else if (event.created_at > sortedArray[end].created_at) {
      position = end + 1;
    } else if (event.created_at <= sortedArray[start2].created_at) {
      position = start2;
    } else
      while (true) {
        if (end <= start2 + 1) {
          position = end;
          break;
        }
        midPoint = Math.floor(start2 + (end - start2) / 2);
        if (sortedArray[midPoint].created_at < event.created_at) {
          start2 = midPoint;
        } else if (sortedArray[midPoint].created_at > event.created_at) {
          end = midPoint;
        } else {
          position = midPoint;
          break;
        }
      }
    if (sortedArray[position]?.id !== event.id) {
      return [
        ...sortedArray.slice(0, position),
        event,
        ...sortedArray.slice(position)
      ];
    }
    return sortedArray;
  }
  var fakejson_exports = {};
  __export(fakejson_exports, {
    getHex64: () => getHex64,
    getInt: () => getInt,
    getSubscriptionId: () => getSubscriptionId,
    matchEventId: () => matchEventId,
    matchEventKind: () => matchEventKind,
    matchEventPubkey: () => matchEventPubkey
  });
  function getHex64(json, field) {
    let len = field.length + 3;
    let idx = json.indexOf(`"${field}":`) + len;
    let s = json.slice(idx).indexOf(`"`) + idx + 1;
    return json.slice(s, s + 64);
  }
  function getInt(json, field) {
    let len = field.length;
    let idx = json.indexOf(`"${field}":`) + len + 3;
    let sliced = json.slice(idx);
    let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
    return parseInt(sliced.slice(0, end), 10);
  }
  function getSubscriptionId(json) {
    let idx = json.slice(0, 22).indexOf(`"EVENT"`);
    if (idx === -1)
      return null;
    let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
    if (pstart === -1)
      return null;
    let start2 = idx + 7 + 1 + pstart;
    let pend = json.slice(start2 + 1, 80).indexOf(`"`);
    if (pend === -1)
      return null;
    let end = start2 + 1 + pend;
    return json.slice(start2 + 1, end);
  }
  function matchEventId(json, id) {
    return id === getHex64(json, "id");
  }
  function matchEventPubkey(json, pubkey) {
    return pubkey === getHex64(json, "pubkey");
  }
  function matchEventKind(json, kind) {
    return kind === getInt(json, "kind");
  }
  var nip04_exports = {};
  __export(nip04_exports, {
    decrypt: () => decrypt,
    encrypt: () => encrypt
  });
  async function encrypt(privkey, pubkey, text) {
    const key = getSharedSecret(privkey, "02" + pubkey);
    const normalizedKey = getNormalizedX(key);
    let iv = Uint8Array.from(randomBytes(16));
    let plaintext = utf8Encoder.encode(text);
    let cryptoKey = await crypto.subtle.importKey(
      "raw",
      normalizedKey,
      { name: "AES-CBC" },
      false,
      ["encrypt"]
    );
    let ciphertext = await crypto.subtle.encrypt(
      { name: "AES-CBC", iv },
      cryptoKey,
      plaintext
    );
    let ctb64 = base64.encode(new Uint8Array(ciphertext));
    let ivb64 = base64.encode(new Uint8Array(iv.buffer));
    return `${ctb64}?iv=${ivb64}`;
  }
  async function decrypt(privkey, pubkey, data2) {
    let [ctb64, ivb64] = data2.split("?iv=");
    let key = getSharedSecret(privkey, "02" + pubkey);
    let normalizedKey = getNormalizedX(key);
    let cryptoKey = await crypto.subtle.importKey(
      "raw",
      normalizedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"]
    );
    let ciphertext = base64.decode(ctb64);
    let iv = base64.decode(ivb64);
    let plaintext = await crypto.subtle.decrypt(
      { name: "AES-CBC", iv },
      cryptoKey,
      ciphertext
    );
    let text = utf8Decoder.decode(plaintext);
    return text;
  }
  function getNormalizedX(key) {
    return key.slice(1, 33);
  }
  var nip05_exports = {};
  __export(nip05_exports, {
    queryProfile: () => queryProfile,
    searchDomain: () => searchDomain,
    useFetchImplementation: () => useFetchImplementation
  });
  var _fetch;
  try {
    _fetch = fetch;
  } catch {
  }
  function useFetchImplementation(fetchImplementation) {
    _fetch = fetchImplementation;
  }
  async function searchDomain(domain, query = "") {
    try {
      let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();
      return res.names;
    } catch (_) {
      return {};
    }
  }
  async function queryProfile(fullname) {
    let [name, domain] = fullname.split("@");
    if (!domain) {
      domain = name;
      name = "_";
    }
    if (!name.match(/^[A-Za-z0-9-_]+$/))
      return null;
    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)).json();
    if (!res?.names?.[name])
      return null;
    let pubkey = res.names[name];
    let relays = res.relays?.[pubkey] || [];
    return {
      pubkey,
      relays
    };
  }
  var nip06_exports = {};
  __export(nip06_exports, {
    generateSeedWords: () => generateSeedWords,
    privateKeyFromSeedWords: () => privateKeyFromSeedWords,
    validateWords: () => validateWords
  });
  function privateKeyFromSeedWords(mnemonic, passphrase) {
    let root = HDKey.fromMasterSeed((0, import_bip39.mnemonicToSeedSync)(mnemonic, passphrase));
    let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;
    if (!privateKey)
      throw new Error("could not derive private key");
    return utils.bytesToHex(privateKey);
  }
  function generateSeedWords() {
    return (0, import_bip39.generateMnemonic)(import_english.wordlist);
  }
  function validateWords(words) {
    return (0, import_bip39.validateMnemonic)(words, import_english.wordlist);
  }
  var nip19_exports = {};
  __export(nip19_exports, {
    decode: () => decode,
    neventEncode: () => neventEncode,
    noteEncode: () => noteEncode,
    nprofileEncode: () => nprofileEncode,
    npubEncode: () => npubEncode,
    nsecEncode: () => nsecEncode
  });
  var Bech32MaxSize = 5e3;
  function decode(nip19) {
    let { prefix: prefix2, words } = bech32.decode(nip19, Bech32MaxSize);
    let data2 = new Uint8Array(bech32.fromWords(words));
    if (prefix2 === "nprofile") {
      let tlv = parseTLV(data2);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: utils.bytesToHex(tlv[0][0]),
          relays: tlv[1].map((d) => utf8Decoder.decode(d))
        }
      };
    }
    if (prefix2 === "nevent") {
      let tlv = parseTLV(data2);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nevent",
        data: {
          id: utils.bytesToHex(tlv[0][0]),
          relays: tlv[1].map((d) => utf8Decoder.decode(d))
        }
      };
    }
    if (prefix2 === "nsec" || prefix2 === "npub" || prefix2 === "note") {
      return { type: prefix2, data: utils.bytesToHex(data2) };
    }
    throw new Error(`unknown prefix ${prefix2}`);
  }
  function parseTLV(data2) {
    let result = {};
    let rest = data2;
    while (rest.length > 0) {
      let t = rest[0];
      let l = rest[1];
      let v = rest.slice(2, 2 + l);
      rest = rest.slice(2 + l);
      if (v.length < l)
        continue;
      result[t] = result[t] || [];
      result[t].push(v);
    }
    return result;
  }
  function nsecEncode(hex2) {
    return encodeBytes("nsec", hex2);
  }
  function npubEncode(hex2) {
    return encodeBytes("npub", hex2);
  }
  function noteEncode(hex2) {
    return encodeBytes("note", hex2);
  }
  function encodeBytes(prefix2, hex2) {
    let data2 = utils.hexToBytes(hex2);
    let words = bech32.toWords(data2);
    return bech32.encode(prefix2, words, Bech32MaxSize);
  }
  function nprofileEncode(profile) {
    let data2 = encodeTLV({
      0: [utils.hexToBytes(profile.pubkey)],
      1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
    });
    let words = bech32.toWords(data2);
    return bech32.encode("nprofile", words, Bech32MaxSize);
  }
  function neventEncode(event) {
    let data2 = encodeTLV({
      0: [utils.hexToBytes(event.id)],
      1: (event.relays || []).map((url) => utf8Encoder.encode(url))
    });
    let words = bech32.toWords(data2);
    return bech32.encode("nevent", words, Bech32MaxSize);
  }
  function encodeTLV(tlv) {
    let entries = [];
    Object.entries(tlv).forEach(([t, vs]) => {
      vs.forEach((v) => {
        let entry = new Uint8Array(v.length + 2);
        entry.set([parseInt(t)], 0);
        entry.set([v.length], 1);
        entry.set(v, 2);
        entries.push(entry);
      });
    });
    return utils.concatBytes(...entries);
  }
  var nip26_exports = {};
  __export(nip26_exports, {
    createDelegation: () => createDelegation,
    getDelegator: () => getDelegator
  });
  function createDelegation(privateKey, parameters) {
    let conditions = [];
    if ((parameters.kind || -1) >= 0)
      conditions.push(`kind=${parameters.kind}`);
    if (parameters.until)
      conditions.push(`created_at<${parameters.until}`);
    if (parameters.since)
      conditions.push(`created_at>${parameters.since}`);
    let cond = conditions.join("&");
    if (cond === "")
      throw new Error("refusing to create a delegation without any conditions");
    let sighash = sha256(
      utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`)
    );
    let sig = utils.bytesToHex(
      schnorr.signSync(sighash, privateKey)
    );
    return {
      from: getPublicKey2(privateKey),
      to: parameters.pubkey,
      cond,
      sig
    };
  }
  function getDelegator(event) {
    let tag = event.tags.find((tag2) => tag2[0] === "delegation" && tag2.length >= 4);
    if (!tag)
      return null;
    let pubkey = tag[1];
    let cond = tag[2];
    let sig = tag[3];
    let conditions = cond.split("&");
    for (let i = 0; i < conditions.length; i++) {
      let [key, operator, value] = conditions[i].split(/\b/);
      if (key === "kind" && operator === "=" && event.kind === parseInt(value))
        continue;
      else if (key === "created_at" && operator === "<" && event.created_at < parseInt(value))
        continue;
      else if (key === "created_at" && operator === ">" && event.created_at > parseInt(value))
        continue;
      else
        return null;
    }
    let sighash = sha256(
      utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)
    );
    if (!schnorr.verifySync(sig, sighash, pubkey))
      return null;
    return pubkey;
  }
  utils.hmacSha256Sync = (key, ...msgs) => hmac2(sha256, key, utils.concatBytes(...msgs));
  utils.sha256Sync = (...msgs) => sha256(utils.concatBytes(...msgs));

  // Shared (Extension)/Resources/wizards/delegation/delegation.js
  var storage2 = browser.storage.local;
  module_default.data("delegated", () => ({
    privKey: "",
    duration: 7,
    profile: {},
    async init() {
      this.profile = await generateProfile("New Delegate");
      this.profile.delegate = true;
    },
    openNip(event) {
      browser.tabs.create({ url: event.target.href, active: true });
    },
    goBack() {
      window.location = browser.runtime.getURL("options.html");
    },
    async save() {
      let profiles = await getProfiles();
      let profile = JSON.parse(JSON.stringify(this.profile));
      profile.delegator = getPublicKey2(this.decodedPrivKey);
      profile.delegation = this.getDelegation();
      profiles.push(profile);
      let profileIndex = profiles.length - 1;
      await storage2.set({ profiles, profileIndex });
      window.location = `${browser.runtime.getURL(
        "options.html"
      )}?index=${profileIndex}`;
    },
    getDelegation() {
      let pubkey = getPublicKey2(this.profile.privKey);
      let delegation = nip26_exports.createDelegation(this.decodedPrivKey, {
        pubkey,
        until: this.until,
        since: Math.round(Date.now() / 1e3) - 1
      });
      console.log(delegation);
      return delegation;
    },
    // Properties
    get isKeyValid() {
      return validateKey(this.privKey);
    },
    get validKeyClass() {
      return this.isKeyValid ? "" : "ring-2 ring-rose-500 focus:ring-2 focus:ring-rose-500 border-transparent focus:border-transparent";
    },
    get until() {
      return Math.round(Date.now() / 1e3) + 60 * 60 * 24 * this.duration;
    },
    get decodedPrivKey() {
      if (!this.isKeyValid) {
        return null;
      }
      if (this.privKey.startsWith("nsec")) {
        return nip19_exports.decode(this.privKey).data;
      }
      return this.privKey;
    }
  }));
  module_default.start();
})();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ccm93c2VyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcGJrZGYyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhNTEyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzIiwgIi4uLy4uL3V0aWxpdGllcy91dGlscy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvZXNtL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ccm93c2VyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL25vc3RyLmVzbS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b0Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbGliL2VzbS9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsICJkZWxlZ2F0aW9uLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud29yZGxpc3QgPSB2b2lkIDA7XG5leHBvcnRzLndvcmRsaXN0ID0gYGFiYW5kb25cbmFiaWxpdHlcbmFibGVcbmFib3V0XG5hYm92ZVxuYWJzZW50XG5hYnNvcmJcbmFic3RyYWN0XG5hYnN1cmRcbmFidXNlXG5hY2Nlc3NcbmFjY2lkZW50XG5hY2NvdW50XG5hY2N1c2VcbmFjaGlldmVcbmFjaWRcbmFjb3VzdGljXG5hY3F1aXJlXG5hY3Jvc3NcbmFjdFxuYWN0aW9uXG5hY3RvclxuYWN0cmVzc1xuYWN0dWFsXG5hZGFwdFxuYWRkXG5hZGRpY3RcbmFkZHJlc3NcbmFkanVzdFxuYWRtaXRcbmFkdWx0XG5hZHZhbmNlXG5hZHZpY2VcbmFlcm9iaWNcbmFmZmFpclxuYWZmb3JkXG5hZnJhaWRcbmFnYWluXG5hZ2VcbmFnZW50XG5hZ3JlZVxuYWhlYWRcbmFpbVxuYWlyXG5haXJwb3J0XG5haXNsZVxuYWxhcm1cbmFsYnVtXG5hbGNvaG9sXG5hbGVydFxuYWxpZW5cbmFsbFxuYWxsZXlcbmFsbG93XG5hbG1vc3RcbmFsb25lXG5hbHBoYVxuYWxyZWFkeVxuYWxzb1xuYWx0ZXJcbmFsd2F5c1xuYW1hdGV1clxuYW1hemluZ1xuYW1vbmdcbmFtb3VudFxuYW11c2VkXG5hbmFseXN0XG5hbmNob3JcbmFuY2llbnRcbmFuZ2VyXG5hbmdsZVxuYW5ncnlcbmFuaW1hbFxuYW5rbGVcbmFubm91bmNlXG5hbm51YWxcbmFub3RoZXJcbmFuc3dlclxuYW50ZW5uYVxuYW50aXF1ZVxuYW54aWV0eVxuYW55XG5hcGFydFxuYXBvbG9neVxuYXBwZWFyXG5hcHBsZVxuYXBwcm92ZVxuYXByaWxcbmFyY2hcbmFyY3RpY1xuYXJlYVxuYXJlbmFcbmFyZ3VlXG5hcm1cbmFybWVkXG5hcm1vclxuYXJteVxuYXJvdW5kXG5hcnJhbmdlXG5hcnJlc3RcbmFycml2ZVxuYXJyb3dcbmFydFxuYXJ0ZWZhY3RcbmFydGlzdFxuYXJ0d29ya1xuYXNrXG5hc3BlY3RcbmFzc2F1bHRcbmFzc2V0XG5hc3Npc3RcbmFzc3VtZVxuYXN0aG1hXG5hdGhsZXRlXG5hdG9tXG5hdHRhY2tcbmF0dGVuZFxuYXR0aXR1ZGVcbmF0dHJhY3RcbmF1Y3Rpb25cbmF1ZGl0XG5hdWd1c3RcbmF1bnRcbmF1dGhvclxuYXV0b1xuYXV0dW1uXG5hdmVyYWdlXG5hdm9jYWRvXG5hdm9pZFxuYXdha2VcbmF3YXJlXG5hd2F5XG5hd2Vzb21lXG5hd2Z1bFxuYXdrd2FyZFxuYXhpc1xuYmFieVxuYmFjaGVsb3JcbmJhY29uXG5iYWRnZVxuYmFnXG5iYWxhbmNlXG5iYWxjb255XG5iYWxsXG5iYW1ib29cbmJhbmFuYVxuYmFubmVyXG5iYXJcbmJhcmVseVxuYmFyZ2FpblxuYmFycmVsXG5iYXNlXG5iYXNpY1xuYmFza2V0XG5iYXR0bGVcbmJlYWNoXG5iZWFuXG5iZWF1dHlcbmJlY2F1c2VcbmJlY29tZVxuYmVlZlxuYmVmb3JlXG5iZWdpblxuYmVoYXZlXG5iZWhpbmRcbmJlbGlldmVcbmJlbG93XG5iZWx0XG5iZW5jaFxuYmVuZWZpdFxuYmVzdFxuYmV0cmF5XG5iZXR0ZXJcbmJldHdlZW5cbmJleW9uZFxuYmljeWNsZVxuYmlkXG5iaWtlXG5iaW5kXG5iaW9sb2d5XG5iaXJkXG5iaXJ0aFxuYml0dGVyXG5ibGFja1xuYmxhZGVcbmJsYW1lXG5ibGFua2V0XG5ibGFzdFxuYmxlYWtcbmJsZXNzXG5ibGluZFxuYmxvb2RcbmJsb3Nzb21cbmJsb3VzZVxuYmx1ZVxuYmx1clxuYmx1c2hcbmJvYXJkXG5ib2F0XG5ib2R5XG5ib2lsXG5ib21iXG5ib25lXG5ib251c1xuYm9va1xuYm9vc3RcbmJvcmRlclxuYm9yaW5nXG5ib3Jyb3dcbmJvc3NcbmJvdHRvbVxuYm91bmNlXG5ib3hcbmJveVxuYnJhY2tldFxuYnJhaW5cbmJyYW5kXG5icmFzc1xuYnJhdmVcbmJyZWFkXG5icmVlemVcbmJyaWNrXG5icmlkZ2VcbmJyaWVmXG5icmlnaHRcbmJyaW5nXG5icmlza1xuYnJvY2NvbGlcbmJyb2tlblxuYnJvbnplXG5icm9vbVxuYnJvdGhlclxuYnJvd25cbmJydXNoXG5idWJibGVcbmJ1ZGR5XG5idWRnZXRcbmJ1ZmZhbG9cbmJ1aWxkXG5idWxiXG5idWxrXG5idWxsZXRcbmJ1bmRsZVxuYnVua2VyXG5idXJkZW5cbmJ1cmdlclxuYnVyc3RcbmJ1c1xuYnVzaW5lc3NcbmJ1c3lcbmJ1dHRlclxuYnV5ZXJcbmJ1enpcbmNhYmJhZ2VcbmNhYmluXG5jYWJsZVxuY2FjdHVzXG5jYWdlXG5jYWtlXG5jYWxsXG5jYWxtXG5jYW1lcmFcbmNhbXBcbmNhblxuY2FuYWxcbmNhbmNlbFxuY2FuZHlcbmNhbm5vblxuY2Fub2VcbmNhbnZhc1xuY2FueW9uXG5jYXBhYmxlXG5jYXBpdGFsXG5jYXB0YWluXG5jYXJcbmNhcmJvblxuY2FyZFxuY2FyZ29cbmNhcnBldFxuY2FycnlcbmNhcnRcbmNhc2VcbmNhc2hcbmNhc2lub1xuY2FzdGxlXG5jYXN1YWxcbmNhdFxuY2F0YWxvZ1xuY2F0Y2hcbmNhdGVnb3J5XG5jYXR0bGVcbmNhdWdodFxuY2F1c2VcbmNhdXRpb25cbmNhdmVcbmNlaWxpbmdcbmNlbGVyeVxuY2VtZW50XG5jZW5zdXNcbmNlbnR1cnlcbmNlcmVhbFxuY2VydGFpblxuY2hhaXJcbmNoYWxrXG5jaGFtcGlvblxuY2hhbmdlXG5jaGFvc1xuY2hhcHRlclxuY2hhcmdlXG5jaGFzZVxuY2hhdFxuY2hlYXBcbmNoZWNrXG5jaGVlc2VcbmNoZWZcbmNoZXJyeVxuY2hlc3RcbmNoaWNrZW5cbmNoaWVmXG5jaGlsZFxuY2hpbW5leVxuY2hvaWNlXG5jaG9vc2VcbmNocm9uaWNcbmNodWNrbGVcbmNodW5rXG5jaHVyblxuY2lnYXJcbmNpbm5hbW9uXG5jaXJjbGVcbmNpdGl6ZW5cbmNpdHlcbmNpdmlsXG5jbGFpbVxuY2xhcFxuY2xhcmlmeVxuY2xhd1xuY2xheVxuY2xlYW5cbmNsZXJrXG5jbGV2ZXJcbmNsaWNrXG5jbGllbnRcbmNsaWZmXG5jbGltYlxuY2xpbmljXG5jbGlwXG5jbG9ja1xuY2xvZ1xuY2xvc2VcbmNsb3RoXG5jbG91ZFxuY2xvd25cbmNsdWJcbmNsdW1wXG5jbHVzdGVyXG5jbHV0Y2hcbmNvYWNoXG5jb2FzdFxuY29jb251dFxuY29kZVxuY29mZmVlXG5jb2lsXG5jb2luXG5jb2xsZWN0XG5jb2xvclxuY29sdW1uXG5jb21iaW5lXG5jb21lXG5jb21mb3J0XG5jb21pY1xuY29tbW9uXG5jb21wYW55XG5jb25jZXJ0XG5jb25kdWN0XG5jb25maXJtXG5jb25ncmVzc1xuY29ubmVjdFxuY29uc2lkZXJcbmNvbnRyb2xcbmNvbnZpbmNlXG5jb29rXG5jb29sXG5jb3BwZXJcbmNvcHlcbmNvcmFsXG5jb3JlXG5jb3JuXG5jb3JyZWN0XG5jb3N0XG5jb3R0b25cbmNvdWNoXG5jb3VudHJ5XG5jb3VwbGVcbmNvdXJzZVxuY291c2luXG5jb3ZlclxuY295b3RlXG5jcmFja1xuY3JhZGxlXG5jcmFmdFxuY3JhbVxuY3JhbmVcbmNyYXNoXG5jcmF0ZXJcbmNyYXdsXG5jcmF6eVxuY3JlYW1cbmNyZWRpdFxuY3JlZWtcbmNyZXdcbmNyaWNrZXRcbmNyaW1lXG5jcmlzcFxuY3JpdGljXG5jcm9wXG5jcm9zc1xuY3JvdWNoXG5jcm93ZFxuY3J1Y2lhbFxuY3J1ZWxcbmNydWlzZVxuY3J1bWJsZVxuY3J1bmNoXG5jcnVzaFxuY3J5XG5jcnlzdGFsXG5jdWJlXG5jdWx0dXJlXG5jdXBcbmN1cGJvYXJkXG5jdXJpb3VzXG5jdXJyZW50XG5jdXJ0YWluXG5jdXJ2ZVxuY3VzaGlvblxuY3VzdG9tXG5jdXRlXG5jeWNsZVxuZGFkXG5kYW1hZ2VcbmRhbXBcbmRhbmNlXG5kYW5nZXJcbmRhcmluZ1xuZGFzaFxuZGF1Z2h0ZXJcbmRhd25cbmRheVxuZGVhbFxuZGViYXRlXG5kZWJyaXNcbmRlY2FkZVxuZGVjZW1iZXJcbmRlY2lkZVxuZGVjbGluZVxuZGVjb3JhdGVcbmRlY3JlYXNlXG5kZWVyXG5kZWZlbnNlXG5kZWZpbmVcbmRlZnlcbmRlZ3JlZVxuZGVsYXlcbmRlbGl2ZXJcbmRlbWFuZFxuZGVtaXNlXG5kZW5pYWxcbmRlbnRpc3RcbmRlbnlcbmRlcGFydFxuZGVwZW5kXG5kZXBvc2l0XG5kZXB0aFxuZGVwdXR5XG5kZXJpdmVcbmRlc2NyaWJlXG5kZXNlcnRcbmRlc2lnblxuZGVza1xuZGVzcGFpclxuZGVzdHJveVxuZGV0YWlsXG5kZXRlY3RcbmRldmVsb3BcbmRldmljZVxuZGV2b3RlXG5kaWFncmFtXG5kaWFsXG5kaWFtb25kXG5kaWFyeVxuZGljZVxuZGllc2VsXG5kaWV0XG5kaWZmZXJcbmRpZ2l0YWxcbmRpZ25pdHlcbmRpbGVtbWFcbmRpbm5lclxuZGlub3NhdXJcbmRpcmVjdFxuZGlydFxuZGlzYWdyZWVcbmRpc2NvdmVyXG5kaXNlYXNlXG5kaXNoXG5kaXNtaXNzXG5kaXNvcmRlclxuZGlzcGxheVxuZGlzdGFuY2VcbmRpdmVydFxuZGl2aWRlXG5kaXZvcmNlXG5kaXp6eVxuZG9jdG9yXG5kb2N1bWVudFxuZG9nXG5kb2xsXG5kb2xwaGluXG5kb21haW5cbmRvbmF0ZVxuZG9ua2V5XG5kb25vclxuZG9vclxuZG9zZVxuZG91YmxlXG5kb3ZlXG5kcmFmdFxuZHJhZ29uXG5kcmFtYVxuZHJhc3RpY1xuZHJhd1xuZHJlYW1cbmRyZXNzXG5kcmlmdFxuZHJpbGxcbmRyaW5rXG5kcmlwXG5kcml2ZVxuZHJvcFxuZHJ1bVxuZHJ5XG5kdWNrXG5kdW1iXG5kdW5lXG5kdXJpbmdcbmR1c3RcbmR1dGNoXG5kdXR5XG5kd2FyZlxuZHluYW1pY1xuZWFnZXJcbmVhZ2xlXG5lYXJseVxuZWFyblxuZWFydGhcbmVhc2lseVxuZWFzdFxuZWFzeVxuZWNob1xuZWNvbG9neVxuZWNvbm9teVxuZWRnZVxuZWRpdFxuZWR1Y2F0ZVxuZWZmb3J0XG5lZ2dcbmVpZ2h0XG5laXRoZXJcbmVsYm93XG5lbGRlclxuZWxlY3RyaWNcbmVsZWdhbnRcbmVsZW1lbnRcbmVsZXBoYW50XG5lbGV2YXRvclxuZWxpdGVcbmVsc2VcbmVtYmFya1xuZW1ib2R5XG5lbWJyYWNlXG5lbWVyZ2VcbmVtb3Rpb25cbmVtcGxveVxuZW1wb3dlclxuZW1wdHlcbmVuYWJsZVxuZW5hY3RcbmVuZFxuZW5kbGVzc1xuZW5kb3JzZVxuZW5lbXlcbmVuZXJneVxuZW5mb3JjZVxuZW5nYWdlXG5lbmdpbmVcbmVuaGFuY2VcbmVuam95XG5lbmxpc3RcbmVub3VnaFxuZW5yaWNoXG5lbnJvbGxcbmVuc3VyZVxuZW50ZXJcbmVudGlyZVxuZW50cnlcbmVudmVsb3BlXG5lcGlzb2RlXG5lcXVhbFxuZXF1aXBcbmVyYVxuZXJhc2VcbmVyb2RlXG5lcm9zaW9uXG5lcnJvclxuZXJ1cHRcbmVzY2FwZVxuZXNzYXlcbmVzc2VuY2VcbmVzdGF0ZVxuZXRlcm5hbFxuZXRoaWNzXG5ldmlkZW5jZVxuZXZpbFxuZXZva2VcbmV2b2x2ZVxuZXhhY3RcbmV4YW1wbGVcbmV4Y2Vzc1xuZXhjaGFuZ2VcbmV4Y2l0ZVxuZXhjbHVkZVxuZXhjdXNlXG5leGVjdXRlXG5leGVyY2lzZVxuZXhoYXVzdFxuZXhoaWJpdFxuZXhpbGVcbmV4aXN0XG5leGl0XG5leG90aWNcbmV4cGFuZFxuZXhwZWN0XG5leHBpcmVcbmV4cGxhaW5cbmV4cG9zZVxuZXhwcmVzc1xuZXh0ZW5kXG5leHRyYVxuZXllXG5leWVicm93XG5mYWJyaWNcbmZhY2VcbmZhY3VsdHlcbmZhZGVcbmZhaW50XG5mYWl0aFxuZmFsbFxuZmFsc2VcbmZhbWVcbmZhbWlseVxuZmFtb3VzXG5mYW5cbmZhbmN5XG5mYW50YXN5XG5mYXJtXG5mYXNoaW9uXG5mYXRcbmZhdGFsXG5mYXRoZXJcbmZhdGlndWVcbmZhdWx0XG5mYXZvcml0ZVxuZmVhdHVyZVxuZmVicnVhcnlcbmZlZGVyYWxcbmZlZVxuZmVlZFxuZmVlbFxuZmVtYWxlXG5mZW5jZVxuZmVzdGl2YWxcbmZldGNoXG5mZXZlclxuZmV3XG5maWJlclxuZmljdGlvblxuZmllbGRcbmZpZ3VyZVxuZmlsZVxuZmlsbVxuZmlsdGVyXG5maW5hbFxuZmluZFxuZmluZVxuZmluZ2VyXG5maW5pc2hcbmZpcmVcbmZpcm1cbmZpcnN0XG5maXNjYWxcbmZpc2hcbmZpdFxuZml0bmVzc1xuZml4XG5mbGFnXG5mbGFtZVxuZmxhc2hcbmZsYXRcbmZsYXZvclxuZmxlZVxuZmxpZ2h0XG5mbGlwXG5mbG9hdFxuZmxvY2tcbmZsb29yXG5mbG93ZXJcbmZsdWlkXG5mbHVzaFxuZmx5XG5mb2FtXG5mb2N1c1xuZm9nXG5mb2lsXG5mb2xkXG5mb2xsb3dcbmZvb2RcbmZvb3RcbmZvcmNlXG5mb3Jlc3RcbmZvcmdldFxuZm9ya1xuZm9ydHVuZVxuZm9ydW1cbmZvcndhcmRcbmZvc3NpbFxuZm9zdGVyXG5mb3VuZFxuZm94XG5mcmFnaWxlXG5mcmFtZVxuZnJlcXVlbnRcbmZyZXNoXG5mcmllbmRcbmZyaW5nZVxuZnJvZ1xuZnJvbnRcbmZyb3N0XG5mcm93blxuZnJvemVuXG5mcnVpdFxuZnVlbFxuZnVuXG5mdW5ueVxuZnVybmFjZVxuZnVyeVxuZnV0dXJlXG5nYWRnZXRcbmdhaW5cbmdhbGF4eVxuZ2FsbGVyeVxuZ2FtZVxuZ2FwXG5nYXJhZ2VcbmdhcmJhZ2VcbmdhcmRlblxuZ2FybGljXG5nYXJtZW50XG5nYXNcbmdhc3BcbmdhdGVcbmdhdGhlclxuZ2F1Z2VcbmdhemVcbmdlbmVyYWxcbmdlbml1c1xuZ2VucmVcbmdlbnRsZVxuZ2VudWluZVxuZ2VzdHVyZVxuZ2hvc3RcbmdpYW50XG5naWZ0XG5naWdnbGVcbmdpbmdlclxuZ2lyYWZmZVxuZ2lybFxuZ2l2ZVxuZ2xhZFxuZ2xhbmNlXG5nbGFyZVxuZ2xhc3NcbmdsaWRlXG5nbGltcHNlXG5nbG9iZVxuZ2xvb21cbmdsb3J5XG5nbG92ZVxuZ2xvd1xuZ2x1ZVxuZ29hdFxuZ29kZGVzc1xuZ29sZFxuZ29vZFxuZ29vc2VcbmdvcmlsbGFcbmdvc3BlbFxuZ29zc2lwXG5nb3Zlcm5cbmdvd25cbmdyYWJcbmdyYWNlXG5ncmFpblxuZ3JhbnRcbmdyYXBlXG5ncmFzc1xuZ3Jhdml0eVxuZ3JlYXRcbmdyZWVuXG5ncmlkXG5ncmllZlxuZ3JpdFxuZ3JvY2VyeVxuZ3JvdXBcbmdyb3dcbmdydW50XG5ndWFyZFxuZ3Vlc3Ncbmd1aWRlXG5ndWlsdFxuZ3VpdGFyXG5ndW5cbmd5bVxuaGFiaXRcbmhhaXJcbmhhbGZcbmhhbW1lclxuaGFtc3RlclxuaGFuZFxuaGFwcHlcbmhhcmJvclxuaGFyZFxuaGFyc2hcbmhhcnZlc3RcbmhhdFxuaGF2ZVxuaGF3a1xuaGF6YXJkXG5oZWFkXG5oZWFsdGhcbmhlYXJ0XG5oZWF2eVxuaGVkZ2Vob2dcbmhlaWdodFxuaGVsbG9cbmhlbG1ldFxuaGVscFxuaGVuXG5oZXJvXG5oaWRkZW5cbmhpZ2hcbmhpbGxcbmhpbnRcbmhpcFxuaGlyZVxuaGlzdG9yeVxuaG9iYnlcbmhvY2tleVxuaG9sZFxuaG9sZVxuaG9saWRheVxuaG9sbG93XG5ob21lXG5ob25leVxuaG9vZFxuaG9wZVxuaG9yblxuaG9ycm9yXG5ob3JzZVxuaG9zcGl0YWxcbmhvc3RcbmhvdGVsXG5ob3VyXG5ob3ZlclxuaHViXG5odWdlXG5odW1hblxuaHVtYmxlXG5odW1vclxuaHVuZHJlZFxuaHVuZ3J5XG5odW50XG5odXJkbGVcbmh1cnJ5XG5odXJ0XG5odXNiYW5kXG5oeWJyaWRcbmljZVxuaWNvblxuaWRlYVxuaWRlbnRpZnlcbmlkbGVcbmlnbm9yZVxuaWxsXG5pbGxlZ2FsXG5pbGxuZXNzXG5pbWFnZVxuaW1pdGF0ZVxuaW1tZW5zZVxuaW1tdW5lXG5pbXBhY3RcbmltcG9zZVxuaW1wcm92ZVxuaW1wdWxzZVxuaW5jaFxuaW5jbHVkZVxuaW5jb21lXG5pbmNyZWFzZVxuaW5kZXhcbmluZGljYXRlXG5pbmRvb3JcbmluZHVzdHJ5XG5pbmZhbnRcbmluZmxpY3RcbmluZm9ybVxuaW5oYWxlXG5pbmhlcml0XG5pbml0aWFsXG5pbmplY3RcbmluanVyeVxuaW5tYXRlXG5pbm5lclxuaW5ub2NlbnRcbmlucHV0XG5pbnF1aXJ5XG5pbnNhbmVcbmluc2VjdFxuaW5zaWRlXG5pbnNwaXJlXG5pbnN0YWxsXG5pbnRhY3RcbmludGVyZXN0XG5pbnRvXG5pbnZlc3Rcbmludml0ZVxuaW52b2x2ZVxuaXJvblxuaXNsYW5kXG5pc29sYXRlXG5pc3N1ZVxuaXRlbVxuaXZvcnlcbmphY2tldFxuamFndWFyXG5qYXJcbmphenpcbmplYWxvdXNcbmplYW5zXG5qZWxseVxuamV3ZWxcbmpvYlxuam9pblxuam9rZVxuam91cm5leVxuam95XG5qdWRnZVxuanVpY2Vcbmp1bXBcbmp1bmdsZVxuanVuaW9yXG5qdW5rXG5qdXN0XG5rYW5nYXJvb1xua2Vlblxua2VlcFxua2V0Y2h1cFxua2V5XG5raWNrXG5raWRcbmtpZG5leVxua2luZFxua2luZ2RvbVxua2lzc1xua2l0XG5raXRjaGVuXG5raXRlXG5raXR0ZW5cbmtpd2lcbmtuZWVcbmtuaWZlXG5rbm9ja1xua25vd1xubGFiXG5sYWJlbFxubGFib3JcbmxhZGRlclxubGFkeVxubGFrZVxubGFtcFxubGFuZ3VhZ2VcbmxhcHRvcFxubGFyZ2VcbmxhdGVyXG5sYXRpblxubGF1Z2hcbmxhdW5kcnlcbmxhdmFcbmxhd1xubGF3blxubGF3c3VpdFxubGF5ZXJcbmxhenlcbmxlYWRlclxubGVhZlxubGVhcm5cbmxlYXZlXG5sZWN0dXJlXG5sZWZ0XG5sZWdcbmxlZ2FsXG5sZWdlbmRcbmxlaXN1cmVcbmxlbW9uXG5sZW5kXG5sZW5ndGhcbmxlbnNcbmxlb3BhcmRcbmxlc3NvblxubGV0dGVyXG5sZXZlbFxubGlhclxubGliZXJ0eVxubGlicmFyeVxubGljZW5zZVxubGlmZVxubGlmdFxubGlnaHRcbmxpa2VcbmxpbWJcbmxpbWl0XG5saW5rXG5saW9uXG5saXF1aWRcbmxpc3RcbmxpdHRsZVxubGl2ZVxubGl6YXJkXG5sb2FkXG5sb2FuXG5sb2JzdGVyXG5sb2NhbFxubG9ja1xubG9naWNcbmxvbmVseVxubG9uZ1xubG9vcFxubG90dGVyeVxubG91ZFxubG91bmdlXG5sb3ZlXG5sb3lhbFxubHVja3lcbmx1Z2dhZ2Vcbmx1bWJlclxubHVuYXJcbmx1bmNoXG5sdXh1cnlcbmx5cmljc1xubWFjaGluZVxubWFkXG5tYWdpY1xubWFnbmV0XG5tYWlkXG5tYWlsXG5tYWluXG5tYWpvclxubWFrZVxubWFtbWFsXG5tYW5cbm1hbmFnZVxubWFuZGF0ZVxubWFuZ29cbm1hbnNpb25cbm1hbnVhbFxubWFwbGVcbm1hcmJsZVxubWFyY2hcbm1hcmdpblxubWFyaW5lXG5tYXJrZXRcbm1hcnJpYWdlXG5tYXNrXG5tYXNzXG5tYXN0ZXJcbm1hdGNoXG5tYXRlcmlhbFxubWF0aFxubWF0cml4XG5tYXR0ZXJcbm1heGltdW1cbm1hemVcbm1lYWRvd1xubWVhblxubWVhc3VyZVxubWVhdFxubWVjaGFuaWNcbm1lZGFsXG5tZWRpYVxubWVsb2R5XG5tZWx0XG5tZW1iZXJcbm1lbW9yeVxubWVudGlvblxubWVudVxubWVyY3lcbm1lcmdlXG5tZXJpdFxubWVycnlcbm1lc2hcbm1lc3NhZ2Vcbm1ldGFsXG5tZXRob2Rcbm1pZGRsZVxubWlkbmlnaHRcbm1pbGtcbm1pbGxpb25cbm1pbWljXG5taW5kXG5taW5pbXVtXG5taW5vclxubWludXRlXG5taXJhY2xlXG5taXJyb3Jcbm1pc2VyeVxubWlzc1xubWlzdGFrZVxubWl4XG5taXhlZFxubWl4dHVyZVxubW9iaWxlXG5tb2RlbFxubW9kaWZ5XG5tb21cbm1vbWVudFxubW9uaXRvclxubW9ua2V5XG5tb25zdGVyXG5tb250aFxubW9vblxubW9yYWxcbm1vcmVcbm1vcm5pbmdcbm1vc3F1aXRvXG5tb3RoZXJcbm1vdGlvblxubW90b3Jcbm1vdW50YWluXG5tb3VzZVxubW92ZVxubW92aWVcbm11Y2hcbm11ZmZpblxubXVsZVxubXVsdGlwbHlcbm11c2NsZVxubXVzZXVtXG5tdXNocm9vbVxubXVzaWNcbm11c3Rcbm11dHVhbFxubXlzZWxmXG5teXN0ZXJ5XG5teXRoXG5uYWl2ZVxubmFtZVxubmFwa2luXG5uYXJyb3dcbm5hc3R5XG5uYXRpb25cbm5hdHVyZVxubmVhclxubmVja1xubmVlZFxubmVnYXRpdmVcbm5lZ2xlY3Rcbm5laXRoZXJcbm5lcGhld1xubmVydmVcbm5lc3Rcbm5ldFxubmV0d29ya1xubmV1dHJhbFxubmV2ZXJcbm5ld3Ncbm5leHRcbm5pY2Vcbm5pZ2h0XG5ub2JsZVxubm9pc2Vcbm5vbWluZWVcbm5vb2RsZVxubm9ybWFsXG5ub3J0aFxubm9zZVxubm90YWJsZVxubm90ZVxubm90aGluZ1xubm90aWNlXG5ub3ZlbFxubm93XG5udWNsZWFyXG5udW1iZXJcbm51cnNlXG5udXRcbm9ha1xub2JleVxub2JqZWN0XG5vYmxpZ2Vcbm9ic2N1cmVcbm9ic2VydmVcbm9idGFpblxub2J2aW91c1xub2NjdXJcbm9jZWFuXG5vY3RvYmVyXG5vZG9yXG5vZmZcbm9mZmVyXG5vZmZpY2Vcbm9mdGVuXG5vaWxcbm9rYXlcbm9sZFxub2xpdmVcbm9seW1waWNcbm9taXRcbm9uY2Vcbm9uZVxub25pb25cbm9ubGluZVxub25seVxub3Blblxub3BlcmFcbm9waW5pb25cbm9wcG9zZVxub3B0aW9uXG5vcmFuZ2Vcbm9yYml0XG5vcmNoYXJkXG5vcmRlclxub3JkaW5hcnlcbm9yZ2FuXG5vcmllbnRcbm9yaWdpbmFsXG5vcnBoYW5cbm9zdHJpY2hcbm90aGVyXG5vdXRkb29yXG5vdXRlclxub3V0cHV0XG5vdXRzaWRlXG5vdmFsXG5vdmVuXG5vdmVyXG5vd25cbm93bmVyXG5veHlnZW5cbm95c3Rlclxub3pvbmVcbnBhY3RcbnBhZGRsZVxucGFnZVxucGFpclxucGFsYWNlXG5wYWxtXG5wYW5kYVxucGFuZWxcbnBhbmljXG5wYW50aGVyXG5wYXBlclxucGFyYWRlXG5wYXJlbnRcbnBhcmtcbnBhcnJvdFxucGFydHlcbnBhc3NcbnBhdGNoXG5wYXRoXG5wYXRpZW50XG5wYXRyb2xcbnBhdHRlcm5cbnBhdXNlXG5wYXZlXG5wYXltZW50XG5wZWFjZVxucGVhbnV0XG5wZWFyXG5wZWFzYW50XG5wZWxpY2FuXG5wZW5cbnBlbmFsdHlcbnBlbmNpbFxucGVvcGxlXG5wZXBwZXJcbnBlcmZlY3RcbnBlcm1pdFxucGVyc29uXG5wZXRcbnBob25lXG5waG90b1xucGhyYXNlXG5waHlzaWNhbFxucGlhbm9cbnBpY25pY1xucGljdHVyZVxucGllY2VcbnBpZ1xucGlnZW9uXG5waWxsXG5waWxvdFxucGlua1xucGlvbmVlclxucGlwZVxucGlzdG9sXG5waXRjaFxucGl6emFcbnBsYWNlXG5wbGFuZXRcbnBsYXN0aWNcbnBsYXRlXG5wbGF5XG5wbGVhc2VcbnBsZWRnZVxucGx1Y2tcbnBsdWdcbnBsdW5nZVxucG9lbVxucG9ldFxucG9pbnRcbnBvbGFyXG5wb2xlXG5wb2xpY2VcbnBvbmRcbnBvbnlcbnBvb2xcbnBvcHVsYXJcbnBvcnRpb25cbnBvc2l0aW9uXG5wb3NzaWJsZVxucG9zdFxucG90YXRvXG5wb3R0ZXJ5XG5wb3ZlcnR5XG5wb3dkZXJcbnBvd2VyXG5wcmFjdGljZVxucHJhaXNlXG5wcmVkaWN0XG5wcmVmZXJcbnByZXBhcmVcbnByZXNlbnRcbnByZXR0eVxucHJldmVudFxucHJpY2VcbnByaWRlXG5wcmltYXJ5XG5wcmludFxucHJpb3JpdHlcbnByaXNvblxucHJpdmF0ZVxucHJpemVcbnByb2JsZW1cbnByb2Nlc3NcbnByb2R1Y2VcbnByb2ZpdFxucHJvZ3JhbVxucHJvamVjdFxucHJvbW90ZVxucHJvb2ZcbnByb3BlcnR5XG5wcm9zcGVyXG5wcm90ZWN0XG5wcm91ZFxucHJvdmlkZVxucHVibGljXG5wdWRkaW5nXG5wdWxsXG5wdWxwXG5wdWxzZVxucHVtcGtpblxucHVuY2hcbnB1cGlsXG5wdXBweVxucHVyY2hhc2VcbnB1cml0eVxucHVycG9zZVxucHVyc2VcbnB1c2hcbnB1dFxucHV6emxlXG5weXJhbWlkXG5xdWFsaXR5XG5xdWFudHVtXG5xdWFydGVyXG5xdWVzdGlvblxucXVpY2tcbnF1aXRcbnF1aXpcbnF1b3RlXG5yYWJiaXRcbnJhY2Nvb25cbnJhY2VcbnJhY2tcbnJhZGFyXG5yYWRpb1xucmFpbFxucmFpblxucmFpc2VcbnJhbGx5XG5yYW1wXG5yYW5jaFxucmFuZG9tXG5yYW5nZVxucmFwaWRcbnJhcmVcbnJhdGVcbnJhdGhlclxucmF2ZW5cbnJhd1xucmF6b3JcbnJlYWR5XG5yZWFsXG5yZWFzb25cbnJlYmVsXG5yZWJ1aWxkXG5yZWNhbGxcbnJlY2VpdmVcbnJlY2lwZVxucmVjb3JkXG5yZWN5Y2xlXG5yZWR1Y2VcbnJlZmxlY3RcbnJlZm9ybVxucmVmdXNlXG5yZWdpb25cbnJlZ3JldFxucmVndWxhclxucmVqZWN0XG5yZWxheFxucmVsZWFzZVxucmVsaWVmXG5yZWx5XG5yZW1haW5cbnJlbWVtYmVyXG5yZW1pbmRcbnJlbW92ZVxucmVuZGVyXG5yZW5ld1xucmVudFxucmVvcGVuXG5yZXBhaXJcbnJlcGVhdFxucmVwbGFjZVxucmVwb3J0XG5yZXF1aXJlXG5yZXNjdWVcbnJlc2VtYmxlXG5yZXNpc3RcbnJlc291cmNlXG5yZXNwb25zZVxucmVzdWx0XG5yZXRpcmVcbnJldHJlYXRcbnJldHVyblxucmV1bmlvblxucmV2ZWFsXG5yZXZpZXdcbnJld2FyZFxucmh5dGhtXG5yaWJcbnJpYmJvblxucmljZVxucmljaFxucmlkZVxucmlkZ2VcbnJpZmxlXG5yaWdodFxucmlnaWRcbnJpbmdcbnJpb3RcbnJpcHBsZVxucmlza1xucml0dWFsXG5yaXZhbFxucml2ZXJcbnJvYWRcbnJvYXN0XG5yb2JvdFxucm9idXN0XG5yb2NrZXRcbnJvbWFuY2VcbnJvb2ZcbnJvb2tpZVxucm9vbVxucm9zZVxucm90YXRlXG5yb3VnaFxucm91bmRcbnJvdXRlXG5yb3lhbFxucnViYmVyXG5ydWRlXG5ydWdcbnJ1bGVcbnJ1blxucnVud2F5XG5ydXJhbFxuc2FkXG5zYWRkbGVcbnNhZG5lc3NcbnNhZmVcbnNhaWxcbnNhbGFkXG5zYWxtb25cbnNhbG9uXG5zYWx0XG5zYWx1dGVcbnNhbWVcbnNhbXBsZVxuc2FuZFxuc2F0aXNmeVxuc2F0b3NoaVxuc2F1Y2VcbnNhdXNhZ2VcbnNhdmVcbnNheVxuc2NhbGVcbnNjYW5cbnNjYXJlXG5zY2F0dGVyXG5zY2VuZVxuc2NoZW1lXG5zY2hvb2xcbnNjaWVuY2VcbnNjaXNzb3JzXG5zY29ycGlvblxuc2NvdXRcbnNjcmFwXG5zY3JlZW5cbnNjcmlwdFxuc2NydWJcbnNlYVxuc2VhcmNoXG5zZWFzb25cbnNlYXRcbnNlY29uZFxuc2VjcmV0XG5zZWN0aW9uXG5zZWN1cml0eVxuc2VlZFxuc2Vla1xuc2VnbWVudFxuc2VsZWN0XG5zZWxsXG5zZW1pbmFyXG5zZW5pb3JcbnNlbnNlXG5zZW50ZW5jZVxuc2VyaWVzXG5zZXJ2aWNlXG5zZXNzaW9uXG5zZXR0bGVcbnNldHVwXG5zZXZlblxuc2hhZG93XG5zaGFmdFxuc2hhbGxvd1xuc2hhcmVcbnNoZWRcbnNoZWxsXG5zaGVyaWZmXG5zaGllbGRcbnNoaWZ0XG5zaGluZVxuc2hpcFxuc2hpdmVyXG5zaG9ja1xuc2hvZVxuc2hvb3RcbnNob3BcbnNob3J0XG5zaG91bGRlclxuc2hvdmVcbnNocmltcFxuc2hydWdcbnNodWZmbGVcbnNoeVxuc2libGluZ1xuc2lja1xuc2lkZVxuc2llZ2VcbnNpZ2h0XG5zaWduXG5zaWxlbnRcbnNpbGtcbnNpbGx5XG5zaWx2ZXJcbnNpbWlsYXJcbnNpbXBsZVxuc2luY2VcbnNpbmdcbnNpcmVuXG5zaXN0ZXJcbnNpdHVhdGVcbnNpeFxuc2l6ZVxuc2thdGVcbnNrZXRjaFxuc2tpXG5za2lsbFxuc2tpblxuc2tpcnRcbnNrdWxsXG5zbGFiXG5zbGFtXG5zbGVlcFxuc2xlbmRlclxuc2xpY2VcbnNsaWRlXG5zbGlnaHRcbnNsaW1cbnNsb2dhblxuc2xvdFxuc2xvd1xuc2x1c2hcbnNtYWxsXG5zbWFydFxuc21pbGVcbnNtb2tlXG5zbW9vdGhcbnNuYWNrXG5zbmFrZVxuc25hcFxuc25pZmZcbnNub3dcbnNvYXBcbnNvY2Nlclxuc29jaWFsXG5zb2NrXG5zb2RhXG5zb2Z0XG5zb2xhclxuc29sZGllclxuc29saWRcbnNvbHV0aW9uXG5zb2x2ZVxuc29tZW9uZVxuc29uZ1xuc29vblxuc29ycnlcbnNvcnRcbnNvdWxcbnNvdW5kXG5zb3VwXG5zb3VyY2VcbnNvdXRoXG5zcGFjZVxuc3BhcmVcbnNwYXRpYWxcbnNwYXduXG5zcGVha1xuc3BlY2lhbFxuc3BlZWRcbnNwZWxsXG5zcGVuZFxuc3BoZXJlXG5zcGljZVxuc3BpZGVyXG5zcGlrZVxuc3Bpblxuc3Bpcml0XG5zcGxpdFxuc3BvaWxcbnNwb25zb3JcbnNwb29uXG5zcG9ydFxuc3BvdFxuc3ByYXlcbnNwcmVhZFxuc3ByaW5nXG5zcHlcbnNxdWFyZVxuc3F1ZWV6ZVxuc3F1aXJyZWxcbnN0YWJsZVxuc3RhZGl1bVxuc3RhZmZcbnN0YWdlXG5zdGFpcnNcbnN0YW1wXG5zdGFuZFxuc3RhcnRcbnN0YXRlXG5zdGF5XG5zdGVha1xuc3RlZWxcbnN0ZW1cbnN0ZXBcbnN0ZXJlb1xuc3RpY2tcbnN0aWxsXG5zdGluZ1xuc3RvY2tcbnN0b21hY2hcbnN0b25lXG5zdG9vbFxuc3RvcnlcbnN0b3ZlXG5zdHJhdGVneVxuc3RyZWV0XG5zdHJpa2VcbnN0cm9uZ1xuc3RydWdnbGVcbnN0dWRlbnRcbnN0dWZmXG5zdHVtYmxlXG5zdHlsZVxuc3ViamVjdFxuc3VibWl0XG5zdWJ3YXlcbnN1Y2Nlc3NcbnN1Y2hcbnN1ZGRlblxuc3VmZmVyXG5zdWdhclxuc3VnZ2VzdFxuc3VpdFxuc3VtbWVyXG5zdW5cbnN1bm55XG5zdW5zZXRcbnN1cGVyXG5zdXBwbHlcbnN1cHJlbWVcbnN1cmVcbnN1cmZhY2VcbnN1cmdlXG5zdXJwcmlzZVxuc3Vycm91bmRcbnN1cnZleVxuc3VzcGVjdFxuc3VzdGFpblxuc3dhbGxvd1xuc3dhbXBcbnN3YXBcbnN3YXJtXG5zd2Vhclxuc3dlZXRcbnN3aWZ0XG5zd2ltXG5zd2luZ1xuc3dpdGNoXG5zd29yZFxuc3ltYm9sXG5zeW1wdG9tXG5zeXJ1cFxuc3lzdGVtXG50YWJsZVxudGFja2xlXG50YWdcbnRhaWxcbnRhbGVudFxudGFsa1xudGFua1xudGFwZVxudGFyZ2V0XG50YXNrXG50YXN0ZVxudGF0dG9vXG50YXhpXG50ZWFjaFxudGVhbVxudGVsbFxudGVuXG50ZW5hbnRcbnRlbm5pc1xudGVudFxudGVybVxudGVzdFxudGV4dFxudGhhbmtcbnRoYXRcbnRoZW1lXG50aGVuXG50aGVvcnlcbnRoZXJlXG50aGV5XG50aGluZ1xudGhpc1xudGhvdWdodFxudGhyZWVcbnRocml2ZVxudGhyb3dcbnRodW1iXG50aHVuZGVyXG50aWNrZXRcbnRpZGVcbnRpZ2VyXG50aWx0XG50aW1iZXJcbnRpbWVcbnRpbnlcbnRpcFxudGlyZWRcbnRpc3N1ZVxudGl0bGVcbnRvYXN0XG50b2JhY2NvXG50b2RheVxudG9kZGxlclxudG9lXG50b2dldGhlclxudG9pbGV0XG50b2tlblxudG9tYXRvXG50b21vcnJvd1xudG9uZVxudG9uZ3VlXG50b25pZ2h0XG50b29sXG50b290aFxudG9wXG50b3BpY1xudG9wcGxlXG50b3JjaFxudG9ybmFkb1xudG9ydG9pc2VcbnRvc3NcbnRvdGFsXG50b3VyaXN0XG50b3dhcmRcbnRvd2VyXG50b3duXG50b3lcbnRyYWNrXG50cmFkZVxudHJhZmZpY1xudHJhZ2ljXG50cmFpblxudHJhbnNmZXJcbnRyYXBcbnRyYXNoXG50cmF2ZWxcbnRyYXlcbnRyZWF0XG50cmVlXG50cmVuZFxudHJpYWxcbnRyaWJlXG50cmlja1xudHJpZ2dlclxudHJpbVxudHJpcFxudHJvcGh5XG50cm91YmxlXG50cnVja1xudHJ1ZVxudHJ1bHlcbnRydW1wZXRcbnRydXN0XG50cnV0aFxudHJ5XG50dWJlXG50dWl0aW9uXG50dW1ibGVcbnR1bmFcbnR1bm5lbFxudHVya2V5XG50dXJuXG50dXJ0bGVcbnR3ZWx2ZVxudHdlbnR5XG50d2ljZVxudHdpblxudHdpc3RcbnR3b1xudHlwZVxudHlwaWNhbFxudWdseVxudW1icmVsbGFcbnVuYWJsZVxudW5hd2FyZVxudW5jbGVcbnVuY292ZXJcbnVuZGVyXG51bmRvXG51bmZhaXJcbnVuZm9sZFxudW5oYXBweVxudW5pZm9ybVxudW5pcXVlXG51bml0XG51bml2ZXJzZVxudW5rbm93blxudW5sb2NrXG51bnRpbFxudW51c3VhbFxudW52ZWlsXG51cGRhdGVcbnVwZ3JhZGVcbnVwaG9sZFxudXBvblxudXBwZXJcbnVwc2V0XG51cmJhblxudXJnZVxudXNhZ2VcbnVzZVxudXNlZFxudXNlZnVsXG51c2VsZXNzXG51c3VhbFxudXRpbGl0eVxudmFjYW50XG52YWN1dW1cbnZhZ3VlXG52YWxpZFxudmFsbGV5XG52YWx2ZVxudmFuXG52YW5pc2hcbnZhcG9yXG52YXJpb3VzXG52YXN0XG52YXVsdFxudmVoaWNsZVxudmVsdmV0XG52ZW5kb3JcbnZlbnR1cmVcbnZlbnVlXG52ZXJiXG52ZXJpZnlcbnZlcnNpb25cbnZlcnlcbnZlc3NlbFxudmV0ZXJhblxudmlhYmxlXG52aWJyYW50XG52aWNpb3VzXG52aWN0b3J5XG52aWRlb1xudmlld1xudmlsbGFnZVxudmludGFnZVxudmlvbGluXG52aXJ0dWFsXG52aXJ1c1xudmlzYVxudmlzaXRcbnZpc3VhbFxudml0YWxcbnZpdmlkXG52b2NhbFxudm9pY2VcbnZvaWRcbnZvbGNhbm9cbnZvbHVtZVxudm90ZVxudm95YWdlXG53YWdlXG53YWdvblxud2FpdFxud2Fsa1xud2FsbFxud2FsbnV0XG53YW50XG53YXJmYXJlXG53YXJtXG53YXJyaW9yXG53YXNoXG53YXNwXG53YXN0ZVxud2F0ZXJcbndhdmVcbndheVxud2VhbHRoXG53ZWFwb25cbndlYXJcbndlYXNlbFxud2VhdGhlclxud2ViXG53ZWRkaW5nXG53ZWVrZW5kXG53ZWlyZFxud2VsY29tZVxud2VzdFxud2V0XG53aGFsZVxud2hhdFxud2hlYXRcbndoZWVsXG53aGVuXG53aGVyZVxud2hpcFxud2hpc3Blclxud2lkZVxud2lkdGhcbndpZmVcbndpbGRcbndpbGxcbndpblxud2luZG93XG53aW5lXG53aW5nXG53aW5rXG53aW5uZXJcbndpbnRlclxud2lyZVxud2lzZG9tXG53aXNlXG53aXNoXG53aXRuZXNzXG53b2xmXG53b21hblxud29uZGVyXG53b29kXG53b29sXG53b3JkXG53b3JrXG53b3JsZFxud29ycnlcbndvcnRoXG53cmFwXG53cmVja1xud3Jlc3RsZVxud3Jpc3RcbndyaXRlXG53cm9uZ1xueWFyZFxueWVhclxueWVsbG93XG55b3VcbnlvdW5nXG55b3V0aFxuemVicmFcbnplcm9cbnpvbmVcbnpvb2Auc3BsaXQoJ1xcbicpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG5leHBvcnRzLmNyeXB0byA9IHtcbiAgICBub2RlOiB1bmRlZmluZWQsXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLmNoZWNrT3B0cyA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvQnl0ZXMgPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5hc3luY0xvb3AgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5pc0xFID0gZXhwb3J0cy5yb3RyID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnU4ID0gdm9pZCAwO1xuLy8gVGhlIGltcG9ydCBoZXJlIGlzIHZpYSB0aGUgcGFja2FnZSBuYW1lLiBUaGlzIGlzIHRvIGVuc3VyZVxuLy8gdGhhdCBleHBvcnRzIG1hcHBpbmcvcmVzb2x1dGlvbiBkb2VzIGZhbGwgaW50byBwbGFjZS5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGVyZSBpcyBhbG1vc3Qgbm8gYmlnIGVuZGlhbiBoYXJkd2FyZSwgYnV0IGpzIHR5cGVkIGFycmF5cyB1c2VzIHBsYXRmb3JtIHNwZWNpZmljIGVuZGlhbm5lc3MuXG4vLyBTbywganVzdCB0byBiZSBzdXJlIG5vdCB0byBjb3JydXB0IGFueXRoaW5nLlxuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGRlLCAweGFkLCAweGJlLCAweGVmXSkpXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2RlYWRiZWVmJylcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy4gSG93ZXZlciwgY2FsbCB0byBhc3luYyBmdW5jdGlvbiB3aWxsIHJldHVybiBQcm9taXNlXG4vLyB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbmV4cG9ydHMuYXN5bmNMb29wID0gYXN5bmNMb29wO1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdHlwZSBpcyBVaW50OEFycmF5IChnb3QgJHt0eXBlb2YgZGF0YX0pYCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuLyoqXG4gKiBDb25jYXRzIFVpbnQ4QXJyYXktcyBpbnRvIG9uZTsgbGlrZSBgQnVmZmVyLmNvbmNhdChbYnVmMSwgYnVmMl0pYFxuICogQGV4YW1wbGUgY29uY2F0Qnl0ZXMoYnVmMSwgYnVmMilcbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKCFhcnJheXMuZXZlcnkoKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWQnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtZXNzYWdlKSA9PiBoYXNoQ29uc3RydWN0b3IoKS51cGRhdGUodG9CeXRlcyhtZXNzYWdlKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJOR1xuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0by53ZWIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNyeXB0b18xLmNyeXB0by5ub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjcnlwdG9fMS5jcnlwdG8ubm9kZS5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCkuYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgcmFuZG9tQnl0ZXMgZnVuY3Rpb25cIik7XG4gICAgfVxufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBia2RmMkFzeW5jID0gZXhwb3J0cy5wYmtkZjIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgaG1hY19qc18xID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuaGFzaChoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBfb3B0cyk7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrIH0gPSBvcHRzO1xuICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihjKTtcbiAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIoZGtMZW4pO1xuICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihhc3luY1RpY2spO1xuICAgIGlmIChjIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQktERjI6IGl0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWNfanNfMS5obWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgdS5maWxsKDApO1xuICAgIHJldHVybiBESztcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBwYXNzd29yZCBmcm9tIHdoaWNoIGEgZGVyaXZlZCBrZXkgaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2FsdCAtIGNyeXB0b2dyYXBoaWMgc2FsdFxuICogQHBhcmFtIG9wdHMgLSB7YywgZGtMZW59IHdoZXJlIGMgaXMgd29yayBmYWN0b3IgYW5kIGRrTGVuIGlzIG91dHB1dCBtZXNzYWdlIHNpemVcbiAqL1xuZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyBcdTIyRUYgKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIFx1MjJFRiBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWNcdTIyMTIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbmV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xuYXN5bmMgZnVuY3Rpb24gcGJrZGYyQXN5bmMoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsgXHUyMkVGICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiBcdTIyRUYgXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCAoMCwgdXRpbHNfanNfMS5hc3luY0xvb3ApKGMgLSAxLCBhc3luY1RpY2ssIChpKSA9PiB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWNcdTIyMTIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0cy5wYmtkZjJBc3luYyA9IHBia2RmMkFzeW5jO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEEyID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyID0gU0hBMjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZCA9IGV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNwbGl0ID0gZXhwb3J0cy5mcm9tQmlnID0gdm9pZCAwO1xuY29uc3QgVTMyX01BU0s2NCA9IEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIGwsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKGgsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIGwpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG4vLyBSZW1vdmluZyBcImV4cG9ydFwiIGhhcyA1JSBwZXJmIHBlbmFsdHkgLV8tXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZzogZXhwb3J0cy50b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTM4NCA9IGV4cG9ydHMuc2hhNTEyXzI1NiA9IGV4cG9ydHMuc2hhNTEyXzIyNCA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5TSEE1MTIgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKFcyaCwgVzJsLCAxOSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEFoLCBBbCwgMjgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChBaCwgQWwsIDI4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTIgPSBTSEE1MTI7XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydHMuc2hhNTEyID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0cy5zaGE1MTJfMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydHMuc2hhNTEyXzI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnRzLnNoYTM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmhleCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gZXhwb3J0cy5iYXNlNThjaGVjayA9IGV4cG9ydHMuYmFzZTU4eG1yID0gZXhwb3J0cy5iYXNlNTh4cnAgPSBleHBvcnRzLmJhc2U1OGZsaWNrciA9IGV4cG9ydHMuYmFzZTU4ID0gZXhwb3J0cy5iYXNlNjR1cmwgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gZXhwb3J0cy5iYXNlMzJoZXggPSBleHBvcnRzLmJhc2UzMiA9IGV4cG9ydHMuYmFzZTE2ID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRzW2ldKSB8fCBkaWdpdHNbaV0gKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghZGlnaXRzW2ldKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxO1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy51dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0cy5iYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnRzLmJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNTggPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnRzLmJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0cy5iYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gZXhwb3J0cy5iYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBleHBvcnRzLmJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgZXhwb3J0cy5iYXNlNTgpO1xuZXhwb3J0cy5iYXNlNThjaGVjayA9IGJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0cy51dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydHMuaGV4ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4OiBleHBvcnRzLnV0ZjgsIGhleDogZXhwb3J0cy5oZXgsIGJhc2UxNjogZXhwb3J0cy5iYXNlMTYsIGJhc2UzMjogZXhwb3J0cy5iYXNlMzIsIGJhc2U2NDogZXhwb3J0cy5iYXNlNjQsIGJhc2U2NHVybDogZXhwb3J0cy5iYXNlNjR1cmwsIGJhc2U1ODogZXhwb3J0cy5iYXNlNTgsIGJhc2U1OHhtcjogZXhwb3J0cy5iYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9IGBJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogJHtPYmplY3Qua2V5cyhDT0RFUlMpLmpvaW4oJywgJyl9YDtcbmNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuc3RyID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nO1xuY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gZXhwb3J0cy52YWxpZGF0ZU1uZW1vbmljID0gZXhwb3J0cy5lbnRyb3B5VG9NbmVtb25pYyA9IGV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBleHBvcnRzLmdlbmVyYXRlTW5lbW9uaWMgPSB2b2lkIDA7XG4vKiEgc2N1cmUtYmlwMzkgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgX2Fzc2VydF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKTtcbmNvbnN0IHBia2RmMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCBzaGE1MTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbi8vIEphcGFuZXNlIHdvcmRsaXN0XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG4vLyBOb3JtYWxpemF0aW9uIHJlcGxhY2VzIGVxdWl2YWxlbnQgc2VxdWVuY2VzIG9mIGNoYXJhY3RlcnNcbi8vIHNvIHRoYXQgYW55IHR3byB0ZXh0cyB0aGF0IGFyZSBlcXVpdmFsZW50IHdpbGwgYmUgcmVkdWNlZFxuLy8gdG8gdGhlIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMsIGNhbGxlZCB0aGUgbm9ybWFsIGZvcm0gb2YgdGhlIG9yaWdpbmFsIHRleHQuXG5mdW5jdGlvbiBuZmtkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICBjb25zdCBub3JtID0gbmZrZChzdHIpO1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybS5zcGxpdCgnICcpO1xuICAgIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMod29yZHMubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1uZW1vbmljJyk7XG4gICAgcmV0dXJuIHsgbmZrZDogbm9ybSwgd29yZHMgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudHJvcHkoZW50cm9weSkge1xuICAgIF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzKGVudHJvcHksIDE2LCAyMCwgMjQsIDI4LCAzMik7XG59XG4vKipcbiAqIEdlbmVyYXRlIHggcmFuZG9tIHdvcmRzLiBVc2VzIENyeXB0b2dyYXBoaWNhbGx5LVNlY3VyZSBSYW5kb20gTnVtYmVyIEdlbmVyYXRvci5cbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEBwYXJhbSBzdHJlbmd0aCBtbmVtb25pYyBzdHJlbmd0aCAxMjgtMjU2IGJpdHNcbiAqIEBleGFtcGxlXG4gKiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCAxMjgpXG4gKiAvLyAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93J1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIF9hc3NlcnRfMS5kZWZhdWx0Lm51bWJlcihzdHJlbmd0aCk7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDAgfHwgc3RyZW5ndGggPiAyNTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZW50cm9weScpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYygoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1uZW1vbmljID0gZ2VuZXJhdGVNbmVtb25pYztcbmNvbnN0IGNhbGNDaGVja3N1bSA9IChlbnRyb3B5KSA9PiB7XG4gICAgLy8gQ2hlY2tzdW0gaXMgZW50Lmxlbmd0aC80IGJpdHMgbG9uZ1xuICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICAvLyBaZXJvIHJpZ2h0bW9zdCBcImJpdHNMZWZ0XCIgYml0cyBpbiBieXRlXG4gICAgLy8gRm9yIGV4YW1wbGU6IGJpdHNMZWZ0PTQgdmFsPTEwMTExMTAxIC0+IDEwMTEwMDAwXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsoKDAsIHNoYTI1Nl8xLnNoYTI1NikoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMiAqKiAxMSB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5ncycpO1xuICAgIHdvcmRsaXN0LmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29yZGxpc3Q6IG5vbi1zdHJpbmcgZWxlbWVudDogJHtpfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlXzEudXRpbHMuY2hhaW4oYmFzZV8xLnV0aWxzLmNoZWNrc3VtKDEsIGNhbGNDaGVja3N1bSksIGJhc2VfMS51dGlscy5yYWRpeDIoMTEsIHRydWUpLCBiYXNlXzEudXRpbHMuYWxwaGFiZXQod29yZGxpc3QpKTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgbW5lbW9uaWMgc3RyaW5nIHRvIHJhdyBlbnRyb3B5IGluIGZvcm0gb2YgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHdvcmRsaXN0IGltcG9ydGVkIHdvcmRsaXN0IGZvciBzcGVjaWZpYyBsYW5ndWFnZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9FbnRyb3B5KG1uZW0sIHdvcmRsaXN0KVxuICogLy8gUHJvZHVjZXNcbiAqIG5ldyBVaW50OEFycmF5KFtcbiAqICAgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZixcbiAqICAgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZiwgMHg3ZlxuICogXSlcbiAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gbm9ybWFsaXplKG1uZW1vbmljKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gZ2V0Q29kZXIod29yZGxpc3QpLmRlY29kZSh3b3Jkcyk7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbmV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weTtcbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhc3NlcnRFbnRyb3B5KGVudHJvcHkpO1xuICAgIGNvbnN0IHdvcmRzID0gZ2V0Q29kZXIod29yZGxpc3QpLmVuY29kZShlbnRyb3B5KTtcbiAgICByZXR1cm4gd29yZHMuam9pbihpc0phcGFuZXNlKHdvcmRsaXN0KSA/ICdcXHUzMDAwJyA6ICcgJyk7XG59XG5leHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG4vKipcbiAqIFZhbGlkYXRlcyBtbmVtb25pYyBmb3IgYmVpbmcgMTItMjQgd29yZHMgY29udGFpbmVkIGluIGB3b3JkbGlzdGAuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNbmVtb25pYyA9IHZhbGlkYXRlTW5lbW9uaWM7XG5jb25zdCBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoYG1uZW1vbmljJHtwYXNzcGhyYXNlfWApO1xuLyoqXG4gKiBJcnJldmVyc2libGU6IFVzZXMgS0RGIHRvIGRlcml2ZSA2NCBieXRlcyBvZiBrZXkgZGF0YSBmcm9tIG1uZW1vbmljICsgb3B0aW9uYWwgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSBwYXNzcGhyYXNlIHN0cmluZyB0aGF0IHdpbGwgYWRkaXRpb25hbGx5IHByb3RlY3QgdGhlIGtleVxuICogQHJldHVybnMgNjQgYnl0ZXMgb2Yga2V5IGRhdGFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBhd2FpdCBtbmVtb25pY1RvU2VlZChtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gKDAsIHBia2RmMl8xLnBia2RmMkFzeW5jKShzaGE1MTJfMS5zaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbW5lbW9uaWNUb1NlZWQ7XG4vKipcbiAqIElycmV2ZXJzaWJsZTogVXNlcyBLREYgdG8gZGVyaXZlIDY0IGJ5dGVzIG9mIGtleSBkYXRhIGZyb20gbW5lbW9uaWMgKyBvcHRpb25hbCBwYXNzd29yZC5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHBhc3NwaHJhc2Ugc3RyaW5nIHRoYXQgd2lsbCBhZGRpdGlvbmFsbHkgcHJvdGVjdCB0aGUga2V5XG4gKiBAcmV0dXJucyA2NCBieXRlcyBvZiBrZXkgZGF0YVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuICgwLCBwYmtkZjJfMS5wYmtkZjIpKHNoYTUxMl8xLnNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbmV4cG9ydHMubW5lbW9uaWNUb1NlZWRTeW5jID0gbW5lbW9uaWNUb1NlZWRTeW5jO1xuIiwgIi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zY2hlZHVsZXIuanNcbnZhciBmbHVzaFBlbmRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIHF1ZXVlID0gW107XG5mdW5jdGlvbiBzY2hlZHVsZXIoY2FsbGJhY2spIHtcbiAgcXVldWVKb2IoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gIGlmICghcXVldWUuaW5jbHVkZXMoam9iKSlcbiAgICBxdWV1ZS5wdXNoKGpvYik7XG4gIHF1ZXVlRmx1c2goKTtcbn1cbmZ1bmN0aW9uIGRlcXVldWVKb2Ioam9iKSB7XG4gIGxldCBpbmRleCA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICBxdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFmbHVzaGluZyAmJiAhZmx1c2hQZW5kaW5nKSB7XG4gICAgZmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBxdWV1ZU1pY3JvdGFzayhmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEpvYnMoKSB7XG4gIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXSgpO1xuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9yZWFjdGl2aXR5LmpzXG52YXIgcmVhY3RpdmU7XG52YXIgZWZmZWN0O1xudmFyIHJlbGVhc2U7XG52YXIgcmF3O1xudmFyIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nKGNhbGxiYWNrKSB7XG4gIHNob3VsZFNjaGVkdWxlID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldFJlYWN0aXZpdHlFbmdpbmUoZW5naW5lKSB7XG4gIHJlYWN0aXZlID0gZW5naW5lLnJlYWN0aXZlO1xuICByZWxlYXNlID0gZW5naW5lLnJlbGVhc2U7XG4gIGVmZmVjdCA9IChjYWxsYmFjaykgPT4gZW5naW5lLmVmZmVjdChjYWxsYmFjaywge3NjaGVkdWxlcjogKHRhc2spID0+IHtcbiAgICBpZiAoc2hvdWxkU2NoZWR1bGUpIHtcbiAgICAgIHNjaGVkdWxlcih0YXNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzaygpO1xuICAgIH1cbiAgfX0pO1xuICByYXcgPSBlbmdpbmUucmF3O1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVFZmZlY3Qob3ZlcnJpZGUpIHtcbiAgZWZmZWN0ID0gb3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBlbGVtZW50Qm91bmRFZmZlY3QoZWwpIHtcbiAgbGV0IGNsZWFudXAyID0gKCkgPT4ge1xuICB9O1xuICBsZXQgd3JhcHBlZEVmZmVjdCA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QoY2FsbGJhY2spO1xuICAgIGlmICghZWwuX3hfZWZmZWN0cykge1xuICAgICAgZWwuX3hfZWZmZWN0cyA9IG5ldyBTZXQoKTtcbiAgICAgIGVsLl94X3J1bkVmZmVjdHMgPSAoKSA9PiB7XG4gICAgICAgIGVsLl94X2VmZmVjdHMuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGVsLl94X2VmZmVjdHMuYWRkKGVmZmVjdFJlZmVyZW5jZSk7XG4gICAgY2xlYW51cDIgPSAoKSA9PiB7XG4gICAgICBpZiAoZWZmZWN0UmVmZXJlbmNlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGVsLl94X2VmZmVjdHMuZGVsZXRlKGVmZmVjdFJlZmVyZW5jZSk7XG4gICAgICByZWxlYXNlKGVmZmVjdFJlZmVyZW5jZSk7XG4gICAgfTtcbiAgICByZXR1cm4gZWZmZWN0UmVmZXJlbmNlO1xuICB9O1xuICByZXR1cm4gW3dyYXBwZWRFZmZlY3QsICgpID0+IHtcbiAgICBjbGVhbnVwMigpO1xuICB9XTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL211dGF0aW9uLmpzXG52YXIgb25BdHRyaWJ1dGVBZGRlZHMgPSBbXTtcbnZhciBvbkVsUmVtb3ZlZHMgPSBbXTtcbnZhciBvbkVsQWRkZWRzID0gW107XG5mdW5jdGlvbiBvbkVsQWRkZWQoY2FsbGJhY2spIHtcbiAgb25FbEFkZGVkcy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uRWxSZW1vdmVkKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIWVsLl94X2NsZWFudXBzKVxuICAgICAgZWwuX3hfY2xlYW51cHMgPSBbXTtcbiAgICBlbC5feF9jbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayA9IGVsO1xuICAgIG9uRWxSZW1vdmVkcy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gb25BdHRyaWJ1dGVzQWRkZWQoY2FsbGJhY2spIHtcbiAgb25BdHRyaWJ1dGVBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZVJlbW92ZWQoZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMgPSB7fTtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSlcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSA9IFtdO1xuICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBuYW1lcykge1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKVxuICAgIHJldHVybjtcbiAgT2JqZWN0LmVudHJpZXMoZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBpZiAobmFtZXMgPT09IHZvaWQgMCB8fCBuYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIGRlbGV0ZSBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25NdXRhdGUpO1xudmFyIGN1cnJlbnRseU9ic2VydmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlfSk7XG4gIGN1cnJlbnRseU9ic2VydmluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCkge1xuICBmbHVzaE9ic2VydmVyKCk7XG4gIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gZmFsc2U7XG59XG52YXIgcmVjb3JkUXVldWUgPSBbXTtcbnZhciB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBmbHVzaE9ic2VydmVyKCkge1xuICByZWNvcmRRdWV1ZSA9IHJlY29yZFF1ZXVlLmNvbmNhdChvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgaWYgKHJlY29yZFF1ZXVlLmxlbmd0aCAmJiAhd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSkge1xuICAgIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHByb2Nlc3NSZWNvcmRRdWV1ZSgpO1xuICAgICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVjb3JkUXVldWUoKSB7XG4gIG9uTXV0YXRlKHJlY29yZFF1ZXVlKTtcbiAgcmVjb3JkUXVldWUubGVuZ3RoID0gMDtcbn1cbmZ1bmN0aW9uIG11dGF0ZURvbShjYWxsYmFjaykge1xuICBpZiAoIWN1cnJlbnRseU9ic2VydmluZylcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgc3RvcE9ic2VydmluZ011dGF0aW9ucygpO1xuICBsZXQgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBpc0NvbGxlY3RpbmcgPSBmYWxzZTtcbnZhciBkZWZlcnJlZE11dGF0aW9ucyA9IFtdO1xuZnVuY3Rpb24gZGVmZXJNdXRhdGlvbnMoKSB7XG4gIGlzQ29sbGVjdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBmbHVzaEFuZFN0b3BEZWZlcnJpbmdNdXRhdGlvbnMoKSB7XG4gIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xuICBvbk11dGF0ZShkZWZlcnJlZE11dGF0aW9ucyk7XG4gIGRlZmVycmVkTXV0YXRpb25zID0gW107XG59XG5mdW5jdGlvbiBvbk11dGF0ZShtdXRhdGlvbnMpIHtcbiAgaWYgKGlzQ29sbGVjdGluZykge1xuICAgIGRlZmVycmVkTXV0YXRpb25zID0gZGVmZXJyZWRNdXRhdGlvbnMuY29uY2F0KG11dGF0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBhZGRlZE5vZGVzID0gW107XG4gIGxldCByZW1vdmVkTm9kZXMgPSBbXTtcbiAgbGV0IGFkZGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgbGV0IHJlbW92ZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtdXRhdGlvbnNbaV0udGFyZ2V0Ll94X2lnbm9yZU11dGF0aW9uT2JzZXJ2ZXIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgIG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDEgJiYgYWRkZWROb2Rlcy5wdXNoKG5vZGUpKTtcbiAgICAgIG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiByZW1vdmVkTm9kZXMucHVzaChub2RlKSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgIGxldCBlbCA9IG11dGF0aW9uc1tpXS50YXJnZXQ7XG4gICAgICBsZXQgbmFtZSA9IG11dGF0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgbGV0IG9sZFZhbHVlID0gbXV0YXRpb25zW2ldLm9sZFZhbHVlO1xuICAgICAgbGV0IGFkZDIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWRBdHRyaWJ1dGVzLmhhcyhlbCkpXG4gICAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLnNldChlbCwgW10pO1xuICAgICAgICBhZGRlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKHtuYW1lLCB2YWx1ZTogZWwuZ2V0QXR0cmlidXRlKG5hbWUpfSk7XG4gICAgICB9O1xuICAgICAgbGV0IHJlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFyZW1vdmVkQXR0cmlidXRlcy5oYXMoZWwpKVxuICAgICAgICAgIHJlbW92ZWRBdHRyaWJ1dGVzLnNldChlbCwgW10pO1xuICAgICAgICByZW1vdmVkQXR0cmlidXRlcy5nZXQoZWwpLnB1c2gobmFtZSk7XG4gICAgICB9O1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiBvbGRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBhZGQyKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgYWRkMigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xuICAgIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBhdHRycyk7XG4gIH0pO1xuICBhZGRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cnMsIGVsKSA9PiB7XG4gICAgb25BdHRyaWJ1dGVBZGRlZHMuZm9yRWFjaCgoaSkgPT4gaShlbCwgYXR0cnMpKTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBvbkVsUmVtb3ZlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XG4gICAgaWYgKG5vZGUuX3hfY2xlYW51cHMpIHtcbiAgICAgIHdoaWxlIChub2RlLl94X2NsZWFudXBzLmxlbmd0aClcbiAgICAgICAgbm9kZS5feF9jbGVhbnVwcy5wb3AoKSgpO1xuICAgIH1cbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xuICAgIG5vZGUuX3hfaWdub3JlID0gdHJ1ZTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgYWRkZWROb2Rlcykge1xuICAgIGlmIChyZW1vdmVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoIW5vZGUuaXNDb25uZWN0ZWQpXG4gICAgICBjb250aW51ZTtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgICBvbkVsQWRkZWRzLmZvckVhY2goKGkpID0+IGkobm9kZSkpO1xuICAgIG5vZGUuX3hfaWdub3JlID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xuICB9XG4gIGFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZVNlbGY7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlO1xuICB9KTtcbiAgYWRkZWROb2RlcyA9IG51bGw7XG4gIHJlbW92ZWROb2RlcyA9IG51bGw7XG4gIGFkZGVkQXR0cmlidXRlcyA9IG51bGw7XG4gIHJlbW92ZWRBdHRyaWJ1dGVzID0gbnVsbDtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3Njb3BlLmpzXG5mdW5jdGlvbiBzY29wZShub2RlKSB7XG4gIHJldHVybiBtZXJnZVByb3hpZXMoY2xvc2VzdERhdGFTdGFjayhub2RlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZVRvTm9kZShub2RlLCBkYXRhMiwgcmVmZXJlbmNlTm9kZSkge1xuICBub2RlLl94X2RhdGFTdGFjayA9IFtkYXRhMiwgLi4uY2xvc2VzdERhdGFTdGFjayhyZWZlcmVuY2VOb2RlIHx8IG5vZGUpXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBub2RlLl94X2RhdGFTdGFjayA9IG5vZGUuX3hfZGF0YVN0YWNrLmZpbHRlcigoaSkgPT4gaSAhPT0gZGF0YTIpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVmcmVzaFNjb3BlKGVsZW1lbnQsIHNjb3BlMikge1xuICBsZXQgZXhpc3RpbmdTY29wZSA9IGVsZW1lbnQuX3hfZGF0YVN0YWNrWzBdO1xuICBPYmplY3QuZW50cmllcyhzY29wZTIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGV4aXN0aW5nU2NvcGVba2V5XSA9IHZhbHVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3REYXRhU3RhY2sobm9kZSkge1xuICBpZiAobm9kZS5feF9kYXRhU3RhY2spXG4gICAgcmV0dXJuIG5vZGUuX3hfZGF0YVN0YWNrO1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIiAmJiBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUuaG9zdCk7XG4gIH1cbiAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3REYXRhU3RhY2sobm9kZS5wYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJveGllcyhvYmplY3RzKSB7XG4gIGxldCB0aGlzUHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICBvd25LZXlzOiAoKSA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG9iamVjdHMuZmxhdE1hcCgoaSkgPT4gT2JqZWN0LmtleXMoaSkpKSk7XG4gICAgfSxcbiAgICBoYXM6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBvYmplY3RzLnNvbWUoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICB9LFxuICAgIGdldDogKHRhcmdldCwgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIChvYmplY3RzLmZpbmQoKG9iaikgPT4ge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgbGV0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbmFtZSk7XG4gICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICYmIGRlc2NyaXB0b3IuZ2V0Ll94X2FscmVhZHlCb3VuZCB8fCBkZXNjcmlwdG9yLnNldCAmJiBkZXNjcmlwdG9yLnNldC5feF9hbHJlYWR5Qm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSBkZXNjcmlwdG9yLmdldDtcbiAgICAgICAgICAgIGxldCBzZXR0ZXIgPSBkZXNjcmlwdG9yLnNldDtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGRlc2NyaXB0b3I7XG4gICAgICAgICAgICBnZXR0ZXIgPSBnZXR0ZXIgJiYgZ2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcbiAgICAgICAgICAgIHNldHRlciA9IHNldHRlciAmJiBzZXR0ZXIuYmluZCh0aGlzUHJveHkpO1xuICAgICAgICAgICAgaWYgKGdldHRlcilcbiAgICAgICAgICAgICAgZ2V0dGVyLl94X2FscmVhZHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc2V0dGVyKVxuICAgICAgICAgICAgICBzZXR0ZXIuX3hfYWxyZWFkeUJvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgLi4ucHJvcGVydHksXG4gICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pIHx8IHt9KVtuYW1lXTtcbiAgICB9LFxuICAgIHNldDogKHRhcmdldCwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGxldCBjbG9zZXN0T2JqZWN0V2l0aEtleSA9IG9iamVjdHMuZmluZCgob2JqKSA9PiBvYmouaGFzT3duUHJvcGVydHkobmFtZSkpO1xuICAgICAgaWYgKGNsb3Nlc3RPYmplY3RXaXRoS2V5KSB7XG4gICAgICAgIGNsb3Nlc3RPYmplY3RXaXRoS2V5W25hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RzW29iamVjdHMubGVuZ3RoIC0gMV1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzUHJveHk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbnRlcmNlcHRvci5qc1xuZnVuY3Rpb24gaW5pdEludGVyY2VwdG9ycyhkYXRhMikge1xuICBsZXQgaXNPYmplY3QyID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbCAhPT0gbnVsbDtcbiAgbGV0IHJlY3Vyc2UgPSAob2JqLCBiYXNlUGF0aCA9IFwiXCIpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKS5mb3JFYWNoKChba2V5LCB7dmFsdWUsIGVudW1lcmFibGV9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0Mih2YWx1ZSkgJiYgdmFsdWUgIT09IG9iaiAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgICByZWN1cnNlKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcmVjdXJzZShkYXRhMik7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRvcihjYWxsYmFjaywgbXV0YXRlT2JqID0gKCkgPT4ge1xufSkge1xuICBsZXQgb2JqID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdm9pZCAwLFxuICAgIF94X2ludGVyY2VwdG9yOiB0cnVlLFxuICAgIGluaXRpYWxpemUoZGF0YTIsIHBhdGgsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuaW5pdGlhbFZhbHVlLCAoKSA9PiBnZXQoZGF0YTIsIHBhdGgpLCAodmFsdWUpID0+IHNldChkYXRhMiwgcGF0aCwgdmFsdWUpLCBwYXRoLCBrZXkpO1xuICAgIH1cbiAgfTtcbiAgbXV0YXRlT2JqKG9iaik7XG4gIHJldHVybiAoaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmIGluaXRpYWxWYWx1ZS5feF9pbnRlcmNlcHRvcikge1xuICAgICAgbGV0IGluaXRpYWxpemUgPSBvYmouaW5pdGlhbGl6ZS5iaW5kKG9iaik7XG4gICAgICBvYmouaW5pdGlhbGl6ZSA9IChkYXRhMiwgcGF0aCwga2V5KSA9PiB7XG4gICAgICAgIGxldCBpbm5lclZhbHVlID0gaW5pdGlhbFZhbHVlLmluaXRpYWxpemUoZGF0YTIsIHBhdGgsIGtleSk7XG4gICAgICAgIG9iai5pbml0aWFsVmFsdWUgPSBpbm5lclZhbHVlO1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iai5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKGNhcnJ5LCBzZWdtZW50KSA9PiBjYXJyeVtzZWdtZW50XSwgb2JqKTtcbn1cbmZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIilcbiAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSlcbiAgICBvYmpbcGF0aFswXV0gPSB2YWx1ZTtcbiAgZWxzZSBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgZXJyb3I7XG4gIGVsc2Uge1xuICAgIGlmIChvYmpbcGF0aFswXV0pXG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xuICAgIGVsc2Uge1xuICAgICAgb2JqW3BhdGhbMF1dID0ge307XG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLmpzXG52YXIgbWFnaWNzID0ge307XG5mdW5jdGlvbiBtYWdpYyhuYW1lLCBjYWxsYmFjaykge1xuICBtYWdpY3NbbmFtZV0gPSBjYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGluamVjdE1hZ2ljcyhvYmosIGVsKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1hZ2ljcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGAkJHtuYW1lfWAsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgbGV0IFt1dGlsaXRpZXMsIGNsZWFudXAyXSA9IGdldEVsZW1lbnRCb3VuZFV0aWxpdGllcyhlbCk7XG4gICAgICAgIHV0aWxpdGllcyA9IHtpbnRlcmNlcHRvciwgLi4udXRpbGl0aWVzfTtcbiAgICAgICAgb25FbFJlbW92ZWQoZWwsIGNsZWFudXAyKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVsLCB1dGlsaXRpZXMpO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZXJyb3IuanNcbmZ1bmN0aW9uIHRyeUNhdGNoKGVsLCBleHByZXNzaW9uLCBjYWxsYmFjaywgLi4uYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIGVsLCBleHByZXNzaW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbiA9IHZvaWQgMCkge1xuICBPYmplY3QuYXNzaWduKGVycm9yMiwge2VsLCBleHByZXNzaW9ufSk7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIEV4cHJlc3Npb24gRXJyb3I6ICR7ZXJyb3IyLm1lc3NhZ2V9XG5cbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH0sIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXG52YXIgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gdHJ1ZTtcbmZ1bmN0aW9uIGRvbnRBdXRvRXZhbHVhdGVGdW5jdGlvbnMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zO1xuICBzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgPSBmYWxzZTtcbiAgY2FsbGJhY2soKTtcbiAgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gY2FjaGU7XG59XG5mdW5jdGlvbiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgZXh0cmFzID0ge30pIHtcbiAgbGV0IHJlc3VsdDtcbiAgZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSwgZXh0cmFzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTGF0ZXIoLi4uYXJncykge1xuICByZXR1cm4gdGhlRXZhbHVhdG9yRnVuY3Rpb24oLi4uYXJncyk7XG59XG52YXIgdGhlRXZhbHVhdG9yRnVuY3Rpb24gPSBub3JtYWxFdmFsdWF0b3I7XG5mdW5jdGlvbiBzZXRFdmFsdWF0b3IobmV3RXZhbHVhdG9yKSB7XG4gIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbmV3RXZhbHVhdG9yO1xufVxuZnVuY3Rpb24gbm9ybWFsRXZhbHVhdG9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGxldCBvdmVycmlkZGVuTWFnaWNzID0ge307XG4gIGluamVjdE1hZ2ljcyhvdmVycmlkZGVuTWFnaWNzLCBlbCk7XG4gIGxldCBkYXRhU3RhY2sgPSBbb3ZlcnJpZGRlbk1hZ2ljcywgLi4uY2xvc2VzdERhdGFTdGFjayhlbCldO1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pO1xuICB9XG4gIGxldCBldmFsdWF0b3IgPSBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiB0cnlDYXRjaC5iaW5kKG51bGwsIGVsLCBleHByZXNzaW9uLCBldmFsdWF0b3IpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBmdW5jKSB7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdfSA9IHt9KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMuYXBwbHkobWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKCgpID0+IHsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XG4gIGNvbnN0IHNhZmVBc3luY0Z1bmN0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcbiAgZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpIHtcbiAgbGV0IGZ1bmMgPSBnZW5lcmF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdfSA9IHt9KSA9PiB7XG4gICAgZnVuYy5yZXN1bHQgPSB2b2lkIDA7XG4gICAgZnVuYy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBjb21wbGV0ZVNjb3BlID0gbWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pO1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IGZ1bmMoZnVuYywgY29tcGxldGVTY29wZSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpO1xuICAgICAgaWYgKGZ1bmMuZmluaXNoZWQpIHtcbiAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgZnVuYy5yZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xuICAgICAgICBmdW5jLnJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgcmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpLmZpbmFsbHkoKCkgPT4gZnVuYy5yZXN1bHQgPSB2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHZhbHVlLCBzY29wZTIsIHBhcmFtcywgZWwpIHtcbiAgaWYgKHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS5hcHBseShzY29wZTIsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJlc3VsdC50aGVuKChpKSA9PiBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCBpLCBzY29wZTIsIHBhcmFtcykpLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY2VpdmVyKHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlY2VpdmVyKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy5qc1xudmFyIHByZWZpeEFzU3RyaW5nID0gXCJ4LVwiO1xuZnVuY3Rpb24gcHJlZml4KHN1YmplY3QgPSBcIlwiKSB7XG4gIHJldHVybiBwcmVmaXhBc1N0cmluZyArIHN1YmplY3Q7XG59XG5mdW5jdGlvbiBzZXRQcmVmaXgobmV3UHJlZml4KSB7XG4gIHByZWZpeEFzU3RyaW5nID0gbmV3UHJlZml4O1xufVxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge307XG5mdW5jdGlvbiBkaXJlY3RpdmUobmFtZSwgY2FsbGJhY2spIHtcbiAgZGlyZWN0aXZlSGFuZGxlcnNbbmFtZV0gPSBjYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGRpcmVjdGl2ZXMoZWwsIGF0dHJpYnV0ZXMsIG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUpIHtcbiAgYXR0cmlidXRlcyA9IEFycmF5LmZyb20oYXR0cmlidXRlcyk7XG4gIGlmIChlbC5feF92aXJ0dWFsRGlyZWN0aXZlcykge1xuICAgIGxldCB2QXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGVsLl94X3ZpcnR1YWxEaXJlY3RpdmVzKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7bmFtZSwgdmFsdWV9KSk7XG4gICAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seSh2QXR0cmlidXRlcyk7XG4gICAgdkF0dHJpYnV0ZXMgPSB2QXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBgeC1iaW5kOiR7YXR0cmlidXRlLm5hbWV9YCxcbiAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdCh2QXR0cmlidXRlcyk7XG4gIH1cbiAgbGV0IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwID0ge307XG4gIGxldCBkaXJlY3RpdmVzMiA9IGF0dHJpYnV0ZXMubWFwKHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKChuZXdOYW1lLCBvbGROYW1lKSA9PiB0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcFtuZXdOYW1lXSA9IG9sZE5hbWUpKS5maWx0ZXIob3V0Tm9uQWxwaW5lQXR0cmlidXRlcykubWFwKHRvUGFyc2VkRGlyZWN0aXZlcyh0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcCwgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkpLnNvcnQoYnlQcmlvcml0eSk7XG4gIHJldHVybiBkaXJlY3RpdmVzMi5tYXAoKGRpcmVjdGl2ZTIpID0+IHtcbiAgICByZXR1cm4gZ2V0RGlyZWN0aXZlSGFuZGxlcihlbCwgZGlyZWN0aXZlMik7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0cmlidXRlc09ubHkoYXR0cmlidXRlcykge1xuICByZXR1cm4gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5tYXAodG9UcmFuc2Zvcm1lZEF0dHJpYnV0ZXMoKSkuZmlsdGVyKChhdHRyKSA9PiAhb3V0Tm9uQWxwaW5lQXR0cmlidXRlcyhhdHRyKSk7XG59XG52YXIgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xudmFyIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MgPSBuZXcgTWFwKCk7XG52YXIgY3VycmVudEhhbmRsZXJTdGFja0tleSA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZGVmZXJIYW5kbGluZ0RpcmVjdGl2ZXMoY2FsbGJhY2spIHtcbiAgaXNEZWZlcnJpbmdIYW5kbGVycyA9IHRydWU7XG4gIGxldCBrZXkgPSBTeW1ib2woKTtcbiAgY3VycmVudEhhbmRsZXJTdGFja0tleSA9IGtleTtcbiAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5zZXQoa2V5LCBbXSk7XG4gIGxldCBmbHVzaEhhbmRsZXJzID0gKCkgPT4ge1xuICAgIHdoaWxlIChkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLmdldChrZXkpLmxlbmd0aClcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGtleSkuc2hpZnQoKSgpO1xuICAgIGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZGVsZXRlKGtleSk7XG4gIH07XG4gIGxldCBzdG9wRGVmZXJyaW5nID0gKCkgPT4ge1xuICAgIGlzRGVmZXJyaW5nSGFuZGxlcnMgPSBmYWxzZTtcbiAgICBmbHVzaEhhbmRsZXJzKCk7XG4gIH07XG4gIGNhbGxiYWNrKGZsdXNoSGFuZGxlcnMpO1xuICBzdG9wRGVmZXJyaW5nKCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50Qm91bmRVdGlsaXRpZXMoZWwpIHtcbiAgbGV0IGNsZWFudXBzID0gW107XG4gIGxldCBjbGVhbnVwMiA9IChjYWxsYmFjaykgPT4gY2xlYW51cHMucHVzaChjYWxsYmFjayk7XG4gIGxldCBbZWZmZWN0MywgY2xlYW51cEVmZmVjdF0gPSBlbGVtZW50Qm91bmRFZmZlY3QoZWwpO1xuICBjbGVhbnVwcy5wdXNoKGNsZWFudXBFZmZlY3QpO1xuICBsZXQgdXRpbGl0aWVzID0ge1xuICAgIEFscGluZTogYWxwaW5lX2RlZmF1bHQsXG4gICAgZWZmZWN0OiBlZmZlY3QzLFxuICAgIGNsZWFudXA6IGNsZWFudXAyLFxuICAgIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIuYmluZChldmFsdWF0ZUxhdGVyLCBlbCksXG4gICAgZXZhbHVhdGU6IGV2YWx1YXRlLmJpbmQoZXZhbHVhdGUsIGVsKVxuICB9O1xuICBsZXQgZG9DbGVhbnVwID0gKCkgPT4gY2xlYW51cHMuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgcmV0dXJuIFt1dGlsaXRpZXMsIGRvQ2xlYW51cF07XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVIYW5kbGVyKGVsLCBkaXJlY3RpdmUyKSB7XG4gIGxldCBub29wID0gKCkgPT4ge1xuICB9O1xuICBsZXQgaGFuZGxlcjMgPSBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmUyLnR5cGVdIHx8IG5vb3A7XG4gIGxldCBbdXRpbGl0aWVzLCBjbGVhbnVwMl0gPSBnZXRFbGVtZW50Qm91bmRVdGlsaXRpZXMoZWwpO1xuICBvbkF0dHJpYnV0ZVJlbW92ZWQoZWwsIGRpcmVjdGl2ZTIub3JpZ2luYWwsIGNsZWFudXAyKTtcbiAgbGV0IGZ1bGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVyMy5pbmxpbmUgJiYgaGFuZGxlcjMuaW5saW5lKGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA/IGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkpLnB1c2goaGFuZGxlcjMpIDogaGFuZGxlcjMoKTtcbiAgfTtcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBjbGVhbnVwMjtcbiAgcmV0dXJuIGZ1bGxIYW5kbGVyO1xufVxudmFyIHN0YXJ0aW5nV2l0aCA9IChzdWJqZWN0LCByZXBsYWNlbWVudCkgPT4gKHtuYW1lLCB2YWx1ZX0pID0+IHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChzdWJqZWN0KSlcbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHN1YmplY3QsIHJlcGxhY2VtZW50KTtcbiAgcmV0dXJuIHtuYW1lLCB2YWx1ZX07XG59O1xudmFyIGludG8gPSAoaSkgPT4gaTtcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKGNhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKHtuYW1lLCB2YWx1ZX0pID0+IHtcbiAgICBsZXQge25hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZX0gPSBhdHRyaWJ1dGVUcmFuc2Zvcm1lcnMucmVkdWNlKChjYXJyeSwgdHJhbnNmb3JtKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGNhcnJ5KTtcbiAgICB9LCB7bmFtZSwgdmFsdWV9KTtcbiAgICBpZiAobmV3TmFtZSAhPT0gbmFtZSlcbiAgICAgIGNhbGxiYWNrKG5ld05hbWUsIG5hbWUpO1xuICAgIHJldHVybiB7bmFtZTogbmV3TmFtZSwgdmFsdWU6IG5ld1ZhbHVlfTtcbiAgfTtcbn1cbnZhciBhdHRyaWJ1dGVUcmFuc2Zvcm1lcnMgPSBbXTtcbmZ1bmN0aW9uIG1hcEF0dHJpYnV0ZXMoY2FsbGJhY2spIHtcbiAgYXR0cmlidXRlVHJhbnNmb3JtZXJzLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gb3V0Tm9uQWxwaW5lQXR0cmlidXRlcyh7bmFtZX0pIHtcbiAgcmV0dXJuIGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkudGVzdChuYW1lKTtcbn1cbnZhciBhbHBpbmVBdHRyaWJ1dGVSZWdleCA9ICgpID0+IG5ldyBSZWdFeHAoYF4ke3ByZWZpeEFzU3RyaW5nfShbXjpeLl0rKVxcXFxiYCk7XG5mdW5jdGlvbiB0b1BhcnNlZERpcmVjdGl2ZXModHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAsIG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUpIHtcbiAgcmV0dXJuICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gICAgbGV0IHR5cGVNYXRjaCA9IG5hbWUubWF0Y2goYWxwaW5lQXR0cmlidXRlUmVnZXgoKSk7XG4gICAgbGV0IHZhbHVlTWF0Y2ggPSBuYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC06XSspLyk7XG4gICAgbGV0IG1vZGlmaWVycyA9IG5hbWUubWF0Y2goL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2cpIHx8IFtdO1xuICAgIGxldCBvcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUgfHwgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXBbbmFtZV0gfHwgbmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZU1hdGNoID8gdHlwZU1hdGNoWzFdIDogbnVsbCxcbiAgICAgIHZhbHVlOiB2YWx1ZU1hdGNoID8gdmFsdWVNYXRjaFsxXSA6IG51bGwsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycy5tYXAoKGkpID0+IGkucmVwbGFjZShcIi5cIiwgXCJcIikpLFxuICAgICAgZXhwcmVzc2lvbjogdmFsdWUsXG4gICAgICBvcmlnaW5hbFxuICAgIH07XG4gIH07XG59XG52YXIgREVGQVVMVCA9IFwiREVGQVVMVFwiO1xudmFyIGRpcmVjdGl2ZU9yZGVyID0gW1xuICBcImlnbm9yZVwiLFxuICBcInJlZlwiLFxuICBcImRhdGFcIixcbiAgXCJpZFwiLFxuICBcInJhZGlvXCIsXG4gIFwidGFic1wiLFxuICBcInN3aXRjaFwiLFxuICBcImRpc2Nsb3N1cmVcIixcbiAgXCJtZW51XCIsXG4gIFwibGlzdGJveFwiLFxuICBcImxpc3RcIixcbiAgXCJpdGVtXCIsXG4gIFwiY29tYm9ib3hcIixcbiAgXCJiaW5kXCIsXG4gIFwiaW5pdFwiLFxuICBcImZvclwiLFxuICBcIm1hc2tcIixcbiAgXCJtb2RlbFwiLFxuICBcIm1vZGVsYWJsZVwiLFxuICBcInRyYW5zaXRpb25cIixcbiAgXCJzaG93XCIsXG4gIFwiaWZcIixcbiAgREVGQVVMVCxcbiAgXCJ0ZWxlcG9ydFwiXG5dO1xuZnVuY3Rpb24gYnlQcmlvcml0eShhLCBiKSB7XG4gIGxldCB0eXBlQSA9IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoYS50eXBlKSA9PT0gLTEgPyBERUZBVUxUIDogYS50eXBlO1xuICBsZXQgdHlwZUIgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGIudHlwZSkgPT09IC0xID8gREVGQVVMVCA6IGIudHlwZTtcbiAgcmV0dXJuIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUEpIC0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9kaXNwYXRjaC5qc1xuZnVuY3Rpb24gZGlzcGF0Y2goZWwsIG5hbWUsIGRldGFpbCA9IHt9KSB7XG4gIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICBkZXRhaWwsXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlXG4gIH0pKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL25leHRUaWNrLmpzXG52YXIgdGlja1N0YWNrID0gW107XG52YXIgaXNIb2xkaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlzSG9sZGluZyB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgdGlja1N0YWNrLnB1c2goKCkgPT4ge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJlcygpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VOZXh0VGlja3MoKSB7XG4gIGlzSG9sZGluZyA9IGZhbHNlO1xuICB3aGlsZSAodGlja1N0YWNrLmxlbmd0aClcbiAgICB0aWNrU3RhY2suc2hpZnQoKSgpO1xufVxuZnVuY3Rpb24gaG9sZE5leHRUaWNrcygpIHtcbiAgaXNIb2xkaW5nID0gdHJ1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3dhbGsuanNcbmZ1bmN0aW9uIHdhbGsoZWwsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiICYmIGVsIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pLmZvckVhY2goKGVsMikgPT4gd2FsayhlbDIsIGNhbGxiYWNrKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBza2lwID0gZmFsc2U7XG4gIGNhbGxiYWNrKGVsLCAoKSA9PiBza2lwID0gdHJ1ZSk7XG4gIGlmIChza2lwKVxuICAgIHJldHVybjtcbiAgbGV0IG5vZGUgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICB3YWxrKG5vZGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YXJuLmpzXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBBbHBpbmUgV2FybmluZzogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbGlmZWN5Y2xlLmpzXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgaWYgKCFkb2N1bWVudC5ib2R5KVxuICAgIHdhcm4oXCJVbmFibGUgdG8gaW5pdGlhbGl6ZS4gVHJ5aW5nIHRvIGxvYWQgQWxwaW5lIGJlZm9yZSBgPGJvZHk+YCBpcyBhdmFpbGFibGUuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBgZGVmZXJgIGluIEFscGluZSdzIGA8c2NyaXB0PmAgdGFnP1wiKTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRcIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0aWFsaXppbmdcIik7XG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIG9uRWxBZGRlZCgoZWwpID0+IGluaXRUcmVlKGVsLCB3YWxrKSk7XG4gIG9uRWxSZW1vdmVkKChlbCkgPT4gZGVzdHJveVRyZWUoZWwpKTtcbiAgb25BdHRyaWJ1dGVzQWRkZWQoKGVsLCBhdHRycykgPT4ge1xuICAgIGRpcmVjdGl2ZXMoZWwsIGF0dHJzKS5mb3JFYWNoKChoYW5kbGUpID0+IGhhbmRsZSgpKTtcbiAgfSk7XG4gIGxldCBvdXROZXN0ZWRDb21wb25lbnRzID0gKGVsKSA9PiAhY2xvc2VzdFJvb3QoZWwucGFyZW50RWxlbWVudCwgdHJ1ZSk7XG4gIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhbGxTZWxlY3RvcnMoKSkpLmZpbHRlcihvdXROZXN0ZWRDb21wb25lbnRzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGluaXRUcmVlKGVsKTtcbiAgfSk7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0aWFsaXplZFwiKTtcbn1cbnZhciByb290U2VsZWN0b3JDYWxsYmFja3MgPSBbXTtcbnZhciBpbml0U2VsZWN0b3JDYWxsYmFja3MgPSBbXTtcbmZ1bmN0aW9uIHJvb3RTZWxlY3RvcnMoKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JDYWxsYmFja3MubWFwKChmbikgPT4gZm4oKSk7XG59XG5mdW5jdGlvbiBhbGxTZWxlY3RvcnMoKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JDYWxsYmFja3MuY29uY2F0KGluaXRTZWxlY3RvckNhbGxiYWNrcykubWFwKChmbikgPT4gZm4oKSk7XG59XG5mdW5jdGlvbiBhZGRSb290U2VsZWN0b3Ioc2VsZWN0b3JDYWxsYmFjaykge1xuICByb290U2VsZWN0b3JDYWxsYmFja3MucHVzaChzZWxlY3RvckNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIGluaXRTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gY2xvc2VzdFJvb3QoZWwsIGluY2x1ZGVJbml0U2VsZWN0b3JzID0gZmFsc2UpIHtcbiAgcmV0dXJuIGZpbmRDbG9zZXN0KGVsLCAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IGluY2x1ZGVJbml0U2VsZWN0b3JzID8gYWxsU2VsZWN0b3JzKCkgOiByb290U2VsZWN0b3JzKCk7XG4gICAgaWYgKHNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdChlbCwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbClcbiAgICByZXR1cm47XG4gIGlmIChjYWxsYmFjayhlbCkpXG4gICAgcmV0dXJuIGVsO1xuICBpZiAoZWwuX3hfdGVsZXBvcnRCYWNrKVxuICAgIGVsID0gZWwuX3hfdGVsZXBvcnRCYWNrO1xuICBpZiAoIWVsLnBhcmVudEVsZW1lbnQpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gZmluZENsb3Nlc3QoZWwucGFyZW50RWxlbWVudCwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gaXNSb290KGVsKSB7XG4gIHJldHVybiByb290U2VsZWN0b3JzKCkuc29tZSgoc2VsZWN0b3IpID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIGluaXRUcmVlKGVsLCB3YWxrZXIgPSB3YWxrKSB7XG4gIGRlZmVySGFuZGxpbmdEaXJlY3RpdmVzKCgpID0+IHtcbiAgICB3YWxrZXIoZWwsIChlbDIsIHNraXApID0+IHtcbiAgICAgIGRpcmVjdGl2ZXMoZWwyLCBlbDIuYXR0cmlidXRlcykuZm9yRWFjaCgoaGFuZGxlKSA9PiBoYW5kbGUoKSk7XG4gICAgICBlbDIuX3hfaWdub3JlICYmIHNraXAoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXN0cm95VHJlZShyb290KSB7XG4gIHdhbGsocm9vdCwgKGVsKSA9PiBjbGVhbnVwQXR0cmlidXRlcyhlbCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvY2xhc3Nlcy5qc1xuZnVuY3Rpb24gc2V0Q2xhc3NlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2V0Q2xhc3NlcyhlbCwgdmFsdWUoKSk7XG4gIH1cbiAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgY2xhc3NTdHJpbmcpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nMikgPT4gY2xhc3NTdHJpbmcyLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBtaXNzaW5nQ2xhc3NlcyA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKChpKSA9PiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyA9IChjbGFzc2VzKSA9PiB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcbiAgICB9O1xuICB9O1xuICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nID09PSB0cnVlID8gY2xhc3NTdHJpbmcgPSBcIlwiIDogY2xhc3NTdHJpbmcgfHwgXCJcIjtcbiAgcmV0dXJuIGFkZENsYXNzZXNBbmRSZXR1cm5VbmRvKG1pc3NpbmdDbGFzc2VzKGNsYXNzU3RyaW5nKSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgY2xhc3NPYmplY3QpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nKSA9PiBjbGFzc1N0cmluZy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yQWRkID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+IGJvb2wgPyBzcGxpdChjbGFzc1N0cmluZykgOiBmYWxzZSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yUmVtb3ZlID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+ICFib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGFkZGVkID0gW107XG4gIGxldCByZW1vdmVkID0gW107XG4gIGZvclJlbW92ZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShpKTtcbiAgICAgIHJlbW92ZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICBmb3JBZGQuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGkpO1xuICAgICAgYWRkZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LmFkZChpKSk7XG4gICAgYWRkZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShpKSk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9zdHlsZXMuanNcbmZ1bmN0aW9uIHNldFN0eWxlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNldFN0eWxlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlc0Zyb21PYmplY3QoZWwsIHZhbHVlKSB7XG4gIGxldCBwcmV2aW91c1N0eWxlcyA9IHt9O1xuICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgIHByZXZpb3VzU3R5bGVzW2tleV0gPSBlbC5zdHlsZVtrZXldO1xuICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAga2V5ID0ga2ViYWJDYXNlKGtleSk7XG4gICAgfVxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUyKTtcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgc2V0U3R5bGVzKGVsLCBwcmV2aW91c1N0eWxlcyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSkge1xuICBsZXQgY2FjaGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYWNoZSB8fCBcIlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uY2UuanNcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRyYW5zaXRpb24uanNcbmRpcmVjdGl2ZShcInRyYW5zaXRpb25cIiwgKGVsLCB7dmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbn0sIHtldmFsdWF0ZTogZXZhbHVhdGUyfSkgPT4ge1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIilcbiAgICBleHByZXNzaW9uID0gZXZhbHVhdGUyKGV4cHJlc3Npb24pO1xuICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICByZWdpc3RlclRyYW5zaXRpb25zRnJvbUhlbHBlcihlbCwgbW9kaWZpZXJzLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21DbGFzc1N0cmluZyhlbCwgZXhwcmVzc2lvbiwgdmFsdWUpO1xuICB9XG59KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tQ2xhc3NTdHJpbmcoZWwsIGNsYXNzU3RyaW5nLCBzdGFnZSkge1xuICByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldENsYXNzZXMsIFwiXCIpO1xuICBsZXQgZGlyZWN0aXZlU3RvcmFnZU1hcCA9IHtcbiAgICBlbnRlcjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJlbnRlci1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kID0gY2xhc3NlcztcbiAgICB9LFxuICAgIGxlYXZlOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5kdXJpbmcgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1zdGFydFwiOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImxlYXZlLWVuZFwiOiAoY2xhc3NlcykgPT4ge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5lbmQgPSBjbGFzc2VzO1xuICAgIH1cbiAgfTtcbiAgZGlyZWN0aXZlU3RvcmFnZU1hcFtzdGFnZV0oY2xhc3NTdHJpbmcpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21IZWxwZXIoZWwsIG1vZGlmaWVycywgc3RhZ2UpIHtcbiAgcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRTdHlsZXMpO1xuICBsZXQgZG9lc250U3BlY2lmeSA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFzdGFnZTtcbiAgbGV0IHRyYW5zaXRpb25pbmdJbiA9IGRvZXNudFNwZWNpZnkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgfHwgW1wiZW50ZXJcIl0uaW5jbHVkZXMoc3RhZ2UpO1xuICBsZXQgdHJhbnNpdGlvbmluZ091dCA9IGRvZXNudFNwZWNpZnkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpIHx8IFtcImxlYXZlXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4IDwgbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRcIikgJiYgIWRvZXNudFNwZWNpZnkpIHtcbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPiBtb2RpZmllcnMuaW5kZXhPZihcIm91dFwiKSk7XG4gIH1cbiAgbGV0IHdhbnRzQWxsID0gIW1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcInNjYWxlXCIpO1xuICBsZXQgd2FudHNPcGFjaXR5ID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwib3BhY2l0eVwiKTtcbiAgbGV0IHdhbnRzU2NhbGUgPSB3YW50c0FsbCB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IG9wYWNpdHlWYWx1ZSA9IHdhbnRzT3BhY2l0eSA/IDAgOiAxO1xuICBsZXQgc2NhbGVWYWx1ZSA9IHdhbnRzU2NhbGUgPyBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJzY2FsZVwiLCA5NSkgLyAxMDAgOiAxO1xuICBsZXQgZGVsYXkgPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJkZWxheVwiLCAwKTtcbiAgbGV0IG9yaWdpbiA9IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBcIm9yaWdpblwiLCBcImNlbnRlclwiKTtcbiAgbGV0IHByb3BlcnR5ID0gXCJvcGFjaXR5LCB0cmFuc2Zvcm1cIjtcbiAgbGV0IGR1cmF0aW9uSW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJkdXJhdGlvblwiLCAxNTApIC8gMWUzO1xuICBsZXQgZHVyYXRpb25PdXQgPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJkdXJhdGlvblwiLCA3NSkgLyAxZTM7XG4gIGxldCBlYXNpbmcgPSBgY3ViaWMtYmV6aWVyKDAuNCwgMC4wLCAwLjIsIDEpYDtcbiAgaWYgKHRyYW5zaXRpb25pbmdJbikge1xuICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25Jbn1zYCxcbiAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZWFzaW5nXG4gICAgfTtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICB9XG4gIGlmICh0cmFuc2l0aW9uaW5nT3V0KSB7XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5kdXJpbmcgPSB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IG9yaWdpbixcbiAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXksXG4gICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtkdXJhdGlvbk91dH1zYCxcbiAgICAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZWFzaW5nXG4gICAgfTtcbiAgICBlbC5feF90cmFuc2l0aW9uLmxlYXZlLnN0YXJ0ID0ge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKDEpYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiBvcGFjaXR5VmFsdWUsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3NjYWxlVmFsdWV9KWBcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25PYmplY3QoZWwsIHNldEZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUgPSB7fSkge1xuICBpZiAoIWVsLl94X3RyYW5zaXRpb24pXG4gICAgZWwuX3hfdHJhbnNpdGlvbiA9IHtcbiAgICAgIGVudGVyOiB7ZHVyaW5nOiBkZWZhdWx0VmFsdWUsIHN0YXJ0OiBkZWZhdWx0VmFsdWUsIGVuZDogZGVmYXVsdFZhbHVlfSxcbiAgICAgIGxlYXZlOiB7ZHVyaW5nOiBkZWZhdWx0VmFsdWUsIHN0YXJ0OiBkZWZhdWx0VmFsdWUsIGVuZDogZGVmYXVsdFZhbHVlfSxcbiAgICAgIGluKGJlZm9yZSA9ICgpID0+IHtcbiAgICAgIH0sIGFmdGVyID0gKCkgPT4ge1xuICAgICAgfSkge1xuICAgICAgICB0cmFuc2l0aW9uKGVsLCBzZXRGdW5jdGlvbiwge1xuICAgICAgICAgIGR1cmluZzogdGhpcy5lbnRlci5kdXJpbmcsXG4gICAgICAgICAgc3RhcnQ6IHRoaXMuZW50ZXIuc3RhcnQsXG4gICAgICAgICAgZW5kOiB0aGlzLmVudGVyLmVuZFxuICAgICAgICB9LCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgIH0sXG4gICAgICBvdXQoYmVmb3JlID0gKCkgPT4ge1xuICAgICAgfSwgYWZ0ZXIgPSAoKSA9PiB7XG4gICAgICB9KSB7XG4gICAgICAgIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7XG4gICAgICAgICAgZHVyaW5nOiB0aGlzLmxlYXZlLmR1cmluZyxcbiAgICAgICAgICBzdGFydDogdGhpcy5sZWF2ZS5zdGFydCxcbiAgICAgICAgICBlbmQ6IHRoaXMubGVhdmUuZW5kXG4gICAgICAgIH0sIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgfVxuICAgIH07XG59XG53aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKGVsLCB2YWx1ZSwgc2hvdywgaGlkZSkge1xuICBjb25zdCBuZXh0VGljazIgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dDtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4gbmV4dFRpY2syKHNob3cpO1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoZWwuX3hfdHJhbnNpdGlvbiAmJiAoZWwuX3hfdHJhbnNpdGlvbi5lbnRlciB8fCBlbC5feF90cmFuc2l0aW9uLmxlYXZlKSkge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlciAmJiAoT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0KS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQpLmxlbmd0aCkgPyBlbC5feF90cmFuc2l0aW9uLmluKHNob3cpIDogY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbiA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZWwuX3hfaGlkZVByb21pc2UgPSBlbC5feF90cmFuc2l0aW9uID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGVsLl94X3RyYW5zaXRpb24ub3V0KCgpID0+IHtcbiAgICB9LCAoKSA9PiByZXNvbHZlKGhpZGUpKTtcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmJlZm9yZUNhbmNlbCgoKSA9PiByZWplY3Qoe2lzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb246IHRydWV9KSk7XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKGhpZGUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIGlmICghY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4pXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XG4gICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbi5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRpY2syKCgpID0+IHtcbiAgICAgICAgbGV0IGhpZGVBZnRlckNoaWxkcmVuID0gKGVsMikgPT4ge1xuICAgICAgICAgIGxldCBjYXJyeSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGVsMi5feF9oaWRlUHJvbWlzZSxcbiAgICAgICAgICAgIC4uLihlbDIuX3hfaGlkZUNoaWxkcmVuIHx8IFtdKS5tYXAoaGlkZUFmdGVyQ2hpbGRyZW4pXG4gICAgICAgICAgXSkudGhlbigoW2ldKSA9PiBpKCkpO1xuICAgICAgICAgIGRlbGV0ZSBlbDIuX3hfaGlkZVByb21pc2U7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlQ2hpbGRyZW47XG4gICAgICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgICAgICB9O1xuICAgICAgICBoaWRlQWZ0ZXJDaGlsZHJlbihlbCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBpZiAoIWUuaXNGcm9tQ2FuY2VsbGVkVHJhbnNpdGlvbilcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBjbG9zZXN0SGlkZShlbCkge1xuICBsZXQgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKCFwYXJlbnQpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gcGFyZW50Ll94X2hpZGVQcm9taXNlID8gcGFyZW50IDogY2xvc2VzdEhpZGUocGFyZW50KTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7ZHVyaW5nLCBzdGFydDogc3RhcnQyLCBlbmR9ID0ge30sIGJlZm9yZSA9ICgpID0+IHtcbn0sIGFmdGVyID0gKCkgPT4ge1xufSkge1xuICBpZiAoZWwuX3hfdHJhbnNpdGlvbmluZylcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmNhbmNlbCgpO1xuICBpZiAoT2JqZWN0LmtleXMoZHVyaW5nKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3RhcnQyKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoZW5kKS5sZW5ndGggPT09IDApIHtcbiAgICBiZWZvcmUoKTtcbiAgICBhZnRlcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdW5kb1N0YXJ0LCB1bmRvRHVyaW5nLCB1bmRvRW5kO1xuICBwZXJmb3JtVHJhbnNpdGlvbihlbCwge1xuICAgIHN0YXJ0KCkge1xuICAgICAgdW5kb1N0YXJ0ID0gc2V0RnVuY3Rpb24oZWwsIHN0YXJ0Mik7XG4gICAgfSxcbiAgICBkdXJpbmcoKSB7XG4gICAgICB1bmRvRHVyaW5nID0gc2V0RnVuY3Rpb24oZWwsIGR1cmluZyk7XG4gICAgfSxcbiAgICBiZWZvcmUsXG4gICAgZW5kKCkge1xuICAgICAgdW5kb1N0YXJ0KCk7XG4gICAgICB1bmRvRW5kID0gc2V0RnVuY3Rpb24oZWwsIGVuZCk7XG4gICAgfSxcbiAgICBhZnRlcixcbiAgICBjbGVhbnVwKCkge1xuICAgICAgdW5kb0R1cmluZygpO1xuICAgICAgdW5kb0VuZCgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVHJhbnNpdGlvbihlbCwgc3RhZ2VzKSB7XG4gIGxldCBpbnRlcnJ1cHRlZCwgcmVhY2hlZEJlZm9yZSwgcmVhY2hlZEVuZDtcbiAgbGV0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICBpZiAoIXJlYWNoZWRCZWZvcmUpXG4gICAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICAgIGlmICghcmVhY2hlZEVuZCkge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIH1cbiAgICAgIHN0YWdlcy5hZnRlcigpO1xuICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKVxuICAgICAgICBzdGFnZXMuY2xlYW51cCgpO1xuICAgICAgZGVsZXRlIGVsLl94X3RyYW5zaXRpb25pbmc7XG4gICAgfSk7XG4gIH0pO1xuICBlbC5feF90cmFuc2l0aW9uaW5nID0ge1xuICAgIGJlZm9yZUNhbmNlbHM6IFtdLFxuICAgIGJlZm9yZUNhbmNlbChjYWxsYmFjaykge1xuICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG4gICAgY2FuY2VsOiBvbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMuYmVmb3JlQ2FuY2Vscy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVDYW5jZWxzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGZpbmlzaCgpO1xuICAgIH0pLFxuICAgIGZpbmlzaFxuICB9O1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIHN0YWdlcy5zdGFydCgpO1xuICAgIHN0YWdlcy5kdXJpbmcoKTtcbiAgfSk7XG4gIGhvbGROZXh0VGlja3MoKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoaW50ZXJydXB0ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbGV0IGRlbGF5ID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EZWxheS5yZXBsYWNlKC8sLiovLCBcIlwiKS5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKVxuICAgICAgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24ucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBzdGFnZXMuYmVmb3JlKCk7XG4gICAgfSk7XG4gICAgcmVhY2hlZEJlZm9yZSA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgfSk7XG4gICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgICBzZXRUaW1lb3V0KGVsLl94X3RyYW5zaXRpb25pbmcuZmluaXNoLCBkdXJhdGlvbiArIGRlbGF5KTtcbiAgICAgIHJlYWNoZWRFbmQgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XG4gIGlmIChtb2RpZmllcnMuaW5kZXhPZihrZXkpID09PSAtMSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGNvbnN0IHJhd1ZhbHVlID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAxXTtcbiAgaWYgKCFyYXdWYWx1ZSlcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGlmIChrZXkgPT09IFwic2NhbGVcIikge1xuICAgIGlmIChpc05hTihyYXdWYWx1ZSkpXG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgbGV0IG1hdGNoID0gcmF3VmFsdWUubWF0Y2goLyhbMC05XSspbXMvKTtcbiAgICBpZiAobWF0Y2gpXG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJvcmlnaW5cIikge1xuICAgIGlmIChbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJib3R0b21cIl0uaW5jbHVkZXMobW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXSkpIHtcbiAgICAgIHJldHVybiBbcmF3VmFsdWUsIG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMl1dLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3VmFsdWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9jbG9uZS5qc1xudmFyIGlzQ2xvbmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc2tpcER1cmluZ0Nsb25lKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBpc0Nsb25pbmcgPyBmYWxsYmFjayguLi5hcmdzKSA6IGNhbGxiYWNrKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gY2xvbmUob2xkRWwsIG5ld0VsKSB7XG4gIGlmICghbmV3RWwuX3hfZGF0YVN0YWNrKVxuICAgIG5ld0VsLl94X2RhdGFTdGFjayA9IG9sZEVsLl94X2RhdGFTdGFjaztcbiAgaXNDbG9uaW5nID0gdHJ1ZTtcbiAgZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cygoKSA9PiB7XG4gICAgY2xvbmVUcmVlKG5ld0VsKTtcbiAgfSk7XG4gIGlzQ2xvbmluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2xvbmVUcmVlKGVsKSB7XG4gIGxldCBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IGZhbHNlO1xuICBsZXQgc2hhbGxvd1dhbGtlciA9IChlbDIsIGNhbGxiYWNrKSA9PiB7XG4gICAgd2FsayhlbDIsIChlbDMsIHNraXApID0+IHtcbiAgICAgIGlmIChoYXNSdW5UaHJvdWdoRmlyc3RFbCAmJiBpc1Jvb3QoZWwzKSlcbiAgICAgICAgcmV0dXJuIHNraXAoKTtcbiAgICAgIGhhc1J1blRocm91Z2hGaXJzdEVsID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVsMywgc2tpcCk7XG4gICAgfSk7XG4gIH07XG4gIGluaXRUcmVlKGVsLCBzaGFsbG93V2Fsa2VyKTtcbn1cbmZ1bmN0aW9uIGRvbnRSZWdpc3RlclJlYWN0aXZlU2lkZUVmZmVjdHMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gZWZmZWN0O1xuICBvdmVycmlkZUVmZmVjdCgoY2FsbGJhY2syLCBlbCkgPT4ge1xuICAgIGxldCBzdG9yZWRFZmZlY3QgPSBjYWNoZShjYWxsYmFjazIpO1xuICAgIHJlbGVhc2Uoc3RvcmVkRWZmZWN0KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH0pO1xuICBjYWxsYmFjaygpO1xuICBvdmVycmlkZUVmZmVjdChjYWNoZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9iaW5kLmpzXG5mdW5jdGlvbiBiaW5kKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzID0gW10pIHtcbiAgaWYgKCFlbC5feF9iaW5kaW5ncylcbiAgICBlbC5feF9iaW5kaW5ncyA9IHJlYWN0aXZlKHt9KTtcbiAgZWwuX3hfYmluZGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgbmFtZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcImNhbWVsXCIpID8gY2FtZWxDYXNlKG5hbWUpIDogbmFtZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBiaW5kU3R5bGVzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgaWYgKGVsLmF0dHJpYnV0ZXMudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5mcm9tTW9kZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgIVtudWxsLCB2b2lkIDBdLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgZWwudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLnNvbWUoKHZhbCkgPT4gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsLCBlbC52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgICB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWwudmFsdWUgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcylcbiAgICBlbC5feF91bmRvQWRkZWRDbGFzc2VzKCk7XG4gIGVsLl94X3VuZG9BZGRlZENsYXNzZXMgPSBzZXRDbGFzc2VzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kU3R5bGVzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkU3R5bGVzKVxuICAgIGVsLl94X3VuZG9BZGRlZFN0eWxlcygpO1xuICBlbC5feF91bmRvQWRkZWRTdHlsZXMgPSBzZXRTdHlsZXMoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChbbnVsbCwgdm9pZCAwLCBmYWxzZV0uaW5jbHVkZXModmFsdWUpICYmIGF0dHJpYnV0ZVNob3VsZG50QmVQcmVzZXJ2ZWRJZkZhbHN5KG5hbWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKG5hbWUpKVxuICAgICAgdmFsdWUgPSBuYW1lO1xuICAgIHNldElmQ2hhbmdlZChlbCwgbmFtZSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJZkNoYW5nZWQoZWwsIGF0dHJOYW1lLCB2YWx1ZSkge1xuICBpZiAoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSAhPSB2YWx1ZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGFycmF5V3JhcHBlZFZhbHVlID0gW10uY29uY2F0KHZhbHVlKS5tYXAoKHZhbHVlMikgPT4ge1xuICAgIHJldHVybiB2YWx1ZTIgKyBcIlwiO1xuICB9KTtcbiAgQXJyYXkuZnJvbShlbC5vcHRpb25zKS5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICBvcHRpb24uc2VsZWN0ZWQgPSBhcnJheVdyYXBwZWRWYWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbWVsQ2FzZShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csIChtYXRjaCwgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbHVlQSwgdmFsdWVCKSB7XG4gIHJldHVybiB2YWx1ZUEgPT0gdmFsdWVCO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuQXR0cihhdHRyTmFtZSkge1xuICBjb25zdCBib29sZWFuQXR0cmlidXRlcyA9IFtcbiAgICBcImRpc2FibGVkXCIsXG4gICAgXCJjaGVja2VkXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwicmVhZG9ubHlcIixcbiAgICBcImhpZGRlblwiLFxuICAgIFwib3BlblwiLFxuICAgIFwic2VsZWN0ZWRcIixcbiAgICBcImF1dG9mb2N1c1wiLFxuICAgIFwiaXRlbXNjb3BlXCIsXG4gICAgXCJtdWx0aXBsZVwiLFxuICAgIFwibm92YWxpZGF0ZVwiLFxuICAgIFwiYWxsb3dmdWxsc2NyZWVuXCIsXG4gICAgXCJhbGxvd3BheW1lbnRyZXF1ZXN0XCIsXG4gICAgXCJmb3Jtbm92YWxpZGF0ZVwiLFxuICAgIFwiYXV0b3BsYXlcIixcbiAgICBcImNvbnRyb2xzXCIsXG4gICAgXCJsb29wXCIsXG4gICAgXCJtdXRlZFwiLFxuICAgIFwicGxheXNpbmxpbmVcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImlzbWFwXCIsXG4gICAgXCJyZXZlcnNlZFwiLFxuICAgIFwiYXN5bmNcIixcbiAgICBcImRlZmVyXCIsXG4gICAgXCJub21vZHVsZVwiXG4gIF07XG4gIHJldHVybiBib29sZWFuQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyTmFtZSk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVTaG91bGRudEJlUHJlc2VydmVkSWZGYWxzeShuYW1lKSB7XG4gIHJldHVybiAhW1wiYXJpYS1wcmVzc2VkXCIsIFwiYXJpYS1jaGVja2VkXCIsIFwiYXJpYS1leHBhbmRlZFwiLCBcImFyaWEtc2VsZWN0ZWRcIl0uaW5jbHVkZXMobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nKGVsLCBuYW1lLCBmYWxsYmFjaykge1xuICBpZiAoZWwuX3hfYmluZGluZ3MgJiYgZWwuX3hfYmluZGluZ3NbbmFtZV0gIT09IHZvaWQgMClcbiAgICByZXR1cm4gZWwuX3hfYmluZGluZ3NbbmFtZV07XG4gIGxldCBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAoYXR0ciA9PT0gbnVsbClcbiAgICByZXR1cm4gdHlwZW9mIGZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gIGlmIChhdHRyID09PSBcIlwiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoaXNCb29sZWFuQXR0cihuYW1lKSkge1xuICAgIHJldHVybiAhIVtuYW1lLCBcInRydWVcIl0uaW5jbHVkZXMoYXR0cik7XG4gIH1cbiAgcmV0dXJuIGF0dHI7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9kZWJvdW5jZS5qc1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy90aHJvdHRsZS5qc1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgbGltaXQpIHtcbiAgbGV0IGluVGhyb3R0bGU7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKCFpblRocm90dGxlKSB7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaW5UaHJvdHRsZSA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGluVGhyb3R0bGUgPSBmYWxzZSwgbGltaXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3BsdWdpbi5qc1xuZnVuY3Rpb24gcGx1Z2luKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKGFscGluZV9kZWZhdWx0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3N0b3JlLmpzXG52YXIgc3RvcmVzID0ge307XG52YXIgaXNSZWFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gc3RvcmUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc1JlYWN0aXZlKSB7XG4gICAgc3RvcmVzID0gcmVhY3RpdmUoc3RvcmVzKTtcbiAgICBpc1JlYWN0aXZlID0gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBzdG9yZXNbbmFtZV07XG4gIH1cbiAgc3RvcmVzW25hbWVdID0gdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpICYmIHR5cGVvZiB2YWx1ZS5pbml0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdG9yZXNbbmFtZV0uaW5pdCgpO1xuICB9XG4gIGluaXRJbnRlcmNlcHRvcnMoc3RvcmVzW25hbWVdKTtcbn1cbmZ1bmN0aW9uIGdldFN0b3JlcygpIHtcbiAgcmV0dXJuIHN0b3Jlcztcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2JpbmRzLmpzXG52YXIgYmluZHMgPSB7fTtcbmZ1bmN0aW9uIGJpbmQyKG5hbWUsIGJpbmRpbmdzKSB7XG4gIGxldCBnZXRCaW5kaW5ncyA9IHR5cGVvZiBiaW5kaW5ncyAhPT0gXCJmdW5jdGlvblwiID8gKCkgPT4gYmluZGluZ3MgOiBiaW5kaW5ncztcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgYXBwbHlCaW5kaW5nc09iamVjdChuYW1lLCBnZXRCaW5kaW5ncygpKTtcbiAgfSBlbHNlIHtcbiAgICBiaW5kc1tuYW1lXSA9IGdldEJpbmRpbmdzO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3RCaW5kaW5nUHJvdmlkZXJzKG9iaikge1xuICBPYmplY3QuZW50cmllcyhiaW5kcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIG9iaiwgb3JpZ2luYWwpIHtcbiAgbGV0IGNsZWFudXBSdW5uZXJzID0gW107XG4gIHdoaWxlIChjbGVhbnVwUnVubmVycy5sZW5ndGgpXG4gICAgY2xlYW51cFJ1bm5lcnMucG9wKCkoKTtcbiAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHtuYW1lLCB2YWx1ZX0pKTtcbiAgbGV0IHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKTtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICBpZiAoc3RhdGljQXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXG4gICAgICAgIHZhbHVlOiBgXCIke2F0dHJpYnV0ZS52YWx1ZX1cImBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH0pO1xuICBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbCkubWFwKChoYW5kbGUpID0+IHtcbiAgICBjbGVhbnVwUnVubmVycy5wdXNoKGhhbmRsZS5ydW5DbGVhbnVwcyk7XG4gICAgaGFuZGxlKCk7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGF0YXMuanNcbnZhciBkYXRhcyA9IHt9O1xuZnVuY3Rpb24gZGF0YShuYW1lLCBjYWxsYmFjaykge1xuICBkYXRhc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0RGF0YVByb3ZpZGVycyhvYmosIGNvbnRleHQpIHtcbiAgT2JqZWN0LmVudHJpZXMoZGF0YXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXG52YXIgQWxwaW5lID0ge1xuICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlO1xuICB9LFxuICBnZXQgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfSxcbiAgZ2V0IGVmZmVjdCgpIHtcbiAgICByZXR1cm4gZWZmZWN0O1xuICB9LFxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiByYXc7XG4gIH0sXG4gIHZlcnNpb246IFwiMy4xMC41XCIsXG4gIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucyxcbiAgZG9udEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyxcbiAgZGlzYWJsZUVmZmVjdFNjaGVkdWxpbmcsXG4gIHNldFJlYWN0aXZpdHlFbmdpbmUsXG4gIGNsb3Nlc3REYXRhU3RhY2ssXG4gIHNraXBEdXJpbmdDbG9uZSxcbiAgYWRkUm9vdFNlbGVjdG9yLFxuICBhZGRJbml0U2VsZWN0b3IsXG4gIGFkZFNjb3BlVG9Ob2RlLFxuICBkZWZlck11dGF0aW9ucyxcbiAgbWFwQXR0cmlidXRlcyxcbiAgZXZhbHVhdGVMYXRlcixcbiAgc2V0RXZhbHVhdG9yLFxuICBtZXJnZVByb3hpZXMsXG4gIGZpbmRDbG9zZXN0LFxuICBjbG9zZXN0Um9vdCxcbiAgaW50ZXJjZXB0b3IsXG4gIHRyYW5zaXRpb24sXG4gIHNldFN0eWxlcyxcbiAgbXV0YXRlRG9tLFxuICBkaXJlY3RpdmUsXG4gIHRocm90dGxlLFxuICBkZWJvdW5jZSxcbiAgZXZhbHVhdGUsXG4gIGluaXRUcmVlLFxuICBuZXh0VGljayxcbiAgcHJlZml4ZWQ6IHByZWZpeCxcbiAgcHJlZml4OiBzZXRQcmVmaXgsXG4gIHBsdWdpbixcbiAgbWFnaWMsXG4gIHN0b3JlLFxuICBzdGFydCxcbiAgY2xvbmUsXG4gIGJvdW5kOiBnZXRCaW5kaW5nLFxuICAkZGF0YTogc2NvcGUsXG4gIGRhdGEsXG4gIGJpbmQ6IGJpbmQyXG59O1xudmFyIGFscGluZV9kZWZhdWx0ID0gQWxwaW5lO1xuXG4vLyBub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanNcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gKHZhbCkgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogKHZhbCkgPT4gISFtYXBbdmFsXTtcbn1cbnZhciBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcbnZhciBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcbnZhciBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG52YXIgaXNCb29sZWFuQXR0cjIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XG52YXIgRU1QVFlfT0JKID0gdHJ1ZSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG52YXIgRU1QVFlfQVJSID0gdHJ1ZSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG52YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xudmFyIGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG52YXIgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbnZhciB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbnZhciBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xudmFyIGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpO1xufSk7XG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG52YXIgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xudmFyIGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xuXG4vLyBub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qc1xudmFyIHRhcmdldE1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgZWZmZWN0U3RhY2sgPSBbXTtcbnZhciBhY3RpdmVFZmZlY3Q7XG52YXIgSVRFUkFURV9LRVkgPSBTeW1ib2wodHJ1ZSA/IFwiaXRlcmF0ZVwiIDogXCJcIik7XG52YXIgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCh0cnVlID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZuLl9pc0VmZmVjdCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVmZmVjdDIoZm4sIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgaWYgKGlzRWZmZWN0KGZuKSkge1xuICAgIGZuID0gZm4ucmF3O1xuICB9XG4gIGNvbnN0IGVmZmVjdDMgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5sYXp5KSB7XG4gICAgZWZmZWN0MygpO1xuICB9XG4gIHJldHVybiBlZmZlY3QzO1xufVxuZnVuY3Rpb24gc3RvcChlZmZlY3QzKSB7XG4gIGlmIChlZmZlY3QzLmFjdGl2ZSkge1xuICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5vblN0b3ApIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblN0b3AoKTtcbiAgICB9XG4gICAgZWZmZWN0My5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxudmFyIHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xuICBjb25zdCBlZmZlY3QzID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XG4gICAgaWYgKCFlZmZlY3QzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0MykpIHtcbiAgICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgICB0cnkge1xuICAgICAgICBlbmFibGVUcmFja2luZygpO1xuICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdDMpO1xuICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3QzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZWZmZWN0My5pZCA9IHVpZCsrO1xuICBlZmZlY3QzLmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XG4gIGVmZmVjdDMuX2lzRWZmZWN0ID0gdHJ1ZTtcbiAgZWZmZWN0My5hY3RpdmUgPSB0cnVlO1xuICBlZmZlY3QzLnJhdyA9IGZuO1xuICBlZmZlY3QzLmRlcHMgPSBbXTtcbiAgZWZmZWN0My5vcHRpb25zID0gb3B0aW9ucztcbiAgcmV0dXJuIGVmZmVjdDM7XG59XG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdDMpIHtcbiAgY29uc3Qge2RlcHN9ID0gZWZmZWN0MztcbiAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3QzKTtcbiAgICB9XG4gICAgZGVwcy5sZW5ndGggPSAwO1xuICB9XG59XG52YXIgc2hvdWxkVHJhY2sgPSB0cnVlO1xudmFyIHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IG5ldyBNYXAoKSk7XG4gIH1cbiAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gIGlmICghZGVwKSB7XG4gICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgU2V0KCkpO1xuICB9XG4gIGlmICghZGVwLmhhcyhhY3RpdmVFZmZlY3QpKSB7XG4gICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xuICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjaykge1xuICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XG4gICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0LFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZWZmZWN0cyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgYWRkMiA9IChlZmZlY3RzVG9BZGQpID0+IHtcbiAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XG4gICAgICBlZmZlY3RzVG9BZGQuZm9yRWFjaCgoZWZmZWN0MykgPT4ge1xuICAgICAgICBpZiAoZWZmZWN0MyAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdDMuYWxsb3dSZWN1cnNlKSB7XG4gICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0Myk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHNNYXAuZm9yRWFjaChhZGQyKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwibGVuZ3RoXCIgJiYgaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleTIpID0+IHtcbiAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPj0gbmV3VmFsdWUpIHtcbiAgICAgICAgYWRkMihkZXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgYWRkMihkZXBzTWFwLmdldChrZXkpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNJbnRlZ2VyS2V5KGtleSkpIHtcbiAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJ1biA9IChlZmZlY3QzKSA9PiB7XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5vblRyaWdnZXIpIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblRyaWdnZXIoe1xuICAgICAgICBlZmZlY3Q6IGVmZmVjdDMsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5LFxuICAgICAgICB0eXBlLFxuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgIG9sZFRhcmdldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3QzLm9wdGlvbnMuc2NoZWR1bGVyKSB7XG4gICAgICBlZmZlY3QzLm9wdGlvbnMuc2NoZWR1bGVyKGVmZmVjdDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QzKCk7XG4gICAgfVxuICB9O1xuICBlZmZlY3RzLmZvckVhY2gocnVuKTtcbn1cbnZhciBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG52YXIgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpKTtcbnZhciBnZXQyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcigpO1xudmFyIHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbnZhciByZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XG52YXIgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcbnZhciBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcbltcImluY2x1ZGVzXCIsIFwiaW5kZXhPZlwiLCBcImxhc3RJbmRleE9mXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICBjb25zdCBtZXRob2QgPSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdHJhY2soYXJyLCBcImdldFwiLCBpICsgXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseShhcnIsIGFyZ3MpO1xuICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcbn0pO1xuW1wicHVzaFwiLCBcInBvcFwiLCBcInNoaWZ0XCIsIFwidW5zaGlmdFwiLCBcInNwbGljZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XG4gIGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0Myh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgJiYgcmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5ID8gc2hhbGxvdyA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogc2hhbGxvdyA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoc2hhbGxvdykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIGNvbnN0IHNob3VsZFVud3JhcCA9ICF0YXJnZXRJc0FycmF5IHx8ICFpc0ludGVnZXJLZXkoa2V5KTtcbiAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZTIocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbnZhciBzZXQyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcigpO1xudmFyIHNoYWxsb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gc2V0Myh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIsIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbnZhciBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gIGdldDogZ2V0MixcbiAgc2V0OiBzZXQyLFxuICBkZWxldGVQcm9wZXJ0eSxcbiAgaGFzLFxuICBvd25LZXlzXG59O1xudmFyIHJlYWRvbmx5SGFuZGxlcnMgPSB7XG4gIGdldDogcmVhZG9ubHlHZXQsXG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSBleHRlbmQoe30sIG11dGFibGVIYW5kbGVycywge1xuICBnZXQ6IHNoYWxsb3dHZXQsXG4gIHNldDogc2hhbGxvd1NldFxufSk7XG52YXIgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcbiAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcbn0pO1xudmFyIHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlMih2YWx1ZSkgOiB2YWx1ZTtcbnZhciB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcbnZhciB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xudmFyIGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQkMSh0YXJnZXQsIGtleSwgaXNSZWFkb25seSA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xuICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCJdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gIH1cbiAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICBjb25zdCB7aGFzOiBoYXMyfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgfSBlbHNlIGlmIChoYXMyLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChyYXdLZXkpKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzJDEoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgfVxuICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7aGFzOiBoYXMyLCBnZXQ6IGdldDN9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7aGFzOiBoYXMyLCBnZXQ6IGdldDN9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzID8gZ2V0My5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICBpZiAoaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgY29uc3Qgb2xkVGFyZ2V0ID0gdHJ1ZSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICBpZiAoaGFkSXRlbXMpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiLCB2b2lkIDAsIHZvaWQgMCwgb2xkVGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xuICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBkb25lID8ge3ZhbHVlLCBkb25lfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgIGNvbnNvbGUud2FybihgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdGhpcztcbiAgfTtcbn1cbnZhciBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xuICB9LFxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgfSxcbiAgaGFzOiBoYXMkMSxcbiAgYWRkLFxuICBzZXQ6IHNldCQxLFxuICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICBjbGVhcixcbiAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgZmFsc2UpXG59O1xudmFyIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICB9LFxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgfSxcbiAgaGFzOiBoYXMkMSxcbiAgYWRkLFxuICBzZXQ6IHNldCQxLFxuICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICBjbGVhcixcbiAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcbn07XG52YXIgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSk7XG4gIH0sXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICB9LFxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgfSxcbiAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiKSxcbiAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG59O1xudmFyIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgfSxcbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gIH0sXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICB9LFxuICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKSxcbiAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxufTtcbnZhciBpdGVyYXRvck1ldGhvZHMgPSBbXCJrZXlzXCIsIFwidmFsdWVzXCIsIFwiZW50cmllc1wiLCBTeW1ib2wuaXRlcmF0b3JdO1xuaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xuICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XG4gIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBzaGFsbG93ID8gaXNSZWFkb25seSA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA6IGlzUmVhZG9ubHkgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmdldChoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gIH07XG59XG52YXIgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbnZhciBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG52YXIgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbnZhciBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcbiAgfVxufVxudmFyIHJlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzaGFsbG93UmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUyKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcIl9fdl9pc1JlYWRvbmx5XCJdKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seSAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICByZXR1cm4gb2JzZXJ2ZWQgJiYgdG9SYXcob2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdKSB8fCBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIEJvb2xlYW4ociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJG5leHRUaWNrLmpzXG5tYWdpYyhcIm5leHRUaWNrXCIsICgpID0+IG5leHRUaWNrKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kZGlzcGF0Y2guanNcbm1hZ2ljKFwiZGlzcGF0Y2hcIiwgKGVsKSA9PiBkaXNwYXRjaC5iaW5kKGRpc3BhdGNoLCBlbCkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyR3YXRjaC5qc1xubWFnaWMoXCJ3YXRjaFwiLCAoZWwsIHtldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMiwgZWZmZWN0OiBlZmZlY3QzfSkgPT4gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGtleSk7XG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuICBsZXQgb2xkVmFsdWU7XG4gIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QzKCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmaXJzdFRpbWUpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xuICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHNjb3BlKGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJvb3QuanNcbm1hZ2ljKFwicm9vdFwiLCAoZWwpID0+IGNsb3Nlc3RSb290KGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJlZnMuanNcbm1hZ2ljKFwicmVmc1wiLCAoZWwpID0+IHtcbiAgaWYgKGVsLl94X3JlZnNfcHJveHkpXG4gICAgcmV0dXJuIGVsLl94X3JlZnNfcHJveHk7XG4gIGVsLl94X3JlZnNfcHJveHkgPSBtZXJnZVByb3hpZXMoZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkpO1xuICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbn0pO1xuZnVuY3Rpb24gZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkge1xuICBsZXQgcmVmT2JqZWN0cyA9IFtdO1xuICBsZXQgY3VycmVudEVsID0gZWw7XG4gIHdoaWxlIChjdXJyZW50RWwpIHtcbiAgICBpZiAoY3VycmVudEVsLl94X3JlZnMpXG4gICAgICByZWZPYmplY3RzLnB1c2goY3VycmVudEVsLl94X3JlZnMpO1xuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiByZWZPYmplY3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaWRzLmpzXG52YXIgZ2xvYmFsSWRNZW1vID0ge307XG5mdW5jdGlvbiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSkge1xuICBpZiAoIWdsb2JhbElkTWVtb1tuYW1lXSlcbiAgICBnbG9iYWxJZE1lbW9bbmFtZV0gPSAwO1xuICByZXR1cm4gKytnbG9iYWxJZE1lbW9bbmFtZV07XG59XG5mdW5jdGlvbiBjbG9zZXN0SWRSb290KGVsLCBuYW1lKSB7XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbCwgKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC5feF9pZHMgJiYgZWxlbWVudC5feF9pZHNbbmFtZV0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRJZFJvb3QoZWwsIG5hbWUpIHtcbiAgaWYgKCFlbC5feF9pZHMpXG4gICAgZWwuX3hfaWRzID0ge307XG4gIGlmICghZWwuX3hfaWRzW25hbWVdKVxuICAgIGVsLl94X2lkc1tuYW1lXSA9IGZpbmRBbmRJbmNyZW1lbnRJZChuYW1lKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kaWQuanNcbm1hZ2ljKFwiaWRcIiwgKGVsKSA9PiAobmFtZSwga2V5ID0gbnVsbCkgPT4ge1xuICBsZXQgcm9vdCA9IGNsb3Nlc3RJZFJvb3QoZWwsIG5hbWUpO1xuICBsZXQgaWQgPSByb290ID8gcm9vdC5feF9pZHNbbmFtZV0gOiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSk7XG4gIHJldHVybiBrZXkgPyBgJHtuYW1lfS0ke2lkfS0ke2tleX1gIDogYCR7bmFtZX0tJHtpZH1gO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGVsLmpzXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzL2luZGV4LmpzXG53YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKFwiRm9jdXNcIiwgXCJmb2N1c1wiLCBcImZvY3VzXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5NYWdpYyhcIlBlcnNpc3RcIiwgXCJwZXJzaXN0XCIsIFwicGVyc2lzdFwiKTtcbmZ1bmN0aW9uIHdhcm5NaXNzaW5nUGx1Z2luTWFnaWMobmFtZSwgbWFnaWNOYW1lLCBzbHVnKSB7XG4gIG1hZ2ljKG1hZ2ljTmFtZSwgKGVsKSA9PiB3YXJuKGBZb3UgY2FuJ3QgdXNlIFskJHtkaXJlY3RpdmVOYW1lfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1tb2RlbGFibGUuanNcbmRpcmVjdGl2ZShcIm1vZGVsYWJsZVwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjJ9KSA9PiB7XG4gIGxldCBmdW5jID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGxldCBpbm5lckdldCA9ICgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZ1bmMoKGkpID0+IHJlc3VsdCA9IGkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGxldCBldmFsdWF0ZUlubmVyU2V0ID0gZXZhbHVhdGVMYXRlcjIoYCR7ZXhwcmVzc2lvbn0gPSBfX3BsYWNlaG9sZGVyYCk7XG4gIGxldCBpbm5lclNldCA9ICh2YWwpID0+IGV2YWx1YXRlSW5uZXJTZXQoKCkgPT4ge1xuICB9LCB7c2NvcGU6IHtfX3BsYWNlaG9sZGVyOiB2YWx9fSk7XG4gIGxldCBpbml0aWFsVmFsdWUgPSBpbm5lckdldCgpO1xuICBpbm5lclNldChpbml0aWFsVmFsdWUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaWYgKCFlbC5feF9tb2RlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVyc1tcImRlZmF1bHRcIl0oKTtcbiAgICBsZXQgb3V0ZXJHZXQgPSBlbC5feF9tb2RlbC5nZXQ7XG4gICAgbGV0IG91dGVyU2V0ID0gZWwuX3hfbW9kZWwuc2V0O1xuICAgIGVmZmVjdDMoKCkgPT4gaW5uZXJTZXQob3V0ZXJHZXQoKSkpO1xuICAgIGVmZmVjdDMoKCkgPT4gb3V0ZXJTZXQoaW5uZXJHZXQoKSkpO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRlbGVwb3J0LmpzXG5kaXJlY3RpdmUoXCJ0ZWxlcG9ydFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2NsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInRlbXBsYXRlXCIpXG4gICAgd2FybihcIngtdGVsZXBvcnQgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIDx0ZW1wbGF0ZT4gdGFnXCIsIGVsKTtcbiAgbGV0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZXhwcmVzc2lvbik7XG4gIGlmICghdGFyZ2V0KVxuICAgIHdhcm4oYENhbm5vdCBmaW5kIHgtdGVsZXBvcnQgZWxlbWVudCBmb3Igc2VsZWN0b3I6IFwiJHtleHByZXNzaW9ufVwiYCk7XG4gIGxldCBjbG9uZTIgPSBlbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgZWwuX3hfdGVsZXBvcnQgPSBjbG9uZTI7XG4gIGNsb25lMi5feF90ZWxlcG9ydEJhY2sgPSBlbDtcbiAgaWYgKGVsLl94X2ZvcndhcmRFdmVudHMpIHtcbiAgICBlbC5feF9mb3J3YXJkRXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgY2xvbmUyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICBtdXRhdGVEb20oKCkgPT4ge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChjbG9uZTIpO1xuICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgY2xvbmUyLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBjbGVhbnVwMigoKSA9PiBjbG9uZTIucmVtb3ZlKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWdub3JlLmpzXG52YXIgaGFuZGxlciA9ICgpID0+IHtcbn07XG5oYW5kbGVyLmlubGluZSA9IChlbCwge21vZGlmaWVyc30sIHtjbGVhbnVwOiBjbGVhbnVwMn0pID0+IHtcbiAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlIDogZWwuX3hfaWdub3JlID0gdHJ1ZTtcbiAgY2xlYW51cDIoKCkgPT4ge1xuICAgIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBkZWxldGUgZWwuX3hfaWdub3JlU2VsZiA6IGRlbGV0ZSBlbC5feF9pZ25vcmU7XG4gIH0pO1xufTtcbmRpcmVjdGl2ZShcImlnbm9yZVwiLCBoYW5kbGVyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1lZmZlY3QuanNcbmRpcmVjdGl2ZShcImVmZmVjdFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0M30pID0+IGVmZmVjdDMoZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uLmpzXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIG1vZGlmaWVycywgY2FsbGJhY2spIHtcbiAgbGV0IGxpc3RlbmVyVGFyZ2V0ID0gZWw7XG4gIGxldCBoYW5kbGVyMyA9IChlKSA9PiBjYWxsYmFjayhlKTtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgbGV0IHdyYXBIYW5kbGVyID0gKGNhbGxiYWNrMiwgd3JhcHBlcikgPT4gKGUpID0+IHdyYXBwZXIoY2FsbGJhY2syLCBlKTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvdFwiKSlcbiAgICBldmVudCA9IGRvdFN5bnRheChldmVudCk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJjYW1lbFwiKSlcbiAgICBldmVudCA9IGNhbWVsQ2FzZTIoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwicGFzc2l2ZVwiKSlcbiAgICBvcHRpb25zLnBhc3NpdmUgPSB0cnVlO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FwdHVyZVwiKSlcbiAgICBvcHRpb25zLmNhcHR1cmUgPSB0cnVlO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwid2luZG93XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZG9jdW1lbnRcIikpXG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInByZXZlbnRcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzdG9wXCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikpXG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGUudGFyZ2V0ID09PSBlbCAmJiBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXdheVwiKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRzaWRlXCIpKSB7XG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGUudGFyZ2V0LmlzQ29ubmVjdGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZWwuX3hfaXNTaG93biA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xuICAgICAgaWYgKGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5leHQoZSk7XG4gIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZGVib3VuY2VcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwiZGVib3VuY2VcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSBkZWJvdW5jZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInRocm90dGxlXCIpKSB7XG4gICAgbGV0IG5leHRNb2RpZmllciA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihcInRocm90dGxlXCIpICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIjtcbiAgICBsZXQgd2FpdCA9IGlzTnVtZXJpYyhuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgPyBOdW1iZXIobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pIDogMjUwO1xuICAgIGhhbmRsZXIzID0gdGhyb3R0bGUoaGFuZGxlcjMsIHdhaXQpO1xuICB9XG4gIGxpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gIH07XG59XG5mdW5jdGlvbiBkb3RTeW50YXgoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8tL2csIFwiLlwiKTtcbn1cbmZ1bmN0aW9uIGNhbWVsQ2FzZTIoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc051bWVyaWMoc3ViamVjdCkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xufVxuZnVuY3Rpb24ga2ViYWJDYXNlMihzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikucmVwbGFjZSgvW19cXHNdLywgXCItXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpc0tleUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBbXCJrZXlkb3duXCIsIFwia2V5dXBcIl0uaW5jbHVkZXMoZXZlbnQpO1xufVxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpIHtcbiAgbGV0IGtleU1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGkpID0+IHtcbiAgICByZXR1cm4gIVtcIndpbmRvd1wiLCBcImRvY3VtZW50XCIsIFwicHJldmVudFwiLCBcInN0b3BcIiwgXCJvbmNlXCJdLmluY2x1ZGVzKGkpO1xuICB9KTtcbiAgaWYgKGtleU1vZGlmaWVycy5pbmNsdWRlcyhcImRlYm91bmNlXCIpKSB7XG4gICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZihcImRlYm91bmNlXCIpO1xuICAgIGtleU1vZGlmaWVycy5zcGxpY2UoZGVib3VuY2VJbmRleCwgaXNOdW1lcmljKChrZXlNb2RpZmllcnNbZGVib3VuY2VJbmRleCArIDFdIHx8IFwiaW52YWxpZC13YWl0XCIpLnNwbGl0KFwibXNcIilbMF0pID8gMiA6IDEpO1xuICB9XG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDEgJiYga2V5VG9Nb2RpZmllcnMoZS5rZXkpLmluY2x1ZGVzKGtleU1vZGlmaWVyc1swXSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBzeXN0ZW1LZXlNb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCIsIFwiY21kXCIsIFwic3VwZXJcIl07XG4gIGNvbnN0IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzID0gc3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IGtleU1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKChpKSA9PiAhc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuaW5jbHVkZXMoaSkpO1xuICBpZiAoc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycyA9IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcigobW9kaWZpZXIpID0+IHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCJjbWRcIiB8fCBtb2RpZmllciA9PT0gXCJzdXBlclwiKVxuICAgICAgICBtb2RpZmllciA9IFwibWV0YVwiO1xuICAgICAgcmV0dXJuIGVbYCR7bW9kaWZpZXJ9S2V5YF07XG4gICAgfSk7XG4gICAgaWYgKGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycy5sZW5ndGggPT09IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgaWYgKGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24ga2V5VG9Nb2RpZmllcnMoa2V5KSB7XG4gIGlmICgha2V5KVxuICAgIHJldHVybiBbXTtcbiAga2V5ID0ga2ViYWJDYXNlMihrZXkpO1xuICBsZXQgbW9kaWZpZXJUb0tleU1hcCA9IHtcbiAgICBjdHJsOiBcImNvbnRyb2xcIixcbiAgICBzbGFzaDogXCIvXCIsXG4gICAgc3BhY2U6IFwiLVwiLFxuICAgIHNwYWNlYmFyOiBcIi1cIixcbiAgICBjbWQ6IFwibWV0YVwiLFxuICAgIGVzYzogXCJlc2NhcGVcIixcbiAgICB1cDogXCJhcnJvdy11cFwiLFxuICAgIGRvd246IFwiYXJyb3ctZG93blwiLFxuICAgIGxlZnQ6IFwiYXJyb3ctbGVmdFwiLFxuICAgIHJpZ2h0OiBcImFycm93LXJpZ2h0XCIsXG4gICAgcGVyaW9kOiBcIi5cIixcbiAgICBlcXVhbDogXCI9XCJcbiAgfTtcbiAgbW9kaWZpZXJUb0tleU1hcFtrZXldID0ga2V5O1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kaWZpZXJUb0tleU1hcCkubWFwKChtb2RpZmllcikgPT4ge1xuICAgIGlmIChtb2RpZmllclRvS2V5TWFwW21vZGlmaWVyXSA9PT0ga2V5KVxuICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICB9KS5maWx0ZXIoKG1vZGlmaWVyKSA9PiBtb2RpZmllcik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtbW9kZWwuanNcbmRpcmVjdGl2ZShcIm1vZGVsXCIsIChlbCwge21vZGlmaWVycywgZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb259ID0gcmlnaHRTaWRlT2ZFeHByZXNzaW9uKCRldmVudCwgJHtleHByZXNzaW9ufSlgO1xuICBsZXQgZXZhbHVhdGVBc3NpZ25tZW50ID0gZXZhbHVhdGVMYXRlcihlbCwgYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgfHwgW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJsYXp5XCIpID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIjtcbiAgbGV0IGFzc2lnbWVudEZ1bmN0aW9uID0gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbik7XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCBldmVudCwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlQXNzaWdubWVudCgoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7XG4gICAgICAkZXZlbnQ6IGUsXG4gICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGFzc2lnbWVudEZ1bmN0aW9uXG4gICAgfX0pO1xuICB9KTtcbiAgaWYgKCFlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVycylcbiAgICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVycyA9IHt9O1xuICBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVyc1tcImRlZmF1bHRcIl0gPSByZW1vdmVMaXN0ZW5lcjtcbiAgY2xlYW51cDIoKCkgPT4gZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdKCkpO1xuICBsZXQgZXZhbHVhdGVTZXRNb2RlbCA9IGV2YWx1YXRlTGF0ZXIoZWwsIGAke2V4cHJlc3Npb259ID0gX19wbGFjZWhvbGRlcmApO1xuICBlbC5feF9tb2RlbCA9IHtcbiAgICBnZXQoKSB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZXZhbHVhdGVTZXRNb2RlbCgoKSA9PiB7XG4gICAgICB9LCB7c2NvcGU6IHtfX3BsYWNlaG9sZGVyOiB2YWx1ZX19KTtcbiAgICB9XG4gIH07XG4gIGVsLl94X2ZvcmNlTW9kZWxVcGRhdGUgPSAoKSA9PiB7XG4gICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpXG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIHdpbmRvdy5mcm9tTW9kZWwgPSB0cnVlO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IGJpbmQoZWwsIFwidmFsdWVcIiwgdmFsdWUpKTtcbiAgICAgIGRlbGV0ZSB3aW5kb3cuZnJvbU1vZGVsO1xuICAgIH0pO1xuICB9O1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidW5pbnRydXNpdmVcIikgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKSlcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF9mb3JjZU1vZGVsVXBkYXRlKCk7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBnZW5lcmF0ZUFzc2lnbm1lbnRGdW5jdGlvbihlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uKSB7XG4gIGlmIChlbC50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoXCJuYW1lXCIpKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGV4cHJlc3Npb24pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAoZXZlbnQsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgIHJldHVybiBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQgJiYgZXZlbnQuZGV0YWlsICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gc2FmZVBhcnNlTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSkgOiBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkID8gY3VycmVudFZhbHVlLmNvbmNhdChbbmV3VmFsdWVdKSA6IGN1cnJlbnRWYWx1ZS5maWx0ZXIoKGVsMikgPT4gIWNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMihlbDIsIG5ld1ZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiAmJiBlbC5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgIGxldCByYXdWYWx1ZSA9IG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgICByZXR1cm4gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKTtcbiAgICAgICAgfSkgOiBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmF3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKFwidHJpbVwiKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSB7XG4gIGxldCBudW1iZXIgPSByYXdWYWx1ZSA/IHBhcnNlRmxvYXQocmF3VmFsdWUpIDogbnVsbDtcbiAgcmV0dXJuIGlzTnVtZXJpYzIobnVtYmVyKSA/IG51bWJlciA6IHJhd1ZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUyKHZhbHVlQSwgdmFsdWVCKSB7XG4gIHJldHVybiB2YWx1ZUEgPT0gdmFsdWVCO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljMihzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtY2xvYWsuanNcbmRpcmVjdGl2ZShcImNsb2FrXCIsIChlbCkgPT4gcXVldWVNaWNyb3Rhc2soKCkgPT4gbXV0YXRlRG9tKCgpID0+IGVsLnJlbW92ZUF0dHJpYnV0ZShwcmVmaXgoXCJjbG9ha1wiKSkpKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaW5pdC5qc1xuYWRkSW5pdFNlbGVjdG9yKCgpID0+IGBbJHtwcmVmaXgoXCJpbml0XCIpfV1gKTtcbmRpcmVjdGl2ZShcImluaXRcIiwgc2tpcER1cmluZ0Nsb25lKChlbCwge2V4cHJlc3Npb259LCB7ZXZhbHVhdGU6IGV2YWx1YXRlMn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICEhZXhwcmVzc2lvbi50cmltKCkgJiYgZXZhbHVhdGUyKGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlMihleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcbmRpcmVjdGl2ZShcInRleHRcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1odG1sLmpzXG5kaXJlY3RpdmUoXCJodG1sXCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMn0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICAgICAgZWwuX3hfaWdub3JlU2VsZiA9IHRydWU7XG4gICAgICAgIGluaXRUcmVlKGVsKTtcbiAgICAgICAgZGVsZXRlIGVsLl94X2lnbm9yZVNlbGY7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1iaW5kLmpzXG5tYXBBdHRyaWJ1dGVzKHN0YXJ0aW5nV2l0aChcIjpcIiwgaW50byhwcmVmaXgoXCJiaW5kOlwiKSkpKTtcbmRpcmVjdGl2ZShcImJpbmRcIiwgKGVsLCB7dmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgb3JpZ2luYWx9LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgbGV0IGJpbmRpbmdQcm92aWRlcnMgPSB7fTtcbiAgICBpbmplY3RCaW5kaW5nUHJvdmlkZXJzKGJpbmRpbmdQcm92aWRlcnMpO1xuICAgIGxldCBnZXRCaW5kaW5ncyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICAgIGdldEJpbmRpbmdzKChiaW5kaW5ncykgPT4ge1xuICAgICAgYXBwbHlCaW5kaW5nc09iamVjdChlbCwgYmluZGluZ3MsIG9yaWdpbmFsKTtcbiAgICB9LCB7c2NvcGU6IGJpbmRpbmdQcm92aWRlcnN9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcImtleVwiKVxuICAgIHJldHVybiBzdG9yZUtleUZvclhGb3IoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKChyZXN1bHQpID0+IHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgdHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpIHtcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgfVxuICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCB2YWx1ZSwgcmVzdWx0LCBtb2RpZmllcnMpKTtcbiAgfSkpO1xufSk7XG5mdW5jdGlvbiBzdG9yZUtleUZvclhGb3IoZWwsIGV4cHJlc3Npb24pIHtcbiAgZWwuX3hfa2V5RXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZGF0YS5qc1xuYWRkUm9vdFNlbGVjdG9yKCgpID0+IGBbJHtwcmVmaXgoXCJkYXRhXCIpfV1gKTtcbmRpcmVjdGl2ZShcImRhdGFcIiwgc2tpcER1cmluZ0Nsb25lKChlbCwge2V4cHJlc3Npb259LCB7Y2xlYW51cDogY2xlYW51cDJ9KSA9PiB7XG4gIGV4cHJlc3Npb24gPSBleHByZXNzaW9uID09PSBcIlwiID8gXCJ7fVwiIDogZXhwcmVzc2lvbjtcbiAgbGV0IG1hZ2ljQ29udGV4dCA9IHt9O1xuICBpbmplY3RNYWdpY3MobWFnaWNDb250ZXh0LCBlbCk7XG4gIGxldCBkYXRhUHJvdmlkZXJDb250ZXh0ID0ge307XG4gIGluamVjdERhdGFQcm92aWRlcnMoZGF0YVByb3ZpZGVyQ29udGV4dCwgbWFnaWNDb250ZXh0KTtcbiAgbGV0IGRhdGEyID0gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIHtzY29wZTogZGF0YVByb3ZpZGVyQ29udGV4dH0pO1xuICBpZiAoZGF0YTIgPT09IHZvaWQgMClcbiAgICBkYXRhMiA9IHt9O1xuICBpbmplY3RNYWdpY3MoZGF0YTIsIGVsKTtcbiAgbGV0IHJlYWN0aXZlRGF0YSA9IHJlYWN0aXZlKGRhdGEyKTtcbiAgaW5pdEludGVyY2VwdG9ycyhyZWFjdGl2ZURhdGEpO1xuICBsZXQgdW5kbyA9IGFkZFNjb3BlVG9Ob2RlKGVsLCByZWFjdGl2ZURhdGEpO1xuICByZWFjdGl2ZURhdGFbXCJpbml0XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJpbml0XCJdKTtcbiAgY2xlYW51cDIoKCkgPT4ge1xuICAgIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0gJiYgZXZhbHVhdGUoZWwsIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0pO1xuICAgIHVuZG8oKTtcbiAgfSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtc2hvdy5qc1xuZGlyZWN0aXZlKFwic2hvd1wiLCAoZWwsIHttb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGlmICghZWwuX3hfZG9IaWRlKVxuICAgIGVsLl94X2RvSGlkZSA9ICgpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIiwgbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1wb3J0YW50XCIpID8gXCJpbXBvcnRhbnRcIiA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9O1xuICBpZiAoIWVsLl94X2RvU2hvdylcbiAgICBlbC5feF9kb1Nob3cgPSAoKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAxICYmIGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICBsZXQgaGlkZSA9ICgpID0+IHtcbiAgICBlbC5feF9kb0hpZGUoKTtcbiAgICBlbC5feF9pc1Nob3duID0gZmFsc2U7XG4gIH07XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGVsLl94X2RvU2hvdygpO1xuICAgIGVsLl94X2lzU2hvd24gPSB0cnVlO1xuICB9O1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBzZXRUaW1lb3V0KHNob3cpO1xuICBsZXQgdG9nZ2xlID0gb25jZSgodmFsdWUpID0+IHZhbHVlID8gc2hvdygpIDogaGlkZSgpLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZWwuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyhlbCwgdmFsdWUsIHNob3csIGhpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IG9sZFZhbHVlO1xuICBsZXQgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFmaXJzdFRpbWUgJiYgdmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpbW1lZGlhdGVcIikpXG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgdG9nZ2xlKHZhbHVlKTtcbiAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1mb3IuanNcbmRpcmVjdGl2ZShcImZvclwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cDogY2xlYW51cDJ9KSA9PiB7XG4gIGxldCBpdGVyYXRvck5hbWVzID0gcGFyc2VGb3JFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGVJdGVtcyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGl0ZXJhdG9yTmFtZXMuaXRlbXMpO1xuICBsZXQgZXZhbHVhdGVLZXkgPSBldmFsdWF0ZUxhdGVyKGVsLCBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIik7XG4gIGVsLl94X3ByZXZLZXlzID0gW107XG4gIGVsLl94X2xvb2t1cCA9IHt9O1xuICBlZmZlY3QzKCgpID0+IGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSk7XG4gIGNsZWFudXAyKCgpID0+IHtcbiAgICBPYmplY3QudmFsdWVzKGVsLl94X2xvb2t1cCkuZm9yRWFjaCgoZWwyKSA9PiBlbDIucmVtb3ZlKCkpO1xuICAgIGRlbGV0ZSBlbC5feF9wcmV2S2V5cztcbiAgICBkZWxldGUgZWwuX3hfbG9va3VwO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gbG9vcChlbCwgaXRlcmF0b3JOYW1lcywgZXZhbHVhdGVJdGVtcywgZXZhbHVhdGVLZXkpIHtcbiAgbGV0IGlzT2JqZWN0MiA9IChpKSA9PiB0eXBlb2YgaSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpKTtcbiAgbGV0IHRlbXBsYXRlRWwgPSBlbDtcbiAgZXZhbHVhdGVJdGVtcygoaXRlbXMpID0+IHtcbiAgICBpZiAoaXNOdW1lcmljMyhpdGVtcykgJiYgaXRlbXMgPj0gMCkge1xuICAgICAgaXRlbXMgPSBBcnJheS5mcm9tKEFycmF5KGl0ZW1zKS5rZXlzKCksIChpKSA9PiBpICsgMSk7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKVxuICAgICAgaXRlbXMgPSBbXTtcbiAgICBsZXQgbG9va3VwID0gZWwuX3hfbG9va3VwO1xuICAgIGxldCBwcmV2S2V5cyA9IGVsLl94X3ByZXZLZXlzO1xuICAgIGxldCBzY29wZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGlmIChpc09iamVjdDIoaXRlbXMpKSB7XG4gICAgICBpdGVtcyA9IE9iamVjdC5lbnRyaWVzKGl0ZW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsZXQgc2NvcGUyID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgdmFsdWUsIGtleSwgaXRlbXMpO1xuICAgICAgICBldmFsdWF0ZUtleSgodmFsdWUyKSA9PiBrZXlzLnB1c2godmFsdWUyKSwge3Njb3BlOiB7aW5kZXg6IGtleSwgLi4uc2NvcGUyfX0pO1xuICAgICAgICBzY29wZXMucHVzaChzY29wZTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjb3BlMiA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW1zW2ldLCBpLCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZSkgPT4ga2V5cy5wdXNoKHZhbHVlKSwge3Njb3BlOiB7aW5kZXg6IGksIC4uLnNjb3BlMn19KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGlmICghIWxvb2t1cFtrZXldLl94X2VmZmVjdHMpIHtcbiAgICAgICAgbG9va3VwW2tleV0uX3hfZWZmZWN0cy5mb3JFYWNoKGRlcXVldWVKb2IpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0ucmVtb3ZlKCk7XG4gICAgICBsb29rdXBba2V5XSA9IG51bGw7XG4gICAgICBkZWxldGUgbG9va3VwW2tleV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBba2V5SW5TcG90LCBrZXlGb3JTcG90XSA9IG1vdmVzW2ldO1xuICAgICAgbGV0IGVsSW5TcG90ID0gbG9va3VwW2tleUluU3BvdF07XG4gICAgICBsZXQgZWxGb3JTcG90ID0gbG9va3VwW2tleUZvclNwb3RdO1xuICAgICAgbGV0IG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbEZvclNwb3QuYWZ0ZXIobWFya2VyKTtcbiAgICAgICAgZWxJblNwb3QuYWZ0ZXIoZWxGb3JTcG90KTtcbiAgICAgICAgZWxGb3JTcG90Ll94X2N1cnJlbnRJZkVsICYmIGVsRm9yU3BvdC5hZnRlcihlbEZvclNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIuYmVmb3JlKGVsSW5TcG90KTtcbiAgICAgICAgZWxJblNwb3QuX3hfY3VycmVudElmRWwgJiYgZWxJblNwb3QuYWZ0ZXIoZWxJblNwb3QuX3hfY3VycmVudElmRWwpO1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hTY29wZShlbEZvclNwb3QsIHNjb3Blc1trZXlzLmluZGV4T2Yoa2V5Rm9yU3BvdCldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2xhc3RLZXkyLCBpbmRleF0gPSBhZGRzW2ldO1xuICAgICAgbGV0IGxhc3RFbCA9IGxhc3RLZXkyID09PSBcInRlbXBsYXRlXCIgPyB0ZW1wbGF0ZUVsIDogbG9va3VwW2xhc3RLZXkyXTtcbiAgICAgIGlmIChsYXN0RWwuX3hfY3VycmVudElmRWwpXG4gICAgICAgIGxhc3RFbCA9IGxhc3RFbC5feF9jdXJyZW50SWZFbDtcbiAgICAgIGxldCBzY29wZTIgPSBzY29wZXNbaW5kZXhdO1xuICAgICAgbGV0IGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgbGV0IGNsb25lMiA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGVFbC5jb250ZW50LCB0cnVlKS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwgcmVhY3RpdmUoc2NvcGUyKSwgdGVtcGxhdGVFbCk7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBsYXN0RWwuYWZ0ZXIoY2xvbmUyKTtcbiAgICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd2FybihcIngtZm9yIGtleSBjYW5ub3QgYmUgYW4gb2JqZWN0LCBpdCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGludGVnZXJcIiwgdGVtcGxhdGVFbCk7XG4gICAgICB9XG4gICAgICBsb29rdXBba2V5XSA9IGNsb25lMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVmcmVzaFNjb3BlKGxvb2t1cFtzYW1lc1tpXV0sIHNjb3Blc1trZXlzLmluZGV4T2Yoc2FtZXNbaV0pXSk7XG4gICAgfVxuICAgIHRlbXBsYXRlRWwuX3hfcHJldktleXMgPSBrZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGxldCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICBsZXQgc3RyaXBQYXJlbnNSRSA9IC9eXFxzKlxcKHxcXClcXHMqJC9nO1xuICBsZXQgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgbGV0IGluTWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpXG4gICAgcmV0dXJuO1xuICBsZXQgcmVzID0ge307XG4gIHJlcy5pdGVtcyA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBsZXQgaXRlbSA9IGluTWF0Y2hbMV0ucmVwbGFjZShzdHJpcFBhcmVuc1JFLCBcIlwiKS50cmltKCk7XG4gIGxldCBpdGVyYXRvck1hdGNoID0gaXRlbS5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuaXRlbSA9IGl0ZW0ucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKS50cmltKCk7XG4gICAgcmVzLmluZGV4ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5jb2xsZWN0aW9uID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5pdGVtID0gaXRlbTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zKSB7XG4gIGxldCBzY29wZVZhcmlhYmxlcyA9IHt9O1xuICBpZiAoL15cXFsuKlxcXSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiBBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgbGV0IG5hbWVzID0gaXRlcmF0b3JOYW1lcy5pdGVtLnJlcGxhY2UoXCJbXCIsIFwiXCIpLnJlcGxhY2UoXCJdXCIsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBzY29wZVZhcmlhYmxlc1tuYW1lXSA9IGl0ZW1baV07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoL15cXHsuKlxcfSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwie1wiLCBcIlwiKS5yZXBsYWNlKFwifVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW25hbWVdO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaXRlbV0gPSBpdGVtO1xuICB9XG4gIGlmIChpdGVyYXRvck5hbWVzLmluZGV4KVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaW5kZXhdID0gaW5kZXg7XG4gIGlmIChpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb24pXG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uXSA9IGl0ZW1zO1xuICByZXR1cm4gc2NvcGVWYXJpYWJsZXM7XG59XG5mdW5jdGlvbiBpc051bWVyaWMzKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1yZWYuanNcbmZ1bmN0aW9uIGhhbmRsZXIyKCkge1xufVxuaGFuZGxlcjIuaW5saW5lID0gKGVsLCB7ZXhwcmVzc2lvbn0sIHtjbGVhbnVwOiBjbGVhbnVwMn0pID0+IHtcbiAgbGV0IHJvb3QgPSBjbG9zZXN0Um9vdChlbCk7XG4gIGlmICghcm9vdC5feF9yZWZzKVxuICAgIHJvb3QuX3hfcmVmcyA9IHt9O1xuICByb290Ll94X3JlZnNbZXhwcmVzc2lvbl0gPSBlbDtcbiAgY2xlYW51cDIoKCkgPT4gZGVsZXRlIHJvb3QuX3hfcmVmc1tleHByZXNzaW9uXSk7XG59O1xuZGlyZWN0aXZlKFwicmVmXCIsIGhhbmRsZXIyKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pZi5qc1xuZGlyZWN0aXZlKFwiaWZcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9jdXJyZW50SWZFbClcbiAgICAgIHJldHVybiBlbC5feF9jdXJyZW50SWZFbDtcbiAgICBsZXQgY2xvbmUyID0gZWwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBlbC5hZnRlcihjbG9uZTIpO1xuICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICB9KTtcbiAgICBlbC5feF9jdXJyZW50SWZFbCA9IGNsb25lMjtcbiAgICBlbC5feF91bmRvSWYgPSAoKSA9PiB7XG4gICAgICB3YWxrKGNsb25lMiwgKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCEhbm9kZS5feF9lZmZlY3RzKSB7XG4gICAgICAgICAgbm9kZS5feF9lZmZlY3RzLmZvckVhY2goZGVxdWV1ZUpvYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lMjtcbiAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFlbC5feF91bmRvSWYpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfdW5kb0lmKCk7XG4gICAgZGVsZXRlIGVsLl94X3VuZG9JZjtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPyBzaG93KCkgOiBoaWRlKCk7XG4gIH0pKTtcbiAgY2xlYW51cDIoKCkgPT4gZWwuX3hfdW5kb0lmICYmIGVsLl94X3VuZG9JZigpKTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlkLmpzXG5kaXJlY3RpdmUoXCJpZFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2V2YWx1YXRlOiBldmFsdWF0ZTJ9KSA9PiB7XG4gIGxldCBuYW1lcyA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gc2V0SWRSb290KGVsLCBuYW1lKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1vbi5qc1xubWFwQXR0cmlidXRlcyhzdGFydGluZ1dpdGgoXCJAXCIsIGludG8ocHJlZml4KFwib246XCIpKSkpO1xuZGlyZWN0aXZlKFwib25cIiwgc2tpcER1cmluZ0Nsb25lKChlbCwge3ZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb259LCB7Y2xlYW51cDogY2xlYW51cDJ9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIikge1xuICAgIGlmICghZWwuX3hfZm9yd2FyZEV2ZW50cylcbiAgICAgIGVsLl94X2ZvcndhcmRFdmVudHMgPSBbXTtcbiAgICBpZiAoIWVsLl94X2ZvcndhcmRFdmVudHMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5wdXNoKHZhbHVlKTtcbiAgfVxuICBsZXQgcmVtb3ZlTGlzdGVuZXIgPSBvbihlbCwgdmFsdWUsIG1vZGlmaWVycywgKGUpID0+IHtcbiAgICBldmFsdWF0ZTIoKCkgPT4ge1xuICAgIH0sIHtzY29wZTogeyRldmVudDogZX0sIHBhcmFtczogW2VdfSk7XG4gIH0pO1xuICBjbGVhbnVwMigoKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbn0pKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMvaW5kZXguanNcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiQ29sbGFwc2VcIiwgXCJjb2xsYXBzZVwiLCBcImNvbGxhcHNlXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJJbnRlcnNlY3RcIiwgXCJpbnRlcnNlY3RcIiwgXCJpbnRlcnNlY3RcIik7XG53YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShcIkZvY3VzXCIsIFwidHJhcFwiLCBcImZvY3VzXCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJNYXNrXCIsIFwibWFza1wiLCBcIm1hc2tcIik7XG5mdW5jdGlvbiB3YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmVOYW1lMiwgc2x1Zykge1xuICBkaXJlY3RpdmUoZGlyZWN0aXZlTmFtZTIsIChlbCkgPT4gd2FybihgWW91IGNhbid0IHVzZSBbeC0ke2RpcmVjdGl2ZU5hbWUyfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2luZGV4LmpzXG5hbHBpbmVfZGVmYXVsdC5zZXRFdmFsdWF0b3Iobm9ybWFsRXZhbHVhdG9yKTtcbmFscGluZV9kZWZhdWx0LnNldFJlYWN0aXZpdHlFbmdpbmUoe3JlYWN0aXZlOiByZWFjdGl2ZTIsIGVmZmVjdDogZWZmZWN0MiwgcmVsZWFzZTogc3RvcCwgcmF3OiB0b1Jhd30pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiIsICJjb25zdCBEQl9WRVJTSU9OID0gMztcbmNvbnN0IHN0b3JhZ2UgPSBicm93c2VyLnN0b3JhZ2UubG9jYWw7XG5leHBvcnQgY29uc3QgUkVDT01NRU5ERURfUkVMQVlTID0gW1xuICAgIG5ldyBVUkwoJ3dzczovL3JlbGF5LmRhbXVzLmlvJyksXG4gICAgbmV3IFVSTCgnd3NzOi8vcmVsYXkuc25vcnQuc29jaWFsJyksXG4gICAgbmV3IFVSTCgnd3NzOi8vbm9zLmxvbCcpLFxuICAgIG5ldyBVUkwoJ3dzczovL2JyYi5pbycpLFxuICAgIG5ldyBVUkwoJ3dzczovL25vc3RyLm9yYW5nZXBpbGwuZGV2JyksXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgS0lORFMgPSBbXG4gICAgWzAsICAgICAgICAgJ01ldGFkYXRhJywgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8wMS5tZCddLFxuICAgIFsxLCAgICAgICAgICdUZXh0JywgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDEubWQnXSxcbiAgICBbMiwgICAgICAgICAnUmVjb21tZW5kIFJlbGF5JywgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzAxLm1kJ10sXG4gICAgWzMsICAgICAgICAgJ0NvbnRhY3RzJywgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8wMi5tZCddLFxuICAgIFs0LCAgICAgICAgICdFbmNyeXB0ZWQgRGlyZWN0IE1lc3NhZ2VzJywgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMDQubWQnXSxcbiAgICBbNSwgICAgICAgICAnRXZlbnQgRGVsZXRpb24nLCAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzA5Lm1kJ10sXG4gICAgWzYsICAgICAgICAgJ1JlcG9zdCcsICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8xOC5tZCddLFxuICAgIFs3LCAgICAgICAgICdSZWFjdGlvbicsICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjUubWQnXSxcbiAgICBbOCwgICAgICAgICAnQmFkZ2UgQXdhcmQnLCAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU4Lm1kJ10sXG4gICAgWzE2LCAgICAgICAgJ0dlbmVyaWMgUmVwb3N0JywgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8xOC5tZCddLFxuICAgIFs0MCwgICAgICAgICdDaGFubmVsIENyZWF0aW9uJywgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjgubWQnXSxcbiAgICBbNDEsICAgICAgICAnQ2hhbm5lbCBNZXRhZGF0YScsICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzI4Lm1kJ10sXG4gICAgWzQyLCAgICAgICAgJ0NoYW5uZWwgTWVzc2FnZScsICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8yOC5tZCddLFxuICAgIFs0MywgICAgICAgICdDaGFubmVsIEhpZGUgTWVzc2FnZScsICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjgubWQnXSxcbiAgICBbNDQsICAgICAgICAnQ2hhbm5lbCBNdXRlIFVzZXInLCAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzI4Lm1kJ10sXG4gICAgWzEwNjMsICAgICAgJ0ZpbGUgTWV0YWRhdGEnLCAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85NC5tZCddLFxuICAgIFsxMzExLCAgICAgICdMaXZlIENoYXQgTWVzc2FnZScsICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTMubWQnXSxcbiAgICBbMTk4NCwgICAgICAnUmVwb3J0aW5nJywgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU2Lm1kJ10sXG4gICAgWzE5ODUsICAgICAgJ0xhYmVsJywgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8zMi5tZCddLFxuICAgIFs0NTUwLCAgICAgICdDb21tdW5pdHkgUG9zdCBBcHByb3ZhbCcsICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzIubWQnXSxcbiAgICBbNzAwMCwgICAgICAnSm9iIEZlZWRiYWNrJywgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzkwLm1kJ10sXG4gICAgWzkwNDEsICAgICAgJ1phcCBHb2FsJywgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci83NS5tZCddLFxuICAgIFs5NzM0LCAgICAgICdaYXAgUmVxdWVzdCcsICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTcubWQnXSxcbiAgICBbOTczNSwgICAgICAnWmFwJywgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU3Lm1kJ10sXG4gICAgWzEwMDAwLCAgICAgJ011dGUgTGlzdCcsICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81MS5tZCddLFxuICAgIFsxMDAwMSwgICAgICdQaW4gTGlzdCcsICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTEubWQnXSxcbiAgICBbMTAwMDIsICAgICAnUmVsYXkgTGlzdCBNZXRhZGF0YScsICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzY1Lm1kJ10sXG4gICAgWzEzMTk0LCAgICAgJ1dhbGxldCBJbmZvJywgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci80Ny5tZCddLFxuICAgIFsyMjI0MiwgICAgICdDbGllbnQgQXV0aGVudGljYXRpb24nLCAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNDIubWQnXSxcbiAgICBbMjMxOTQsICAgICAnV2FsbGV0IFJlcXVlc3QnLCAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzQ3Lm1kJ10sXG4gICAgWzIzMTk1LCAgICAgJ1dhbGxldCBSZXNwb25zZScsICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci80Ny5tZCddLFxuICAgIFsyNDEzMywgICAgICdOb3N0ciBDb25uZWN0JywgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNDYubWQnXSxcbiAgICBbMjcyMzUsICAgICAnSFRUUCBBdXRoJywgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzk4Lm1kJ10sXG4gICAgWzMwMDAwLCAgICAgJ0NhdGVnb3JpemVkIFBlb3BsZSBMaXN0JywgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81MS5tZCddLFxuICAgIFszMDAwMSwgICAgICdDYXRlZ29yaXplZCBCb29rbWFyayBMaXN0JywgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTEubWQnXSxcbiAgICBbMzAwMDgsICAgICAnUHJvZmlsZSBCYWRnZXMnLCAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzU4Lm1kJ10sXG4gICAgWzMwMDA5LCAgICAgJ0JhZGdlIERlZmluaXRpb24nLCAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81OC5tZCddLFxuICAgIFszMDAxNywgICAgICdDcmVhdGUgb3IgdXBkYXRlIGEgc3RhbGwnLCAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMTUubWQnXSxcbiAgICBbMzAwMTgsICAgICAnQ3JlYXRlIG9yIHVwZGF0ZSBhIHByb2R1Y3QnLCAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzE1Lm1kJ10sXG4gICAgWzMwMDIzLCAgICAgJ0xvbmctRm9ybSBDb250ZW50JywgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci8yMy5tZCddLFxuICAgIFszMDAyNCwgICAgICdEcmFmdCBMb25nLWZvcm0gQ29udGVudCcsICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMjMubWQnXSxcbiAgICBbMzAwNzgsICAgICAnQXBwbGljYXRpb24tc3BlY2lmaWMgRGF0YScsICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzc4Lm1kJ10sXG4gICAgWzMwMzExLCAgICAgJ0xpdmUgRXZlbnQnLCAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81My5tZCddLFxuICAgIFszMDMxNSwgICAgICdVc2VyIFN0YXR1c2VzJywgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvMzgubWQnXSxcbiAgICBbMzA0MDIsICAgICAnQ2xhc3NpZmllZCBMaXN0aW5nJywgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzk5Lm1kJ10sXG4gICAgWzMwNDAzLCAgICAgJ0RyYWZ0IENsYXNzaWZpZWQgTGlzdGluZycsICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci85OS5tZCddLFxuICAgIFszMTkyMiwgICAgICdEYXRlLUJhc2VkIENhbGVuZGFyIEV2ZW50JywgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTIubWQnXSxcbiAgICBbMzE5MjMsICAgICAnVGltZS1CYXNlZCBDYWxlbmRhciBFdmVudCcsICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzUyLm1kJ10sXG4gICAgWzMxOTI0LCAgICAgJ0NhbGVuZGFyJywgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci81Mi5tZCddLFxuICAgIFszMTkyNSwgICAgICdDYWxlbmRhciBFdmVudCBSU1ZQJywgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNTIubWQnXSxcbiAgICBbMzE5ODksICAgICAnSGFuZGxlciByZWNvbW1lbmRhdGlvbicsICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzg5Lm1kJ10sXG4gICAgWzMxOTkwLCAgICAgJ0hhbmRsZXIgaW5mb3JtYXRpb24nLCAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci84OS5tZCddLFxuICAgIFszNDU1MCwgICAgICdDb21tdW5pdHkgRGVmaW5pdGlvbicsICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzIubWQnXSxcbl07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGF3YWl0IGdldE9yU2V0RGVmYXVsdCgncHJvZmlsZUluZGV4JywgMCk7XG4gICAgYXdhaXQgZ2V0T3JTZXREZWZhdWx0KCdwcm9maWxlcycsIFthd2FpdCBnZW5lcmF0ZVByb2ZpbGUoKV0pO1xuICAgIGxldCB2ZXJzaW9uID0gKGF3YWl0IHN0b3JhZ2UuZ2V0KHsgdmVyc2lvbjogMCB9KSkudmVyc2lvbjtcbiAgICBjb25zb2xlLmxvZygnREIgdmVyc2lvbjogJywgdmVyc2lvbik7XG4gICAgd2hpbGUgKHZlcnNpb24gPCBEQl9WRVJTSU9OKSB7XG4gICAgICAgIHZlcnNpb24gPSBhd2FpdCBtaWdyYXRlKHZlcnNpb24sIERCX1ZFUlNJT04pO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHZlcnNpb24gfSk7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtaWdyYXRlKHZlcnNpb24sIGdvYWwpIHtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTWlncmF0aW5nIHRvIHZlcnNpb24gMS4nKTtcbiAgICAgICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICAgICAgcHJvZmlsZXMuZm9yRWFjaChwcm9maWxlID0+IChwcm9maWxlLmhvc3RzID0ge30pKTtcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcyB9KTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb24gKyAxO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtaWdyYXRpbmcgdG8gdmVyc2lvbiAyLicpO1xuICAgICAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgICAgICBwcm9maWxlcy5mb3JFYWNoKHByb2ZpbGUgPT4gKHByb2ZpbGUuZGVsZWdhdGUgPSBmYWxzZSkpO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ01pZ3JhdGluZyB0byB2ZXJzaW9uIDMuJyk7XG4gICAgICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgICAgIHByb2ZpbGVzLmZvckVhY2gocHJvZmlsZSA9PiAocHJvZmlsZS5yZWxheVJlbWluZGVyID0gdHJ1ZSkpO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgICAgICByZXR1cm4gdmVyc2lvbiArIDE7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZXMoKSB7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBwcm9maWxlczogW10gfSk7XG4gICAgcmV0dXJuIHByb2ZpbGVzLnByb2ZpbGVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZShpbmRleCkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgcmV0dXJuIHByb2ZpbGVzW2luZGV4XTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2ZpbGVOYW1lcygpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIHJldHVybiBwcm9maWxlcy5tYXAocCA9PiBwLm5hbWUpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZmlsZUluZGV4KCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXdhaXQgc3RvcmFnZS5nZXQoeyBwcm9maWxlSW5kZXg6IDAgfSk7XG4gICAgcmV0dXJuIGluZGV4LnByb2ZpbGVJbmRleDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFByb2ZpbGVJbmRleChwcm9maWxlSW5kZXgpIHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVJbmRleCB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVByb2ZpbGUoaW5kZXgpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGxldCBwcm9maWxlSW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICBwcm9maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChwcm9maWxlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBhd2FpdCBjbGVhckRhdGEoKTsgLy8gSWYgd2UgaGF2ZSBkZWxldGVkIGFsbCBvZiB0aGUgcHJvZmlsZXMsIGxldCdzIGp1c3Qgc3RhcnQgZnJlc2ggd2l0aCBhbGwgbmV3IGRhdGFcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBkZWxldGVkIHdhcyB0aGUgYWN0aXZlIHByb2ZpbGUsIGNoYW5nZSB0aGUgYWN0aXZlIHByb2ZpbGUgdG8gdGhlIG5leHQgb25lXG4gICAgICAgIGxldCBuZXdJbmRleCA9XG4gICAgICAgICAgICBwcm9maWxlSW5kZXggPT09IGluZGV4ID8gTWF0aC5tYXgoaW5kZXggLSAxLCAwKSA6IHRoaXMucHJvZmlsZUluZGV4O1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzLCBwcm9maWxlSW5kZXg6IG5ld0luZGV4IH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyRGF0YSgpIHtcbiAgICBsZXQgaWdub3JlSW5zdGFsbEhvb2sgPSBhd2FpdCBzdG9yYWdlLmdldCh7IGlnbm9yZUluc3RhbGxIb29rOiBmYWxzZSB9KTtcbiAgICBhd2FpdCBzdG9yYWdlLmNsZWFyKCk7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXQoaWdub3JlSW5zdGFsbEhvb2spO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGF3YWl0IGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZSh7IGtpbmQ6ICdnZW5lcmF0ZVByaXZhdGVLZXknIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQcm9maWxlKG5hbWUgPSAnRGVmYXVsdCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwcml2S2V5OiBhd2FpdCBnZW5lcmF0ZVByaXZhdGVLZXkoKSxcbiAgICAgICAgaG9zdHM6IHt9LFxuICAgICAgICByZWxheXM6IFtdLFxuICAgICAgICBkZWxlZ2F0ZTogZmFsc2UsXG4gICAgICAgIHJlbGF5UmVtaW5kZXI6IHRydWUsXG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T3JTZXREZWZhdWx0KGtleSwgZGVmKSB7XG4gICAgbGV0IHZhbCA9IChhd2FpdCBzdG9yYWdlLmdldChrZXkpKVtrZXldO1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgW2tleV06IGRlZiB9KTtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVByb2ZpbGVOYW1lKGluZGV4LCBwcm9maWxlTmFtZSkge1xuICAgIGxldCBwcm9maWxlcyA9IGF3YWl0IGdldFByb2ZpbGVzKCk7XG4gICAgcHJvZmlsZXNbaW5kZXhdLm5hbWUgPSBwcm9maWxlTmFtZTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVByaXZhdGVLZXkoaW5kZXgsIHByaXZhdGVLZXkpIHtcbiAgICBhd2FpdCBicm93c2VyLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBraW5kOiAnc2F2ZVByaXZhdGVLZXknLFxuICAgICAgICBwYXlsb2FkOiBbaW5kZXgsIHByaXZhdGVLZXldLFxuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3UHJvZmlsZSgpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGNvbnN0IG5ld1Byb2ZpbGUgPSBhd2FpdCBnZW5lcmF0ZVByb2ZpbGUoJ05ldyBQcm9maWxlJyk7XG4gICAgcHJvZmlsZXMucHVzaChuZXdQcm9maWxlKTtcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xuICAgIHJldHVybiBwcm9maWxlcy5sZW5ndGggLSAxO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXlzKHByb2ZpbGVJbmRleCkge1xuICAgIGxldCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShwcm9maWxlSW5kZXgpO1xuICAgIHJldHVybiBwcm9maWxlLnJlbGF5cyB8fCBbXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVSZWxheXMocHJvZmlsZUluZGV4LCByZWxheXMpIHtcbiAgICAvLyBIYXZpbmcgYW4gQWxwaW5lIHByb3h5IG9iamVjdCBhcyBhIHN1Yi1vYmplY3QgZG9lcyBub3Qgc2VyaWFsaXplIGNvcnJlY3RseSBpbiBzdG9yYWdlLFxuICAgIC8vIHNvIHdlIGFyZSBwcmUtc2VyaWFsaXppbmcgaGVyZSBiZWZvcmUgYXNzaWduaW5nIGl0IHRvIHRoZSBwcm9maWxlLCBzbyB0aGUgcHJveHlcbiAgICAvLyBvYmogZG9lc24ndCBidWcgb3V0LlxuICAgIGxldCBmaXhlZFJlbGF5cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVsYXlzKSk7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICBsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW3Byb2ZpbGVJbmRleF07XG4gICAgcHJvZmlsZS5yZWxheXMgPSBmaXhlZFJlbGF5cztcbiAgICBhd2FpdCBzdG9yYWdlLnNldCh7IHByb2ZpbGVzIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0KGl0ZW0pIHtcbiAgICByZXR1cm4gKGF3YWl0IHN0b3JhZ2UuZ2V0KGl0ZW0pKVtpdGVtXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKGluZGV4ID0gbnVsbCkge1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICB9XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKGluZGV4KTtcbiAgICBsZXQgaG9zdHMgPSBhd2FpdCBwcm9maWxlLmhvc3RzO1xuICAgIHJldHVybiBob3N0cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlcm1pc3Npb24oaG9zdCwgYWN0aW9uKSB7XG4gICAgbGV0IGluZGV4ID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGUgPSBhd2FpdCBnZXRQcm9maWxlKGluZGV4KTtcbiAgICBjb25zb2xlLmxvZyhob3N0LCBhY3Rpb24pO1xuICAgIGNvbnNvbGUubG9nKCdwcm9maWxlOiAnLCBwcm9maWxlKTtcbiAgICByZXR1cm4gcHJvZmlsZS5ob3N0cz8uW2hvc3RdPy5bYWN0aW9uXSB8fCAnYXNrJztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFBlcm1pc3Npb24oaG9zdCwgYWN0aW9uLCBwZXJtLCBpbmRleCA9IG51bGwpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgaW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICB9XG4gICAgbGV0IHByb2ZpbGUgPSBwcm9maWxlc1tpbmRleF07XG4gICAgbGV0IG5ld1Blcm1zID0gcHJvZmlsZS5ob3N0c1tob3N0XSB8fCB7fTtcbiAgICBuZXdQZXJtcyA9IHsgLi4ubmV3UGVybXMsIFthY3Rpb25dOiBwZXJtIH07XG4gICAgcHJvZmlsZS5ob3N0c1tob3N0XSA9IG5ld1Blcm1zO1xuICAgIHByb2ZpbGVzW2luZGV4XSA9IHByb2ZpbGU7XG4gICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcyB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh1bWFuUGVybWlzc2lvbihwKSB7XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVyZSBldmVudCBzaWduaW5nIGluY2x1ZGVzIGEga2luZCBudW1iZXJcbiAgICBpZiAocC5zdGFydHNXaXRoKCdzaWduRXZlbnQ6JykpIHtcbiAgICAgICAgbGV0IFtlLCBuXSA9IHAuc3BsaXQoJzonKTtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4pO1xuICAgICAgICBsZXQgbm5hbWUgPSBLSU5EUy5maW5kKGsgPT4ga1swXSA9PT0gbik/LlsxXSB8fCBgVW5rbm93biAoS2luZCAke259KWA7XG4gICAgICAgIHJldHVybiBgU2lnbiBldmVudDogJHtubmFtZX1gO1xuICAgIH1cblxuICAgIHN3aXRjaCAocCkge1xuICAgICAgICBjYXNlICdnZXRQdWJLZXknOlxuICAgICAgICAgICAgcmV0dXJuICdSZWFkIHB1YmxpYyBrZXknO1xuICAgICAgICBjYXNlICdzaWduRXZlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdTaWduIGV2ZW50JztcbiAgICAgICAgY2FzZSAnZ2V0UmVsYXlzJzpcbiAgICAgICAgICAgIHJldHVybiAnUmVhZCByZWxheSBsaXN0JztcbiAgICAgICAgY2FzZSAnbmlwMDQuZW5jcnlwdCc6XG4gICAgICAgICAgICByZXR1cm4gJ0VuY3J5cHQgcHJpdmF0ZSBtZXNzYWdlJztcbiAgICAgICAgY2FzZSAnbmlwMDQuZGVjcnlwdCc6XG4gICAgICAgICAgICByZXR1cm4gJ0RlY3J5cHQgcHJpdmF0ZSBtZXNzYWdlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgY29uc3QgaGV4TWF0Y2ggPSAvXltcXGRhLWZdezY0fSQvaS50ZXN0KGtleSk7XG4gICAgY29uc3QgYjMyTWF0Y2ggPSAvXm5zZWMxW3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsXXs1OH0kLy50ZXN0KGtleSk7XG5cbiAgICByZXR1cm4gaGV4TWF0Y2ggfHwgYjMyTWF0Y2g7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZWF0dXJlKG5hbWUpIHtcbiAgICBsZXQgZm5hbWUgPSBgZmVhdHVyZToke25hbWV9YDtcbiAgICBsZXQgZiA9IGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5sb2NhbC5nZXQoeyBbZm5hbWVdOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gZltmbmFtZV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWxheVJlbWluZGVyKCkge1xuICAgIGxldCBpbmRleCA9IGF3YWl0IGdldFByb2ZpbGVJbmRleCgpO1xuICAgIGxldCBwcm9maWxlID0gYXdhaXQgZ2V0UHJvZmlsZShpbmRleCk7XG4gICAgcmV0dXJuIHByb2ZpbGUucmVsYXlSZW1pbmRlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZVJlbGF5UmVtaW5kZXIoKSB7XG4gICAgbGV0IGluZGV4ID0gYXdhaXQgZ2V0UHJvZmlsZUluZGV4KCk7XG4gICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcbiAgICBwcm9maWxlc1tpbmRleF0ucmVsYXlSZW1pbmRlciA9IGZhbHNlO1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KHsgcHJvZmlsZXMgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWxlZ2F0b3IoaW5kZXgpIHtcbiAgICBsZXQgcHJvZmlsZXMgPSBhd2FpdCBnZXRQcm9maWxlcygpO1xuICAgIGxldCBwcm9maWxlID0gcHJvZmlsZXNbaW5kZXhdO1xuICAgIGNvbnNvbGUubG9nKHByb2ZpbGUpO1xuICAgIHJldHVybiBbcHJvZmlsZS5kZWxlZ2F0ZSwgcHJvZmlsZS5kZWxlZ2F0b3JdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TnB1YigpIHtcbiAgICBsZXQgaW5kZXggPSBhd2FpdCBnZXRQcm9maWxlSW5kZXgoKTtcbiAgICByZXR1cm4gYXdhaXQgYnJvd3Nlci5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAga2luZDogJ2dldE5wdWInLFxuICAgICAgICBwYXlsb2FkOiBpbmRleCxcbiAgICB9KTtcbn1cbiIsICIvKiEgbm9ibGUtc2VjcDI1NmsxIC0gTUlUIExpY2Vuc2UgKGMpIDIwMTkgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgKiBhcyBub2RlQ3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfM24gPSBCaWdJbnQoMyk7XG5jb25zdCBfOG4gPSBCaWdJbnQoOCk7XG5jb25zdCBDVVJWRSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGE6IF8wbixcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgUDogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKSxcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpLFxuICAgIGg6IF8xbixcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbn0pO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbmNvbnN0IGVuZG8gPSB7XG4gICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICBzcGxpdFNjYWxhcihrKSB7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyRW5kbzogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICB9LFxufTtcbmNvbnN0IGZpZWxkTGVuID0gMzI7XG5jb25zdCBncm91cExlbiA9IDMyO1xuY29uc3QgaGFzaExlbiA9IDMyO1xuY29uc3QgY29tcHJlc3NlZExlbiA9IGZpZWxkTGVuICsgMTtcbmNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBmaWVsZExlbiArIDE7XG5leHBvcnQgeyBDVVJWRSB9O1xuZnVuY3Rpb24gd2VpZXJzdHJhc3MoeCkge1xuICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgeDIgPSBtb2QoeCAqIHgpO1xuICAgIGNvbnN0IHgzID0gbW9kKHgyICogeCk7XG4gICAgcmV0dXJuIG1vZCh4MyArIGEgKiB4ICsgYik7XG59XG5jb25zdCBVU0VfRU5ET01PUlBISVNNID0gQ1VSVkUuYSA9PT0gXzBuO1xuY2xhc3MgU2hhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRKYWNQb2ludChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgSmFjb2JpYW5Qb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0phY29iaWFuUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbmNsYXNzIEphY29iaWFuUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHopIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKYWNvYmlhblBvaW50I2Zyb21BZmZpbmU6IGV4cGVjdGVkIFBvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHAueCwgcC55LCBfMW4pO1xuICAgIH1cbiAgICBzdGF0aWMgdG9BZmZpbmVCYXRjaChwb2ludHMpIHtcbiAgICAgICAgY29uc3QgdG9JbnYgPSBpbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnopKTtcbiAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKTtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LnRvQWZmaW5lQmF0Y2gocG9pbnRzKS5tYXAoSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEphY1BvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIgfSA9IG90aGVyO1xuICAgICAgICBjb25zdCBaMVoxID0gbW9kKFoxICogWjEpO1xuICAgICAgICBjb25zdCBaMloyID0gbW9kKFoyICogWjIpO1xuICAgICAgICBjb25zdCBVMSA9IG1vZChYMSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBVMiA9IG1vZChYMiAqIFoxWjEpO1xuICAgICAgICBjb25zdCBTMSA9IG1vZChtb2QoWTEgKiBaMikgKiBaMloyKTtcbiAgICAgICAgY29uc3QgUzIgPSBtb2QobW9kKFkyICogWjEpICogWjFaMSk7XG4gICAgICAgIHJldHVybiBVMSA9PT0gVTIgJiYgUzEgPT09IFMyO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludCh0aGlzLngsIG1vZCgtdGhpcy55KSwgdGhpcy56KTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IEEgPSBtb2QoWDEgKiBYMSk7XG4gICAgICAgIGNvbnN0IEIgPSBtb2QoWTEgKiBZMSk7XG4gICAgICAgIGNvbnN0IEMgPSBtb2QoQiAqIEIpO1xuICAgICAgICBjb25zdCB4MWIgPSBYMSArIEI7XG4gICAgICAgIGNvbnN0IEQgPSBtb2QoXzJuICogKG1vZCh4MWIgKiB4MWIpIC0gQSAtIEMpKTtcbiAgICAgICAgY29uc3QgRSA9IG1vZChfM24gKiBBKTtcbiAgICAgICAgY29uc3QgRiA9IG1vZChFICogRSk7XG4gICAgICAgIGNvbnN0IFgzID0gbW9kKEYgLSBfMm4gKiBEKTtcbiAgICAgICAgY29uc3QgWTMgPSBtb2QoRSAqIChEIC0gWDMpIC0gXzhuICogQyk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKF8ybiAqIFkxICogWjEpO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRKYWNQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgaWYgKFgyID09PSBfMG4gfHwgWTIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoWDEgPT09IF8wbiB8fCBZMSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBjb25zdCBaMVoxID0gbW9kKFoxICogWjEpO1xuICAgICAgICBjb25zdCBaMloyID0gbW9kKFoyICogWjIpO1xuICAgICAgICBjb25zdCBVMSA9IG1vZChYMSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBVMiA9IG1vZChYMiAqIFoxWjEpO1xuICAgICAgICBjb25zdCBTMSA9IG1vZChtb2QoWTEgKiBaMikgKiBaMloyKTtcbiAgICAgICAgY29uc3QgUzIgPSBtb2QobW9kKFkyICogWjEpICogWjFaMSk7XG4gICAgICAgIGNvbnN0IEggPSBtb2QoVTIgLSBVMSk7XG4gICAgICAgIGNvbnN0IHIgPSBtb2QoUzIgLSBTMSk7XG4gICAgICAgIGlmIChIID09PSBfMG4pIHtcbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSEggPSBtb2QoSCAqIEgpO1xuICAgICAgICBjb25zdCBISEggPSBtb2QoSCAqIEhIKTtcbiAgICAgICAgY29uc3QgViA9IG1vZChVMSAqIEhIKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QociAqIHIgLSBISEggLSBfMm4gKiBWKTtcbiAgICAgICAgY29uc3QgWTMgPSBtb2QociAqIChWIC0gWDMpIC0gUzEgKiBISEgpO1xuICAgICAgICBjb25zdCBaMyA9IG1vZChaMSAqIFoyICogSCk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IFAwID0gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICBpZiAodHlwZW9mIHNjYWxhciA9PT0gJ2JpZ2ludCcgJiYgc2NhbGFyID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gUDA7XG4gICAgICAgIGxldCBuID0gbm9ybWFsaXplU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCFVU0VfRU5ET01PUlBISVNNKSB7XG4gICAgICAgICAgICBsZXQgcCA9IFAwO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICBsZXQgazFwID0gUDA7XG4gICAgICAgIGxldCBrMnAgPSBQMDtcbiAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBlbmRvLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgIH1cbiAgICBwcmVjb21wdXRlV2luZG93KFcpIHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IFVTRV9FTkRPTU9SUEhJU00gPyAxMjggLyBXICsgMSA6IDI1NiAvIFcgKyAxO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAyICoqIChXIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHdOQUYobiwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgaWYgKCFhZmZpbmVQb2ludCAmJiB0aGlzLmVxdWFscyhKYWNvYmlhblBvaW50LkJBU0UpKVxuICAgICAgICAgICAgYWZmaW5lUG9pbnQgPSBQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBXID0gKGFmZmluZVBvaW50ICYmIGFmZmluZVBvaW50Ll9XSU5ET1dfU0laRSkgfHwgMTtcbiAgICAgICAgaWYgKDI1NiAlIFcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQjd05BRjogSW52YWxpZCBwcmVjb21wdXRhdGlvbiB3aW5kb3csIG11c3QgYmUgcG93ZXIgb2YgMicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVjb21wdXRlcyA9IGFmZmluZVBvaW50ICYmIHBvaW50UHJlY29tcHV0ZXMuZ2V0KGFmZmluZVBvaW50KTtcbiAgICAgICAgaWYgKCFwcmVjb21wdXRlcykge1xuICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coVyk7XG4gICAgICAgICAgICBpZiAoYWZmaW5lUG9pbnQgJiYgVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzID0gSmFjb2JpYW5Qb2ludC5ub3JtYWxpemVaKHByZWNvbXB1dGVzKTtcbiAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChhZmZpbmVQb2ludCwgcHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwID0gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICBsZXQgZiA9IEphY29iaWFuUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IDEgKyAoVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgOiAyNTYgLyBXKTtcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTtcbiAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTtcbiAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIsIGFmZmluZVBvaW50KSB7XG4gICAgICAgIGxldCBuID0gbm9ybWFsaXplU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGxldCBwb2ludDtcbiAgICAgICAgbGV0IGZha2U7XG4gICAgICAgIGlmIChVU0VfRU5ET01PUlBISVNNKSB7XG4gICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgazFwID0gY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgazJwID0gY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgazJwID0gbmV3IEphY29iaWFuUG9pbnQobW9kKGsycC54ICogZW5kby5iZXRhKSwgazJwLnksIGsycC56KTtcbiAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4sIGFmZmluZVBvaW50KTtcbiAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgfVxuICAgIHRvQWZmaW5lKGludlopIHtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpczAgPSB0aGlzLmVxdWFscyhKYWNvYmlhblBvaW50LlpFUk8pO1xuICAgICAgICBpZiAoaW52WiA9PSBudWxsKVxuICAgICAgICAgICAgaW52WiA9IGlzMCA/IF84biA6IGludmVydCh6KTtcbiAgICAgICAgY29uc3QgaXoxID0gaW52WjtcbiAgICAgICAgY29uc3QgaXoyID0gbW9kKGl6MSAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGl6MyA9IG1vZChpejIgKiBpejEpO1xuICAgICAgICBjb25zdCBheCA9IG1vZCh4ICogaXoyKTtcbiAgICAgICAgY29uc3QgYXkgPSBtb2QoeSAqIGl6Myk7XG4gICAgICAgIGNvbnN0IHp6ID0gbW9kKHogKiBpejEpO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgIGlmICh6eiAhPT0gXzFuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYXgsIGF5KTtcbiAgICB9XG59XG5KYWNvYmlhblBvaW50LkJBU0UgPSBuZXcgSmFjb2JpYW5Qb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbik7XG5KYWNvYmlhblBvaW50LlpFUk8gPSBuZXcgSmFjb2JpYW5Qb2ludChfMG4sIF8xbiwgXzBuKTtcbmZ1bmN0aW9uIGNvbnN0VGltZU5lZ2F0ZShjb25kaXRpb24sIGl0ZW0pIHtcbiAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xufVxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSAlIF8ybiA9PT0gXzBuO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgaXNTaG9ydCA9IGJ5dGVzLmxlbmd0aCA9PT0gMzI7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGlzU2hvcnQgPyBieXRlcyA6IGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzcyh4KTtcbiAgICAgICAgbGV0IHkgPSBzcXJ0TW9kKHkyKTtcbiAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgIGlmIChpc1Nob3J0KSB7XG4gICAgICAgICAgICBpZiAoaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdEJ5dGVPZGQgPSAoYnl0ZXNbMF0gJiAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0Qnl0ZU9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVW5jb21wcmVzc2VkSGV4KGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDEsIGZpZWxkTGVuICsgMSkpO1xuICAgICAgICBjb25zdCB5ID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheShmaWVsZExlbiArIDEsIGZpZWxkTGVuICogMiArIDEpKTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoaGV4KTtcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBieXRlc1swXTtcbiAgICAgICAgaWYgKGxlbiA9PT0gZmllbGRMZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWRlciA9PT0gMHgwMiB8fCBoZWFkZXIgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWRlciA9PT0gMHgwNClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50LmZyb21IZXg6IHJlY2VpdmVkIGludmFsaWQgcG9pbnQuIEV4cGVjdGVkIDMyLSR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzLCBub3QgJHtsZW59YCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmICghWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlY292ZXJ5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlY292ZXI6IGludmFsaWQgcmVjb3ZlcnkgYml0Jyk7XG4gICAgICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2goZW5zdXJlQnl0ZXMobXNnSGFzaCkpO1xuICAgICAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgICAgICBjb25zdCByYWRqID0gcmVjb3ZlcnkgPT09IDIgfHwgcmVjb3ZlcnkgPT09IDMgPyByICsgbiA6IHI7XG4gICAgICAgIGNvbnN0IHJpbnYgPSBpbnZlcnQocmFkaiwgbik7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKC1oICogcmludiwgbik7XG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHMgKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gcmVjb3ZlcnkgJiAxID8gJzAzJyA6ICcwMic7XG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvMzJiU3RyKHJhZGopKTtcbiAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTtcbiAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlciBzaWduYXR1cmU6IHBvaW50IGF0IGluZmluaWZ5Jyk7XG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleChpc0NvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgdG9IZXgoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeCA9IG51bVRvMzJiU3RyKHRoaXMueCk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuaGFzRXZlblkoKSA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3h9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgMDQke3h9JHtudW1UbzMyYlN0cih0aGlzLnkpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9IZXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCh0cnVlKS5zbGljZSgyKTtcbiAgICB9XG4gICAgdG9SYXdYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1BvaW50IGlzIG5vdCBvbiBlbGxpcHRpYyBjdXJ2ZSc7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpIHx8ICFpc1ZhbGlkRmllbGRFbGVtZW50KHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2QoeSAqIHkpO1xuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBpZiAobW9kKGxlZnQgLSByaWdodCkgIT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIG1vZCgtdGhpcy55KSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5kb3VibGUoKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5hZGQoSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKG90aGVyKSkudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykubXVsdGlwbHkoc2NhbGFyLCB0aGlzKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFAgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcyk7XG4gICAgICAgIGNvbnN0IGFQID0gYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCB0aGlzICE9PSBQb2ludC5CQVNFID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSk7XG4gICAgICAgIGNvbnN0IGJRID0gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKFEpLm11bHRpcGx5VW5zYWZlKGIpO1xuICAgICAgICBjb25zdCBzdW0gPSBhUC5hZGQoYlEpO1xuICAgICAgICByZXR1cm4gc3VtLmVxdWFscyhKYWNvYmlhblBvaW50LlpFUk8pID8gdW5kZWZpbmVkIDogc3VtLnRvQWZmaW5lKCk7XG4gICAgfVxufVxuUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3kpO1xuUG9pbnQuWkVSTyA9IG5ldyBQb2ludChfMG4sIF8wbik7XG5mdW5jdGlvbiBzbGljZURFUihzKSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChzWzBdLCAxNikgPj0gOCA/ICcwMCcgKyBzIDogcztcbn1cbmZ1bmN0aW9uIHBhcnNlREVSSW50KGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoYCk7XG4gICAgfVxuICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgcmVzWzFdIDw9IDB4N2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB0cmFpbGluZyBsZW5ndGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogYnl0ZXNUb051bWJlcihyZXMpLCBsZWZ0OiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07XG59XG5mdW5jdGlvbiBwYXJzZURFUlNpZ25hdHVyZShkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSB0YWc6ICR7Ynl0ZXNUb0hleChkYXRhKX1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGFbMV0gIT09IGRhdGEubGVuZ3RoIC0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YTogciwgbGVmdDogc0J5dGVzIH0gPSBwYXJzZURFUkludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICBjb25zdCB7IGRhdGE6IHMsIGxlZnQ6IHJCeXRlc0xlZnQgfSA9IHBhcnNlREVSSW50KHNCeXRlcyk7XG4gICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZzogJHtieXRlc1RvSGV4KHJCeXRlc0xlZnQpfWApO1xuICAgIH1cbiAgICByZXR1cm4geyByLCBzIH07XG59XG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihyLCBzKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICBjb25zdCBhcnIgPSBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBuYW1lID0gJ1NpZ25hdHVyZS5mcm9tQ29tcGFjdCc7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfTogRXhwZWN0ZWQgc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgY29uc3Qgc3RyID0gYXJyID8gYnl0ZXNUb0hleChoZXgpIDogaGV4O1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMTI4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9OiBFeHBlY3RlZCA2NC1ieXRlIGhleGApO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShoZXhUb051bWJlcihzdHIuc2xpY2UoMCwgNjQpKSwgaGV4VG9OdW1iZXIoc3RyLnNsaWNlKDY0LCAxMjgpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICBjb25zdCBhcnIgPSBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycgJiYgIWFycilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNpZ25hdHVyZS5mcm9tREVSOiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHBhcnNlREVSU2lnbmF0dXJlKGFyciA/IGhleCA6IGhleFRvQnl0ZXMoaGV4KSk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURFUihoZXgpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihyKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHIgbXVzdCBiZSAwIDwgciA8IG4nKTtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2lnbmF0dXJlOiBzIG11c3QgYmUgMCA8IHMgPCBuJyk7XG4gICAgfVxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkUubiA+PiBfMW47XG4gICAgICAgIHJldHVybiB0aGlzLnMgPiBIQUxGO1xuICAgIH1cbiAgICBub3JtYWxpemVTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZCgtdGhpcy5zLCBDVVJWRS5uKSkgOiB0aGlzO1xuICAgIH1cbiAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgIH1cbiAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgY29uc3Qgc0hleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5zKSk7XG4gICAgICAgIGNvbnN0IHJIZXggPSBzbGljZURFUihudW1iZXJUb0hleFVucGFkZGVkKHRoaXMucikpO1xuICAgICAgICBjb25zdCBzSGV4TCA9IHNIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgckhleEwgPSBySGV4Lmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNMZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKHNIZXhMKTtcbiAgICAgICAgY29uc3QgckxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBudW1iZXJUb0hleFVucGFkZGVkKHJIZXhMICsgc0hleEwgKyA0KTtcbiAgICAgICAgcmV0dXJuIGAzMCR7bGVuZ3RofTAyJHtyTGVufSR7ckhleH0wMiR7c0xlbn0ke3NIZXh9YDtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ERVJSYXdCeXRlcygpO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ERVJIZXgoKTtcbiAgICB9XG4gICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYikgPT4gYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5jb25zdCBQT1dfMl8yNTYgPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbmZ1bmN0aW9uIG51bVRvMzJiU3RyKG51bSkge1xuICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBiaWdpbnQnKTtcbiAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IFBPV18yXzI1NikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbnVtYmVyIDAgPD0gbiA8IDJeMjU2Jyk7XG4gICAgcmV0dXJuIG51bS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJyk7XG59XG5mdW5jdGlvbiBudW1UbzMyYihudW0pIHtcbiAgICBjb25zdCBiID0gaGV4VG9CeXRlcyhudW1UbzMyYlN0cihudW0pKTtcbiAgICBpZiAoYi5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBleHBlY3RlZCAzMiBieXRlcycpO1xuICAgIHJldHVybiBiO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb051bWJlcjogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGAweCR7aGV4fWApO1xufVxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnICsgaGV4Lmxlbmd0aCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSA/IFVpbnQ4QXJyYXkuZnJvbShoZXgpIDogaGV4VG9CeXRlcyhoZXgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2NhbGFyKG51bSkge1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pICYmIG51bSA+IDApXG4gICAgICAgIHJldHVybiBCaWdJbnQobnVtKTtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgIHJldHVybiBudW07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBzY2FsYXI6IDAgPCBzY2FsYXIgPCBjdXJ2ZS5uJyk7XG59XG5mdW5jdGlvbiBtb2QoYSwgYiA9IENVUlZFLlApIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyKSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gUDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHNxcnRNb2QoeCkge1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgXzZuID0gQmlnSW50KDYpO1xuICAgIGNvbnN0IF8xMW4gPSBCaWdJbnQoMTEpO1xuICAgIGNvbnN0IF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpO1xuICAgIGNvbnN0IF80NG4gPSBCaWdJbnQoNDQpO1xuICAgIGNvbnN0IF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHggKiB4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB4KSAlIFA7XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybikgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbikgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4pICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4pICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbikgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbikgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4pICogYjIpICUgUDtcbiAgICBjb25zdCBydCA9IHBvdzIodDIsIF8ybik7XG4gICAgY29uc3QgeGMgPSAocnQgKiBydCkgJSBQO1xuICAgIGlmICh4YyAhPT0geClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiBydDtcbn1cbmZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbyA9IENVUlZFLlApIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuZnVuY3Rpb24gaW52ZXJ0QmF0Y2gobnVtcywgcCA9IENVUlZFLlApIHtcbiAgICBjb25zdCBzY3JhdGNoID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgXzFuKTtcbiAgICBjb25zdCBpbnZlcnRlZCA9IGludmVydChsYXN0TXVsdGlwbGllZCwgcCk7XG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKG51bSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgc2NyYXRjaFtpXSA9IG1vZChhY2MgKiBzY3JhdGNoW2ldLCBwKTtcbiAgICAgICAgcmV0dXJuIG1vZChhY2MgKiBudW0sIHApO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gc2NyYXRjaDtcbn1cbmZ1bmN0aW9uIGJpdHMyaW50XzIoYnl0ZXMpIHtcbiAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBncm91cExlbiAqIDg7XG4gICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlcihieXRlcyk7XG4gICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xufVxuZnVuY3Rpb24gdHJ1bmNhdGVIYXNoKGhhc2gsIHRydW5jYXRlT25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaCA9IGJpdHMyaW50XzIoaGFzaCk7XG4gICAgaWYgKHRydW5jYXRlT25seSlcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICByZXR1cm4gaCA+PSBuID8gaCAtIG4gOiBoO1xufVxubGV0IF9zaGEyNTZTeW5jO1xubGV0IF9obWFjU2hhMjU2U3luYztcbmNsYXNzIEhtYWNEcmJnIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoTGVuLCBxQnl0ZUxlbikge1xuICAgICAgICB0aGlzLmhhc2hMZW4gPSBoYXNoTGVuO1xuICAgICAgICB0aGlzLnFCeXRlTGVuID0gcUJ5dGVMZW47XG4gICAgICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgdGhpcy52ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaExlbikuZmlsbCgxKTtcbiAgICAgICAgdGhpcy5rID0gbmV3IFVpbnQ4QXJyYXkoaGFzaExlbikuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB9XG4gICAgaG1hYyguLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmhtYWNTaGEyNTYodGhpcy5rLCAuLi52YWx1ZXMpO1xuICAgIH1cbiAgICBobWFjU3luYyguLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYyh0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGNoZWNrU3luYygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfaG1hY1NoYTI1NlN5bmMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hhRXJyb3IoJ2htYWNTaGEyNTZTeW5jIG5lZWRzIHRvIGJlIHNldCcpO1xuICAgIH1cbiAgICBpbmNyKCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudGVyID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIDEsMDAwIGsgdmFsdWVzIGZvciBzaWduKCksIGFsbCB3ZXJlIGludmFsaWQnKTtcbiAgICAgICAgdGhpcy5jb3VudGVyICs9IDE7XG4gICAgfVxuICAgIGFzeW5jIHJlc2VlZChzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmsgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDBdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgfVxuICAgIHJlc2VlZFN5bmMoc2VlZCA9IG5ldyBVaW50OEFycmF5KCkpIHtcbiAgICAgICAgdGhpcy5jaGVja1N5bmMoKTtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IHRoaXMuaG1hY1N5bmModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDFdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IHRoaXMuaG1hY1N5bmModGhpcy52KTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdGhpcy52LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy52Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTeW5jKCkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmluY3IoKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgdGhpcy5xQnl0ZUxlbikge1xuICAgICAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUuUDtcbn1cbmZ1bmN0aW9uIGttZFRvU2lnKGtCeXRlcywgbSwgZCwgbG93UyA9IHRydWUpIHtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IGsgPSB0cnVuY2F0ZUhhc2goa0J5dGVzLCB0cnVlKTtcbiAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGtpbnYgPSBpbnZlcnQoaywgbik7XG4gICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoayk7XG4gICAgY29uc3QgciA9IG1vZChxLngsIG4pO1xuICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gbW9kKGtpbnYgKiBtb2QobSArIGQgKiByLCBuKSwgbik7XG4gICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHNpZy5yID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7XG4gICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpIHtcbiAgICAgICAgc2lnID0gc2lnLm5vcm1hbGl6ZVMoKTtcbiAgICAgICAgcmVjb3ZlcnkgXj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnLCByZWNvdmVyeSB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJpdmF0ZUtleShrZXkpIHtcbiAgICBsZXQgbnVtO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnYmlnaW50Jykge1xuICAgICAgICBudW0gPSBrZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKGtleSkgJiYga2V5ID4gMCkge1xuICAgICAgICBudW0gPSBCaWdJbnQoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggIT09IDIgKiBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gaGV4VG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gZ3JvdXBMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDMyIGJ5dGVzIG9mIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIG51bSA9IGJ5dGVzVG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJpdmF0ZSBrZXk6IDAgPCBrZXkgPCBuJyk7XG4gICAgcmV0dXJuIG51bTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcHVibGljS2V5LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgIHNpZ25hdHVyZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21ERVIoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21TaWduYXR1cmUobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICBjb25zdCBhcnIgPSBpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgIGlmIChhcnIpXG4gICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgaWYgKHN0cilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiAqIDIgfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW4gKiAyO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFNoYXJlZFNlY3JldDogZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgIGNvbnN0IGIgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljQik7XG4gICAgYi5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBiaXRzMmludChieXRlcykge1xuICAgIGNvbnN0IHNsaWNlID0gYnl0ZXMubGVuZ3RoID4gZmllbGRMZW4gPyBieXRlcy5zbGljZSgwLCBmaWVsZExlbikgOiBieXRlcztcbiAgICByZXR1cm4gYnl0ZXNUb051bWJlcihzbGljZSk7XG59XG5mdW5jdGlvbiBiaXRzMm9jdGV0cyhieXRlcykge1xuICAgIGNvbnN0IHoxID0gYml0czJpbnQoYnl0ZXMpO1xuICAgIGNvbnN0IHoyID0gbW9kKHoxLCBDVVJWRS5uKTtcbiAgICByZXR1cm4gaW50Mm9jdGV0cyh6MiA8IF8wbiA/IHoxIDogejIpO1xufVxuZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICByZXR1cm4gbnVtVG8zMmIobnVtKTtcbn1cbmZ1bmN0aW9uIGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZhdGVLZXksIGV4dHJhRW50cm9weSkge1xuICAgIGlmIChtc2dIYXNoID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbjogZXhwZWN0ZWQgdmFsaWQgbWVzc2FnZSBoYXNoLCBub3QgXCIke21zZ0hhc2h9XCJgKTtcbiAgICBjb25zdCBoMSA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIGNvbnN0IGQgPSBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGJpdHMyb2N0ZXRzKGgxKV07XG4gICAgaWYgKGV4dHJhRW50cm9weSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChleHRyYUVudHJvcHkgPT09IHRydWUpXG4gICAgICAgICAgICBleHRyYUVudHJvcHkgPSB1dGlscy5yYW5kb21CeXRlcyhmaWVsZExlbik7XG4gICAgICAgIGNvbnN0IGUgPSBlbnN1cmVCeXRlcyhleHRyYUVudHJvcHkpO1xuICAgICAgICBpZiAoZS5sZW5ndGggIT09IGZpZWxkTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBFeHBlY3RlZCAke2ZpZWxkTGVufSBieXRlcyBvZiBleHRyYSBkYXRhYCk7XG4gICAgICAgIHNlZWRBcmdzLnB1c2goZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7XG4gICAgY29uc3QgbSA9IGJpdHMyaW50KGgxKTtcbiAgICByZXR1cm4geyBzZWVkLCBtLCBkIH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVNpZyhyZWNTaWcsIG9wdHMpIHtcbiAgICBjb25zdCB7IHNpZywgcmVjb3ZlcnkgfSA9IHJlY1NpZztcbiAgICBjb25zdCB7IGRlciwgcmVjb3ZlcmVkIH0gPSBPYmplY3QuYXNzaWduKHsgY2Fub25pY2FsOiB0cnVlLCBkZXI6IHRydWUgfSwgb3B0cyk7XG4gICAgY29uc3QgaGFzaGVkID0gZGVyID8gc2lnLnRvREVSUmF3Qnl0ZXMoKSA6IHNpZy50b0NvbXBhY3RSYXdCeXRlcygpO1xuICAgIHJldHVybiByZWNvdmVyZWQgPyBbaGFzaGVkLCByZWNvdmVyeV0gOiBoYXNoZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2VlZCwgbSwgZCB9ID0gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdktleSwgb3B0cy5leHRyYUVudHJvcHkpO1xuICAgIGNvbnN0IGRyYmcgPSBuZXcgSG1hY0RyYmcoaGFzaExlbiwgZ3JvdXBMZW4pO1xuICAgIGF3YWl0IGRyYmcucmVzZWVkKHNlZWQpO1xuICAgIGxldCBzaWc7XG4gICAgd2hpbGUgKCEoc2lnID0ga21kVG9TaWcoYXdhaXQgZHJiZy5nZW5lcmF0ZSgpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBhd2FpdCBkcmJnLnJlc2VlZCgpO1xuICAgIHJldHVybiBmaW5hbGl6ZVNpZyhzaWcsIG9wdHMpO1xufVxuZnVuY3Rpb24gc2lnblN5bmMobXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgY29uc3QgZHJiZyA9IG5ldyBIbWFjRHJiZyhoYXNoTGVuLCBncm91cExlbik7XG4gICAgZHJiZy5yZXNlZWRTeW5jKHNlZWQpO1xuICAgIGxldCBzaWc7XG4gICAgd2hpbGUgKCEoc2lnID0ga21kVG9TaWcoZHJiZy5nZW5lcmF0ZVN5bmMoKSwgbSwgZCwgb3B0cy5jYW5vbmljYWwpKSlcbiAgICAgICAgZHJiZy5yZXNlZWRTeW5jKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5leHBvcnQgeyBzaWduLCBzaWduU3luYyB9O1xuY29uc3Qgdm9wdHMgPSB7IHN0cmljdDogdHJ1ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IHZvcHRzKSB7XG4gICAgbGV0IHNpZztcbiAgICB0cnkge1xuICAgICAgICBzaWcgPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICBpZiAob3B0cy5zdHJpY3QgJiYgc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoID0gdHJ1bmNhdGVIYXNoKG1zZ0hhc2gpO1xuICAgIGxldCBQO1xuICAgIHRyeSB7XG4gICAgICAgIFAgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBzaW52ID0gaW52ZXJ0KHMsIG4pO1xuICAgIGNvbnN0IHUxID0gbW9kKGggKiBzaW52LCBuKTtcbiAgICBjb25zdCB1MiA9IG1vZChyICogc2ludiwgbik7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKTtcbiAgICBpZiAoIVIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB2ID0gbW9kKFIueCwgbik7XG4gICAgcmV0dXJuIHYgPT09IHI7XG59XG5mdW5jdGlvbiBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUoY2gpIHtcbiAgICByZXR1cm4gbW9kKGJ5dGVzVG9OdW1iZXIoY2gpLCBDVVJWRS5uKTtcbn1cbmNsYXNzIFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA2NClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNjaG5vcnJTaWduYXR1cmUuZnJvbUhleDogZXhwZWN0ZWQgNjQgYnl0ZXMsIG5vdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMzIsIDY0KSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Nobm9yclNpZ25hdHVyZShyLCBzKTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHIpIHx8ICFpc1dpdGhpbkN1cnZlT3JkZXIocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gbnVtVG8zMmJTdHIodGhpcy5yKSArIG51bVRvMzJiU3RyKHRoaXMucyk7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9IZXgoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3WCgpO1xufVxuY2xhc3MgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gdXRpbHMucmFuZG9tQnl0ZXMoKSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc2lnbjogRXhwZWN0ZWQgdmFsaWQgbWVzc2FnZSwgbm90IFwiJHttZXNzYWdlfVwiYCk7XG4gICAgICAgIHRoaXMubSA9IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB7IHgsIHNjYWxhciB9ID0gdGhpcy5nZXRTY2FsYXIobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgICAgIHRoaXMucHggPSB4O1xuICAgICAgICB0aGlzLmQgPSBzY2FsYXI7XG4gICAgICAgIHRoaXMucmFuZCA9IGVuc3VyZUJ5dGVzKGF1eFJhbmQpO1xuICAgICAgICBpZiAodGhpcy5yYW5kLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaWduOiBFeHBlY3RlZCAzMiBieXRlcyBvZiBhdXggcmFuZG9tbmVzcycpO1xuICAgIH1cbiAgICBnZXRTY2FsYXIocHJpdikge1xuICAgICAgICBjb25zdCBwb2ludCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXYpO1xuICAgICAgICBjb25zdCBzY2FsYXIgPSBwb2ludC5oYXNFdmVuWSgpID8gcHJpdiA6IENVUlZFLm4gLSBwcml2O1xuICAgICAgICByZXR1cm4geyBwb2ludCwgc2NhbGFyLCB4OiBwb2ludC50b1Jhd1goKSB9O1xuICAgIH1cbiAgICBpbml0Tm9uY2UoZCwgdDBoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlcih0MGgpKTtcbiAgICB9XG4gICAgZmluYWxpemVOb25jZShrMGgpIHtcbiAgICAgICAgY29uc3QgazAgPSBtb2QoYnl0ZXNUb051bWJlcihrMGgpLCBDVVJWRS5uKTtcbiAgICAgICAgaWYgKGswID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IENyZWF0aW9uIG9mIHNpZ25hdHVyZSBmYWlsZWQuIGsgaXMgemVybycpO1xuICAgICAgICBjb25zdCB7IHBvaW50OiBSLCB4OiByeCwgc2NhbGFyOiBrIH0gPSB0aGlzLmdldFNjYWxhcihrMCk7XG4gICAgICAgIHJldHVybiB7IFIsIHJ4LCBrIH07XG4gICAgfVxuICAgIGZpbmFsaXplU2lnKFIsIGssIGUsIGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKFIueCwgbW9kKGsgKyBlICogZCwgQ1VSVkUubikpLnRvUmF3Qnl0ZXMoKTtcbiAgICB9XG4gICAgZXJyb3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsYygpIHtcbiAgICAgICAgY29uc3QgeyBtLCBkLCBweCwgcmFuZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFnID0gdXRpbHMudGFnZ2VkSGFzaDtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuaW5pdE5vbmNlKGQsIGF3YWl0IHRhZyhUQUdTLmF1eCwgcmFuZCkpO1xuICAgICAgICBjb25zdCB7IFIsIHJ4LCBrIH0gPSB0aGlzLmZpbmFsaXplTm9uY2UoYXdhaXQgdGFnKFRBR1Mubm9uY2UsIHQsIHB4LCBtKSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUoYXdhaXQgdGFnKFRBR1MuY2hhbGxlbmdlLCByeCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5maW5hbGl6ZVNpZyhSLCBrLCBlLCBkKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSkpXG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuICAgIGNhbGNTeW5jKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoU3luYztcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuaW5pdE5vbmNlKGQsIHRhZyhUQUdTLmF1eCwgcmFuZCkpO1xuICAgICAgICBjb25zdCB7IFIsIHJ4LCBrIH0gPSB0aGlzLmZpbmFsaXplTm9uY2UodGFnKFRBR1Mubm9uY2UsIHQsIHB4LCBtKSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodGFnKFRBR1MuY2hhbGxlbmdlLCByeCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5maW5hbGl6ZVNpZyhSLCBrLCBlLCBkKTtcbiAgICAgICAgaWYgKCFzY2hub3JyVmVyaWZ5U3luYyhzaWcsIG0sIHB4KSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzY2hub3JyU2lnbihtc2csIHByaXZLZXksIGF1eFJhbmQpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsU2Nobm9yclNpZ25hdHVyZShtc2csIHByaXZLZXksIGF1eFJhbmQpLmNhbGMoKTtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJTaWduU3luYyhtc2csIHByaXZLZXksIGF1eFJhbmQpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsU2Nobm9yclNpZ25hdHVyZShtc2csIHByaXZLZXksIGF1eFJhbmQpLmNhbGNTeW5jKCk7XG59XG5mdW5jdGlvbiBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHJhdyA9IHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNjaG5vcnJTaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnID0gcmF3ID8gc2lnbmF0dXJlIDogU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHJhdylcbiAgICAgICAgc2lnLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc2lnLFxuICAgICAgICBtOiBlbnN1cmVCeXRlcyhtZXNzYWdlKSxcbiAgICAgICAgUDogbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2Nobm9yclZlcmlmeShyLCBQLCBzLCBlKSB7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgbm9ybWFsaXplUHJpdmF0ZUtleShzKSwgbW9kKC1lLCBDVVJWRS5uKSk7XG4gICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi54ICE9PSByKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5hc3luYyBmdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUoYXdhaXQgdXRpbHMudGFnZ2VkSGFzaChUQUdTLmNoYWxsZW5nZSwgbnVtVG8zMmIociksIFAudG9SYXdYKCksIG0pKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplU2Nobm9yclZlcmlmeShyLCBQLCBzLCBlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5U3luYyhzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgciwgcywgbSwgUCB9ID0gaW5pdFNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBlID0gc2Nobm9yckNoYWxsZW5nZUZpbmFsaXplKHV0aWxzLnRhZ2dlZEhhc2hTeW5jKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2hhRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzY2hub3JyID0ge1xuICAgIFNpZ25hdHVyZTogU2Nobm9yclNpZ25hdHVyZSxcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHNpZ25TeW5jOiBzY2hub3JyU2lnblN5bmMsXG4gICAgdmVyaWZ5U3luYzogc2Nobm9yclZlcmlmeVN5bmMsXG59O1xuUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbmNvbnN0IGNyeXB0byA9IHtcbiAgICBub2RlOiBub2RlQ3J5cHRvLFxuICAgIHdlYjogdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIHNlbGYgPyBzZWxmLmNyeXB0byA6IHVuZGVmaW5lZCxcbn07XG5jb25zdCBUQUdTID0ge1xuICAgIGNoYWxsZW5nZTogJ0JJUDAzNDAvY2hhbGxlbmdlJyxcbiAgICBhdXg6ICdCSVAwMzQwL2F1eCcsXG4gICAgbm9uY2U6ICdCSVAwMzQwL25vbmNlJyxcbn07XG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgaGV4VG9CeXRlcyxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBtb2QsXG4gICAgaW52ZXJ0LFxuICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2JpZ2ludFRvMzJCeXRlczogbnVtVG8zMmIsXG4gICAgX25vcm1hbGl6ZVByaXZhdGVLZXk6IG5vcm1hbGl6ZVByaXZhdGVLZXksXG4gICAgaGFzaFRvUHJpdmF0ZUtleTogKGhhc2gpID0+IHtcbiAgICAgICAgaGFzaCA9IGVuc3VyZUJ5dGVzKGhhc2gpO1xuICAgICAgICBjb25zdCBtaW5MZW4gPSBncm91cExlbiArIDg7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA8IG1pbkxlbiB8fCBoYXNoLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgYnl0ZXMgb2YgcHJpdmF0ZSBrZXkgYXMgcGVyIEZJUFMgMTg2YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtID0gbW9kKGJ5dGVzVG9OdW1iZXIoaGFzaCksIENVUlZFLm4gLSBfMW4pICsgXzFuO1xuICAgICAgICByZXR1cm4gbnVtVG8zMmIobnVtKTtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiAoYnl0ZXNMZW5ndGggPSAzMikgPT4ge1xuICAgICAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tQnl0ZXMgfSA9IGNyeXB0by5ub2RlO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcyhieXRlc0xlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gdXRpbHMuaGFzaFRvUHJpdmF0ZUtleSh1dGlscy5yYW5kb21CeXRlcyhncm91cExlbiArIDgpKSxcbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gcG9pbnQgPT09IFBvaW50LkJBU0UgPyBwb2ludCA6IG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgY2FjaGVkLl9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICBjYWNoZWQubXVsdGlwbHkoXzNuKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9LFxuICAgIHNoYTI1NjogYXN5bmMgKC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBjb25jYXRCeXRlcyguLi5tZXNzYWdlcykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiBoYXNoLnVwZGF0ZShtKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhhc2guZGlnZXN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSBzaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhtYWNTaGEyNTY6IGFzeW5jIChrZXksIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBja2V5ID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBrZXksIHsgbmFtZTogJ0hNQUMnLCBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9IH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY29uY2F0Qnl0ZXMoLi4ubWVzc2FnZXMpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuc2lnbignSE1BQycsIGNrZXksIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSG1hYyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIGhtYWMtc2hhMjU2IGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaGEyNTZTeW5jOiB1bmRlZmluZWQsXG4gICAgaG1hY1NoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICB0YWdnZWRIYXNoOiBhc3luYyAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0ggPSBhd2FpdCB1dGlscy5zaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLnNoYTI1Nih0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICB0YWdnZWRIYXNoU3luYzogKHRhZywgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBfc2hhMjU2U3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGFFcnJvcignc2hhMjU2U3luYyBpcyB1bmRlZmluZWQsIHlvdSBuZWVkIHRvIHNldCBpdCcpO1xuICAgICAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0ggPSBfc2hhMjU2U3luYyhVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NoYTI1NlN5bmModGFnUCwgLi4ubWVzc2FnZXMpO1xuICAgIH0sXG4gICAgX0phY29iaWFuUG9pbnQ6IEphY29iaWFuUG9pbnQsXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXModXRpbHMsIHtcbiAgICBzaGEyNTZTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfc2hhMjU2U3luYylcbiAgICAgICAgICAgICAgICBfc2hhMjU2U3luYyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGhtYWNTaGEyNTZTeW5jOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfaG1hY1NoYTI1NlN5bmM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgIGlmICghX2htYWNTaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9obWFjU2hhMjU2U3luYyA9IHZhbDtcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG4iLCAiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHtcbiAgICBub2RlOiB1bmRlZmluZWQsXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbiIsICIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjEgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBUaGUgaW1wb3J0IGhlcmUgaXMgdmlhIHRoZSBwYWNrYWdlIG5hbWUuIFRoaXMgaXMgdG8gZW5zdXJlXG4vLyB0aGF0IGV4cG9ydHMgbWFwcGluZy9yZXNvbHV0aW9uIGRvZXMgZmFsbCBpbnRvIHBsYWNlLlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZXJlIGlzIGFsbW9zdCBubyBiaWcgZW5kaWFuIGhhcmR3YXJlLCBidXQganMgdHlwZWQgYXJyYXlzIHVzZXMgcGxhdGZvcm0gc3BlY2lmaWMgZW5kaWFuZXNzLlxuLy8gU28sIGp1c3QgdG8gYmUgc3VyZSBub3QgdG8gY29ycnVwdCBhbnl0aGluZy5cbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIHByZS1jYWNoaW5nIGNoYXJzIGNvdWxkIHNwZWVkIHRoaXMgdXAgNnguXG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gcGFyc2VIZXhCeXRlKGhleEJ5dGUpIHtcbiAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihieXRlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8vIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpIC0+IGhleFRvQnl0ZXMoaGV4KVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGFycmF5W2ldID0gcGFyc2VIZXhCeXRlKGhleC5zbGljZShqLCBqICsgMikpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBDdXJyZW50bHkgYXZvaWQgaW5zZXJ0aW9uIG9mIHBvbHlmaWxscyB3aXRoIHBhY2tlcnMgKGJyb3dzZXJpZnkvd2VicGFjay9ldGMpXG4vLyBCdXQgc2V0VGltZW91dCBpcyBwcmV0dHkgc2xvdywgbWF5YmUgd29ydGggdG8gaW52ZXN0aWdhdGUgaG93dG8gZG8gbWluaW1hbCBwb2x5ZmlsbCBoZXJlXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSAoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5yZXF1aXJlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIG1vZHVsZS5yZXF1aXJlLmJpbmQobW9kdWxlKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAobm9kZVJlcXVpcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2V0SW1tZWRpYXRlIH0gPSBub2RlUmVxdWlyZSgndGltZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG59KSgpO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdHlwZSBpcyBVaW50OEFycmF5IChnb3QgJHt0eXBlb2YgZGF0YX0pYCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBCdWZmZXIuY29uY2F0KFtidWYxLCBidWYyXSkgLT4gY29uY2F0Qnl0ZXMoYnVmMSwgYnVmMilcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRCeXRlcyhieXRlcywgLi4ubGVuZ3Rocykge1xuICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgKCFsZW5ndGhzLmxlbmd0aCB8fCBsZW5ndGhzLmluY2x1ZGVzKGJ5dGVzLmxlbmd0aCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJHtsZW5ndGhzfSBieXRlcywgbm90ICR7dHlwZW9mIGJ5dGVzfSB3aXRoIGxlbmd0aD0ke2J5dGVzLmxlbmd0aH1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guaW5pdCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIGFzc2VydE51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWYsIF9vcHRzKSB7XG4gICAgaWYgKF9vcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBfb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3QoX29wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZiwgX29wdHMpO1xuICAgIHJldHVybiBvcHRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtZXNzYWdlKSA9PiBoYXNoQ29uc3RydWN0b3IoKS51cGRhdGUodG9CeXRlcyhtZXNzYWdlKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5pbml0ID0gaGFzaEMuY3JlYXRlO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIGhhc2hDLmluaXQgPSBoYXNoQy5jcmVhdGU7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5ub2RlLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4sIGZpbmlzaGVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN0YW5jZSBpcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgaWYgKCEob3V0IGluc3RhbmNlb2YgVWludDhBcnJheSkgfHwgb3V0Lmxlbmd0aCA8IHRoaXMub3V0cHV0TGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfU2hhMjogSW52YWxpZCBvdXRwdXQgYnVmZmVyJyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTk9URTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NGJpdCBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gb3ZpZXcuc2V0VWludDMyKDQgKiBpLCB2LCBpc0xFKSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuIiwgIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIGNvbnN0IGVuY29kZSA9IEFycmF5LmZyb20oYXJncylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5lbmNvZGUpIDogaS5lbmNvZGUpLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5kZWNvZGUpIDogaS5kZWNvZGUpLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0c1tpXSkgfHwgZGlnaXRzW2ldICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWRpZ2l0c1tpXSlcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTtcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCB1dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iLCAidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8ga2V5cy50c1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gXCJAbm9ibGUvc2VjcDI1NmsxXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZVByaXZhdGVLZXkoKSB7XG4gIHJldHVybiBzZWNwMjU2azEudXRpbHMuYnl0ZXNUb0hleChzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEudXRpbHMuYnl0ZXNUb0hleChzZWNwMjU2azEuc2Nobm9yci5nZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkpO1xufVxuXG4vLyBldmVudC50c1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxMiBmcm9tIFwiQG5vYmxlL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0LFxuICBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3QsXG4gIG5vcm1hbGl6ZVVSTDogKCkgPT4gbm9ybWFsaXplVVJMLFxuICB1dGY4RGVjb2RlcjogKCkgPT4gdXRmOERlY29kZXIsXG4gIHV0ZjhFbmNvZGVyOiAoKSA9PiB1dGY4RW5jb2RlclxufSk7XG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gbm9ybWFsaXplVVJMKHVybCkge1xuICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG4gIGlmIChwLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSlcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gIGlmIChwLnBvcnQgPT09IFwiODBcIiAmJiBwLnByb3RvY29sID09PSBcIndzOlwiIHx8IHAucG9ydCA9PT0gXCI0NDNcIiAmJiBwLnByb3RvY29sID09PSBcIndzczpcIilcbiAgICBwLnBvcnQgPSBcIlwiO1xuICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gIHAuaGFzaCA9IFwiXCI7XG4gIHJldHVybiBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHNvcnRlZEFycmF5Lmxlbmd0aCAtIDE7XG4gIGxldCBtaWRQb2ludDtcbiAgbGV0IHBvc2l0aW9uID0gc3RhcnQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgcG9zaXRpb24gPSAwO1xuICB9IGVsc2UgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPCBzb3J0ZWRBcnJheVtlbmRdLmNyZWF0ZWRfYXQpIHtcbiAgICBwb3NpdGlvbiA9IGVuZCArIDE7XG4gIH0gZWxzZSBpZiAoZXZlbnQuY3JlYXRlZF9hdCA+PSBzb3J0ZWRBcnJheVtzdGFydF0uY3JlYXRlZF9hdCkge1xuICAgIHBvc2l0aW9uID0gc3RhcnQ7XG4gIH0gZWxzZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZW5kIDw9IHN0YXJ0ICsgMSkge1xuICAgICAgICBwb3NpdGlvbiA9IGVuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtaWRQb2ludCA9IE1hdGguZmxvb3Ioc3RhcnQgKyAoZW5kIC0gc3RhcnQpIC8gMik7XG4gICAgICBpZiAoc29ydGVkQXJyYXlbbWlkUG9pbnRdLmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkUG9pbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEFycmF5W21pZFBvaW50XS5jcmVhdGVkX2F0IDwgZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgICBlbmQgPSBtaWRQb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc2l0aW9uID0gbWlkUG9pbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgaWYgKHNvcnRlZEFycmF5W3Bvc2l0aW9uXT8uaWQgIT09IGV2ZW50LmlkKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnNvcnRlZEFycmF5LnNsaWNlKDAsIHBvc2l0aW9uKSxcbiAgICAgIGV2ZW50LFxuICAgICAgLi4uc29ydGVkQXJyYXkuc2xpY2UocG9zaXRpb24pXG4gICAgXTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gc29ydGVkQXJyYXkubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZFBvaW50O1xuICBsZXQgcG9zaXRpb24gPSBzdGFydDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBwb3NpdGlvbiA9IDA7XG4gIH0gZWxzZSBpZiAoZXZlbnQuY3JlYXRlZF9hdCA+IHNvcnRlZEFycmF5W2VuZF0uY3JlYXRlZF9hdCkge1xuICAgIHBvc2l0aW9uID0gZW5kICsgMTtcbiAgfSBlbHNlIGlmIChldmVudC5jcmVhdGVkX2F0IDw9IHNvcnRlZEFycmF5W3N0YXJ0XS5jcmVhdGVkX2F0KSB7XG4gICAgcG9zaXRpb24gPSBzdGFydDtcbiAgfSBlbHNlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChlbmQgPD0gc3RhcnQgKyAxKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1pZFBvaW50ID0gTWF0aC5mbG9vcihzdGFydCArIChlbmQgLSBzdGFydCkgLyAyKTtcbiAgICAgIGlmIChzb3J0ZWRBcnJheVttaWRQb2ludF0uY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRQb2ludDtcbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkQXJyYXlbbWlkUG9pbnRdLmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgIGVuZCA9IG1pZFBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSBtaWRQb2ludDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICBpZiAoc29ydGVkQXJyYXlbcG9zaXRpb25dPy5pZCAhPT0gZXZlbnQuaWQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uc29ydGVkQXJyYXkuc2xpY2UoMCwgcG9zaXRpb24pLFxuICAgICAgZXZlbnQsXG4gICAgICAuLi5zb3J0ZWRBcnJheS5zbGljZShwb3NpdGlvbilcbiAgICBdO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cblxuLy8gZXZlbnQudHNcbnZhciBLaW5kID0gLyogQF9fUFVSRV9fICovICgoS2luZDIpID0+IHtcbiAgS2luZDJbS2luZDJbXCJNZXRhZGF0YVwiXSA9IDBdID0gXCJNZXRhZGF0YVwiO1xuICBLaW5kMltLaW5kMltcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICBLaW5kMltLaW5kMltcIlJlY29tbWVuZFJlbGF5XCJdID0gMl0gPSBcIlJlY29tbWVuZFJlbGF5XCI7XG4gIEtpbmQyW0tpbmQyW1wiQ29udGFjdHNcIl0gPSAzXSA9IFwiQ29udGFjdHNcIjtcbiAgS2luZDJbS2luZDJbXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCJdID0gNF0gPSBcIkVuY3J5cHRlZERpcmVjdE1lc3NhZ2VcIjtcbiAgS2luZDJbS2luZDJbXCJFdmVudERlbGV0aW9uXCJdID0gNV0gPSBcIkV2ZW50RGVsZXRpb25cIjtcbiAgS2luZDJbS2luZDJbXCJSZWFjdGlvblwiXSA9IDddID0gXCJSZWFjdGlvblwiO1xuICBLaW5kMltLaW5kMltcIkNoYW5uZWxDcmVhdGlvblwiXSA9IDQwXSA9IFwiQ2hhbm5lbENyZWF0aW9uXCI7XG4gIEtpbmQyW0tpbmQyW1wiQ2hhbm5lbE1ldGFkYXRhXCJdID0gNDFdID0gXCJDaGFubmVsTWV0YWRhdGFcIjtcbiAgS2luZDJbS2luZDJbXCJDaGFubmVsTWVzc2FnZVwiXSA9IDQyXSA9IFwiQ2hhbm5lbE1lc3NhZ2VcIjtcbiAgS2luZDJbS2luZDJbXCJDaGFubmVsSGlkZU1lc3NhZ2VcIl0gPSA0M10gPSBcIkNoYW5uZWxIaWRlTWVzc2FnZVwiO1xuICBLaW5kMltLaW5kMltcIkNoYW5uZWxNdXRlVXNlclwiXSA9IDQ0XSA9IFwiQ2hhbm5lbE11dGVVc2VyXCI7XG4gIHJldHVybiBLaW5kMjtcbn0pKEtpbmQgfHwge30pO1xuZnVuY3Rpb24gZ2V0QmxhbmtFdmVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAyNTUsXG4gICAgcHVia2V5OiBcIlwiLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgY3JlYXRlZF9hdDogMFxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICAwLFxuICAgIGV2dC5wdWJrZXksXG4gICAgZXZ0LmNyZWF0ZWRfYXQsXG4gICAgZXZ0LmtpbmQsXG4gICAgZXZ0LnRhZ3MsXG4gICAgZXZ0LmNvbnRlbnRcbiAgXSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBzZWNwMjU2azEyLnV0aWxzLmJ5dGVzVG9IZXgoZXZlbnRIYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBldmVudC5jb250ZW50ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5wdWJrZXkgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWV2ZW50LnB1YmtleS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudC50YWdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnQudGFncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0YWcgPSBldmVudC50YWdzW2ldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShldmVudCkge1xuICByZXR1cm4gc2VjcDI1NmsxMi5zY2hub3JyLnZlcmlmeVN5bmMoXG4gICAgZXZlbnQuc2lnLFxuICAgIGdldEV2ZW50SGFzaChldmVudCksXG4gICAgZXZlbnQucHVia2V5XG4gICk7XG59XG5mdW5jdGlvbiBzaWduRXZlbnQoZXZlbnQsIGtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxMi51dGlscy5ieXRlc1RvSGV4KFxuICAgIHNlY3AyNTZrMTIuc2Nobm9yci5zaWduU3luYyhnZXRFdmVudEhhc2goZXZlbnQpLCBrZXkpXG4gICk7XG59XG5cbi8vIGZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgbGV0IHZhbHVlcyA9IGZpbHRlcltgIyR7dGFnTmFtZX1gXTtcbiAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZChcbiAgICAgICAgKFt0LCB2XSkgPT4gdCA9PT0gZi5zbGljZSgxKSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTFcbiAgICAgICkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5zaW5jZSAmJiBldmVudC5jcmVhdGVkX2F0IDwgZmlsdGVyLnNpbmNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID49IGZpbHRlci51bnRpbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hGaWx0ZXJzKGZpbHRlcnMsIGV2ZW50KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXRjaEZpbHRlcihmaWx0ZXJzW2ldLCBldmVudCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZha2Vqc29uLnRzXG52YXIgZmFrZWpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFrZWpzb25fZXhwb3J0cywge1xuICBnZXRIZXg2NDogKCkgPT4gZ2V0SGV4NjQsXG4gIGdldEludDogKCkgPT4gZ2V0SW50LFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gZ2V0U3Vic2NyaXB0aW9uSWQsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4gbWF0Y2hFdmVudElkLFxuICBtYXRjaEV2ZW50S2luZDogKCkgPT4gbWF0Y2hFdmVudEtpbmQsXG4gIG1hdGNoRXZlbnRQdWJrZXk6ICgpID0+IG1hdGNoRXZlbnRQdWJrZXlcbn0pO1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRJbnQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aDtcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuICsgMztcbiAgbGV0IHNsaWNlZCA9IGpzb24uc2xpY2UoaWR4KTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNsaWNlZC5pbmRleE9mKFwiLFwiKSwgc2xpY2VkLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KHNsaWNlZC5zbGljZSgwLCBlbmQpLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50SWQoanNvbiwgaWQpIHtcbiAgcmV0dXJuIGlkID09PSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudFB1YmtleShqc29uLCBwdWJrZXkpIHtcbiAgcmV0dXJuIHB1YmtleSA9PT0gZ2V0SGV4NjQoanNvbiwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50S2luZChqc29uLCBraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBnZXRJbnQoanNvbiwgXCJraW5kXCIpO1xufVxuXG4vLyByZWxheS50c1xuZnVuY3Rpb24gcmVsYXlJbml0KHVybCkge1xuICB2YXIgd3M7XG4gIHZhciByZXNvbHZlQ2xvc2U7XG4gIHZhciBzZXRPcGVuO1xuICB2YXIgdW50aWxPcGVuID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRPcGVuID0gcmVzb2x2ZTtcbiAgfSk7XG4gIHZhciBvcGVuU3VicyA9IHt9O1xuICB2YXIgbGlzdGVuZXJzID0ge1xuICAgIGNvbm5lY3Q6IFtdLFxuICAgIGRpc2Nvbm5lY3Q6IFtdLFxuICAgIGVycm9yOiBbXSxcbiAgICBub3RpY2U6IFtdXG4gIH07XG4gIHZhciBzdWJMaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIHB1Ykxpc3RlbmVycyA9IHt9O1xuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0UmVsYXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHdzID0gbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuY29ubmVjdC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHNldE9wZW4oKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHdzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5lcnJvci5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICAgIHdzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5kaXNjb25uZWN0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzb2x2ZUNsb3NlICYmIHJlc29sdmVDbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIGxldCBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgbGV0IGhhbmRsZU5leHRJbnRlcnZhbDtcbiAgICAgIHdzLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgIGluY29taW5nTWVzc2FnZVF1ZXVlLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYgKCFoYW5kbGVOZXh0SW50ZXJ2YWwpIHtcbiAgICAgICAgICBoYW5kbGVOZXh0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChoYW5kbGVOZXh0LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZU5leHQoKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ01lc3NhZ2VRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGhhbmRsZU5leHRJbnRlcnZhbCk7XG4gICAgICAgICAgaGFuZGxlTmV4dEludGVydmFsID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzb24gPSBpbmNvbWluZ01lc3NhZ2VRdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICAgICAgaWYgKHN1YmlkKSB7XG4gICAgICAgICAgbGV0IHsgYWxyZWFkeUhhdmVFdmVudCB9ID0gb3BlblN1YnNbc3ViaWRdO1xuICAgICAgICAgIGlmIChhbHJlYWR5SGF2ZUV2ZW50ICYmIGFscmVhZHlIYXZlRXZlbnQoZ2V0SGV4NjQoanNvbiwgXCJpZFwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgc3dpdGNoIChkYXRhWzBdKSB7XG4gICAgICAgICAgICBjYXNlIFwiRVZFTlRcIjpcbiAgICAgICAgICAgICAgbGV0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZGF0YVsyXTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXZlbnQoZXZlbnQpICYmIG9wZW5TdWJzW2lkXSAmJiAob3BlblN1YnNbaWRdLnNraXBWZXJpZmljYXRpb24gfHwgdmVyaWZ5U2lnbmF0dXJlKGV2ZW50KSkgJiYgbWF0Y2hGaWx0ZXJzKG9wZW5TdWJzW2lkXS5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgICAgICAgICBvcGVuU3Vic1tpZF07XG4gICAgICAgICAgICAgICAgKHN1Ykxpc3RlbmVyc1tpZF0/LmV2ZW50IHx8IFtdKS5mb3JFYWNoKChjYikgPT4gY2IoZXZlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgICAgIGxldCBpZDIgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAoc3ViTGlzdGVuZXJzW2lkMl0/LmVvc2UgfHwgW10pLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICAgICAgbGV0IGlkMiA9IGRhdGFbMV07XG4gICAgICAgICAgICAgIGxldCBvayA9IGRhdGFbMl07XG4gICAgICAgICAgICAgIGxldCByZWFzb24gPSBkYXRhWzNdIHx8IFwiXCI7XG4gICAgICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgICAgICBwdWJMaXN0ZW5lcnNbaWQyXT8ub2suZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHViTGlzdGVuZXJzW2lkMl0/LmZhaWxlZC5mb3JFYWNoKChjYikgPT4gY2IocmVhc29uKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICAgICAgbGV0IG5vdGljZSA9IGRhdGFbMV07XG4gICAgICAgICAgICAgIGxpc3RlbmVycy5ub3RpY2UuZm9yRWFjaCgoY2IpID0+IGNiKG5vdGljZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIGlmICh3cz8ucmVhZHlTdGF0ZSAmJiB3cy5yZWFkeVN0YXRlID09PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGF3YWl0IGNvbm5lY3RSZWxheSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHRyeVNlbmQocGFyYW1zKSB7XG4gICAgbGV0IG1zZyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgYXdhaXQgdW50aWxPcGVuO1xuICAgIHRyeSB7XG4gICAgICB3cy5zZW5kKG1zZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdWIgPSAoZmlsdGVycywge1xuICAgIHNraXBWZXJpZmljYXRpb24gPSBmYWxzZSxcbiAgICBhbHJlYWR5SGF2ZUV2ZW50ID0gbnVsbCxcbiAgICBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKVxuICB9ID0ge30pID0+IHtcbiAgICBsZXQgc3ViaWQgPSBpZDtcbiAgICBvcGVuU3Vic1tzdWJpZF0gPSB7XG4gICAgICBpZDogc3ViaWQsXG4gICAgICBmaWx0ZXJzLFxuICAgICAgc2tpcFZlcmlmaWNhdGlvbixcbiAgICAgIGFscmVhZHlIYXZlRXZlbnRcbiAgICB9O1xuICAgIHRyeVNlbmQoW1wiUkVRXCIsIHN1YmlkLCAuLi5maWx0ZXJzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1YjogKG5ld0ZpbHRlcnMsIG5ld09wdHMgPSB7fSkgPT4gc3ViKG5ld0ZpbHRlcnMgfHwgZmlsdGVycywge1xuICAgICAgICBza2lwVmVyaWZpY2F0aW9uOiBuZXdPcHRzLnNraXBWZXJpZmljYXRpb24gfHwgc2tpcFZlcmlmaWNhdGlvbixcbiAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbmV3T3B0cy5hbHJlYWR5SGF2ZUV2ZW50IHx8IGFscmVhZHlIYXZlRXZlbnQsXG4gICAgICAgIGlkOiBzdWJpZFxuICAgICAgfSksXG4gICAgICB1bnN1YjogKCkgPT4ge1xuICAgICAgICBkZWxldGUgb3BlblN1YnNbc3ViaWRdO1xuICAgICAgICBkZWxldGUgc3ViTGlzdGVuZXJzW3N1YmlkXTtcbiAgICAgICAgdHJ5U2VuZChbXCJDTE9TRVwiLCBzdWJpZF0pO1xuICAgICAgfSxcbiAgICAgIG9uOiAodHlwZSwgY2IpID0+IHtcbiAgICAgICAgc3ViTGlzdGVuZXJzW3N1YmlkXSA9IHN1Ykxpc3RlbmVyc1tzdWJpZF0gfHwge1xuICAgICAgICAgIGV2ZW50OiBbXSxcbiAgICAgICAgICBlb3NlOiBbXVxuICAgICAgICB9O1xuICAgICAgICBzdWJMaXN0ZW5lcnNbc3ViaWRdW3R5cGVdLnB1c2goY2IpO1xuICAgICAgfSxcbiAgICAgIG9mZjogKHR5cGUsIGNiKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lcnMyID0gc3ViTGlzdGVuZXJzW3N1YmlkXTtcbiAgICAgICAgbGV0IGlkeCA9IGxpc3RlbmVyczJbdHlwZV0uaW5kZXhPZihjYik7XG4gICAgICAgIGlmIChpZHggPj0gMClcbiAgICAgICAgICBsaXN0ZW5lcnMyW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgdXJsLFxuICAgIHN1YixcbiAgICBvbjogKHR5cGUsIGNiKSA9PiB7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0ucHVzaChjYik7XG4gICAgICBpZiAodHlwZSA9PT0gXCJjb25uZWN0XCIgJiYgd3M/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9mZjogKHR5cGUsIGNiKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSBsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihjYik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICBsaXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9LFxuICAgIGxpc3Q6IChmaWx0ZXJzLCBvcHRzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IHMgPSBzdWIoZmlsdGVycywgb3B0cyk7XG4gICAgICBsZXQgZXZlbnRzID0gW107XG4gICAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzLnVuc3ViKCk7XG4gICAgICAgIHJlc29sdmUoZXZlbnRzKTtcbiAgICAgIH0sIDE1MDApO1xuICAgICAgcy5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBzLnVuc3ViKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGdldDogKGZpbHRlciwgb3B0cykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBzID0gc3ViKFtmaWx0ZXJdLCBvcHRzKTtcbiAgICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMudW5zdWIoKTtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH0sIDE1MDApO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBzLnVuc3ViKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBwdWJsaXNoKGV2ZW50KSB7XG4gICAgICBpZiAoIWV2ZW50LmlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV2ZW50ICR7ZXZlbnR9IGhhcyBubyBpZGApO1xuICAgICAgbGV0IGlkID0gZXZlbnQuaWQ7XG4gICAgICB2YXIgc2VudCA9IGZhbHNlO1xuICAgICAgdmFyIG11c3RNb25pdG9yID0gZmFsc2U7XG4gICAgICB0cnlTZW5kKFtcIkVWRU5UXCIsIGV2ZW50XSkudGhlbigoKSA9PiB7XG4gICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICBpZiAobXVzdE1vbml0b3IpIHtcbiAgICAgICAgICBzdGFydE1vbml0b3JpbmcoKTtcbiAgICAgICAgICBtdXN0TW9uaXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0TW9uaXRvcmluZyA9ICgpID0+IHtcbiAgICAgICAgbGV0IG1vbml0b3IgPSBzdWIoW3sgaWRzOiBbaWRdIH1dLCB7XG4gICAgICAgICAgaWQ6IGBtb25pdG9yLSR7aWQuc2xpY2UoMCwgNSl9YFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHdpbGxVbnN1YiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIDtcbiAgICAgICAgICAocHViTGlzdGVuZXJzW2lkXT8uZmFpbGVkIHx8IFtdKS5mb3JFYWNoKFxuICAgICAgICAgICAgKGNiKSA9PiBjYihcImV2ZW50IG5vdCBzZWVuIGFmdGVyIDUgc2Vjb25kc1wiKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbW9uaXRvci51bnN1YigpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICBtb25pdG9yLm9uKFwiZXZlbnRcIiwgKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3aWxsVW5zdWIpO1xuICAgICAgICAgIChwdWJMaXN0ZW5lcnNbaWRdPy5zZWVuIHx8IFtdKS5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uOiAodHlwZSwgY2IpID0+IHtcbiAgICAgICAgICBwdWJMaXN0ZW5lcnNbaWRdID0gcHViTGlzdGVuZXJzW2lkXSB8fCB7XG4gICAgICAgICAgICBvazogW10sXG4gICAgICAgICAgICBzZWVuOiBbXSxcbiAgICAgICAgICAgIGZhaWxlZDogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1Ykxpc3RlbmVyc1tpZF1bdHlwZV0ucHVzaChjYik7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwic2VlblwiKSB7XG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgc3RhcnRNb25pdG9yaW5nKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG11c3RNb25pdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9mZjogKHR5cGUsIGNiKSA9PiB7XG4gICAgICAgICAgbGV0IGxpc3RlbmVyczIgPSBwdWJMaXN0ZW5lcnNbaWRdO1xuICAgICAgICAgIGlmICghbGlzdGVuZXJzMilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBsZXQgaWR4ID0gbGlzdGVuZXJzMlt0eXBlXS5pbmRleE9mKGNiKTtcbiAgICAgICAgICBpZiAoaWR4ID49IDApXG4gICAgICAgICAgICBsaXN0ZW5lcnMyW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgY29ubmVjdCxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZUNsb3NlID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgIHJldHVybiB3cz8ucmVhZHlTdGF0ZSA/PyAzO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcG9vbC50c1xudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyB7XG4gIF9jb25uO1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0UmVsYXlzID0gW10pIHtcbiAgICB0aGlzLl9jb25uID0ge307XG4gICAgZGVmYXVsdFJlbGF5cy5mb3JFYWNoKHRoaXMuZW5zdXJlUmVsYXkpO1xuICB9XG4gIGVuc3VyZVJlbGF5KHVybCkge1xuICAgIGNvbnN0IG5tID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9jb25uW25tXTtcbiAgICBpZiAoZXhpc3RpbmcpXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgY29uc3QgcmVsYXkgPSByZWxheUluaXQobm0pO1xuICAgIHRoaXMuX2Nvbm5bbm1dID0gcmVsYXk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIHN1YihyZWxheXMsIGZpbHRlcnMsIG9wdHMpIHtcbiAgICBsZXQgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgbW9kaWZpZWRPcHRzID0gb3B0cyB8fCB7fTtcbiAgICBtb2RpZmllZE9wdHMuYWxyZWFkeUhhdmVFdmVudCA9IChpZCkgPT4gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgcmV0dXJuIHJlbGF5cy5tYXAoKHJlbGF5KSA9PiB7XG4gICAgICBsZXQgciA9IHRoaXMuX2Nvbm5bcmVsYXldO1xuICAgICAgaWYgKCFyKVxuICAgICAgICByZXR1cm4gYmFkU3ViKCk7XG4gICAgICBsZXQgcyA9IHIuc3ViKGZpbHRlcnMsIG1vZGlmaWVkT3B0cyk7XG4gICAgICBzLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiBfa25vd25JZHMuYWRkKGV2ZW50LmlkKSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9KTtcbiAgfVxuICBnZXQocmVsYXlzLCBmaWx0ZXIsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBzdWJzID0gdGhpcy5zdWIocmVsYXlzLCBbZmlsdGVyXSwgb3B0cyk7XG4gICAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4gc3ViLnVuc3ViKCksIDE1MDApO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfSk7XG4gICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIyKSA9PiB7XG4gICAgICAgICAgICBzdWIyLnVuc3ViKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdChyZWxheXMsIGZpbHRlcnMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgbGV0IG1vZGlmaWVkT3B0cyA9IG9wdHMgfHwge307XG4gICAgICBtb2RpZmllZE9wdHMuYWxyZWFkeUhhdmVFdmVudCA9IChpZCkgPT4gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgICBsZXQgZXZlbnRzID0gW107XG4gICAgICBsZXQgc3VicyA9IHRoaXMuc3ViKHJlbGF5cywgZmlsdGVycywgbW9kaWZpZWRPcHRzKTtcbiAgICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiBzdWIudW5zdWIoKSwgMTUwMCk7XG4gICAgICAgIHJlc29sdmUoZXZlbnRzKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IHBlbmRpbmdFb3NlcyA9IHJlbGF5cy5sZW5ndGg7XG4gICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWIub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgICBwZW5kaW5nRW9zZXMtLTtcbiAgICAgICAgICBpZiAocGVuZGluZ0Vvc2VzID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBzdWJzLmZvckVhY2goKHN1YjIpID0+IHtcbiAgICAgICAgICAgICAgc3ViMi51bnN1YigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCkge1xuICAgIHJldHVybiByZWxheXMubWFwKChyZWxheSkgPT4ge1xuICAgICAgbGV0IHIgPSB0aGlzLl9jb25uW3JlbGF5XTtcbiAgICAgIGlmICghcilcbiAgICAgICAgcmV0dXJuIGJhZFB1YihyZWxheSk7XG4gICAgICBsZXQgcyA9IHIucHVibGlzaChldmVudCk7XG4gICAgICByZXR1cm4gcztcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJhZFN1YigpIHtcbiAgcmV0dXJuIHtcbiAgICBvbigpIHtcbiAgICB9LFxuICAgIG9mZigpIHtcbiAgICB9LFxuICAgIHN1YigpIHtcbiAgICAgIHJldHVybiBiYWRTdWIoKTtcbiAgICB9LFxuICAgIHVuc3ViKCkge1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJhZFB1YihyZWxheSkge1xuICByZXR1cm4ge1xuICAgIG9uKHR5cCwgY2IpIHtcbiAgICAgIGlmICh0eXAgPT09IFwiZmFpbGVkXCIpXG4gICAgICAgIGNiKGByZWxheSAke3JlbGF5fSBub3QgY29ubmVjdGVkYCk7XG4gICAgfSxcbiAgICBvZmYoKSB7XG4gICAgfVxuICB9O1xufVxuXG4vLyBuaXAwNC50c1xudmFyIG5pcDA0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdCxcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdFxufSk7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEzIGZyb20gXCJAbm9ibGUvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQocHJpdmtleSwgcHVia2V5LCB0ZXh0KSB7XG4gIGNvbnN0IGtleSA9IHNlY3AyNTZrMTMuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgaXYgPSBVaW50OEFycmF5LmZyb20ocmFuZG9tQnl0ZXMoMTYpKTtcbiAgbGV0IHBsYWludGV4dCA9IHV0ZjhFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgbGV0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbm9ybWFsaXplZEtleSxcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gICAgZmFsc2UsXG4gICAgW1wiZW5jcnlwdFwiXVxuICApO1xuICBsZXQgY2lwaGVydGV4dCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiLCBpdiB9LFxuICAgIGNyeXB0b0tleSxcbiAgICBwbGFpbnRleHRcbiAgKTtcbiAgbGV0IGN0YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KSk7XG4gIGxldCBpdmI2NCA9IGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoaXYuYnVmZmVyKSk7XG4gIHJldHVybiBgJHtjdGI2NH0/aXY9JHtpdmI2NH1gO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChwcml2a2V5LCBwdWJrZXksIGRhdGEpIHtcbiAgbGV0IFtjdGI2NCwgaXZiNjRdID0gZGF0YS5zcGxpdChcIj9pdj1cIik7XG4gIGxldCBrZXkgPSBzZWNwMjU2azEzLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBsZXQgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBjcnlwdG9LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInJhd1wiLFxuICAgIG5vcm1hbGl6ZWRLZXksXG4gICAgeyBuYW1lOiBcIkFFUy1DQkNcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcImRlY3J5cHRcIl1cbiAgKTtcbiAgbGV0IGNpcGhlcnRleHQgPSBiYXNlNjQuZGVjb2RlKGN0YjY0KTtcbiAgbGV0IGl2ID0gYmFzZTY0LmRlY29kZShpdmI2NCk7XG4gIGxldCBwbGFpbnRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoXG4gICAgeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXYgfSxcbiAgICBjcnlwdG9LZXksXG4gICAgY2lwaGVydGV4dFxuICApO1xuICBsZXQgdGV4dCA9IHV0ZjhEZWNvZGVyLmRlY29kZShwbGFpbnRleHQpO1xuICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRYKGtleSkge1xuICByZXR1cm4ga2V5LnNsaWNlKDEsIDMzKTtcbn1cblxuLy8gbmlwMDUudHNcbnZhciBuaXAwNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNV9leHBvcnRzLCB7XG4gIHF1ZXJ5UHJvZmlsZTogKCkgPT4gcXVlcnlQcm9maWxlLFxuICBzZWFyY2hEb21haW46ICgpID0+IHNlYXJjaERvbWFpbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvblxufSk7XG52YXIgX2ZldGNoO1xudHJ5IHtcbiAgX2ZldGNoID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24oZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2ggPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VhcmNoRG9tYWluKGRvbWFpbiwgcXVlcnkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2goYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke3F1ZXJ5fWApKS5qc29uKCk7XG4gICAgcmV0dXJuIHJlcy5uYW1lcztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcXVlcnlQcm9maWxlKGZ1bGxuYW1lKSB7XG4gIGxldCBbbmFtZSwgZG9tYWluXSA9IGZ1bGxuYW1lLnNwbGl0KFwiQFwiKTtcbiAgaWYgKCFkb21haW4pIHtcbiAgICBkb21haW4gPSBuYW1lO1xuICAgIG5hbWUgPSBcIl9cIjtcbiAgfVxuICBpZiAoIW5hbWUubWF0Y2goL15bQS1aYS16MC05LV9dKyQvKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2goYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YCkpLmpzb24oKTtcbiAgaWYgKCFyZXM/Lm5hbWVzPy5bbmFtZV0pXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwdWJrZXkgPSByZXMubmFtZXNbbmFtZV07XG4gIGxldCByZWxheXMgPSByZXMucmVsYXlzPy5bcHVia2V5XSB8fCBbXTtcbiAgcmV0dXJuIHtcbiAgICBwdWJrZXksXG4gICAgcmVsYXlzXG4gIH07XG59XG5cbi8vIG5pcDA2LnRzXG52YXIgbmlwMDZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDZfZXhwb3J0cywge1xuICBnZW5lcmF0ZVNlZWRXb3JkczogKCkgPT4gZ2VuZXJhdGVTZWVkV29yZHMsXG4gIHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzOiAoKSA9PiBwcml2YXRlS2V5RnJvbVNlZWRXb3JkcyxcbiAgdmFsaWRhdGVXb3JkczogKCkgPT4gdmFsaWRhdGVXb3Jkc1xufSk7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azE0IGZyb20gXCJAbm9ibGUvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyB3b3JkbGlzdCB9IGZyb20gXCJAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2VuZ2xpc2guanNcIjtcbmltcG9ydCB7XG4gIGdlbmVyYXRlTW5lbW9uaWMsXG4gIG1uZW1vbmljVG9TZWVkU3luYyxcbiAgdmFsaWRhdGVNbmVtb25pY1xufSBmcm9tIFwiQHNjdXJlL2JpcDM5XCI7XG5pbXBvcnQgeyBIREtleSB9IGZyb20gXCJAc2N1cmUvYmlwMzJcIjtcbmZ1bmN0aW9uIHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzKG1uZW1vbmljLCBwYXNzcGhyYXNlKSB7XG4gIGxldCByb290ID0gSERLZXkuZnJvbU1hc3RlclNlZWQobW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlKSk7XG4gIGxldCBwcml2YXRlS2V5ID0gcm9vdC5kZXJpdmUoYG0vNDQnLzEyMzcnLzAnLzAvMGApLnByaXZhdGVLZXk7XG4gIGlmICghcHJpdmF0ZUtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZGVyaXZlIHByaXZhdGUga2V5XCIpO1xuICByZXR1cm4gc2VjcDI1NmsxNC51dGlscy5ieXRlc1RvSGV4KHByaXZhdGVLZXkpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTZWVkV29yZHMoKSB7XG4gIHJldHVybiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlV29yZHMod29yZHMpIHtcbiAgcmV0dXJuIHZhbGlkYXRlTW5lbW9uaWMod29yZHMsIHdvcmRsaXN0KTtcbn1cblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIGRlY29kZTogKCkgPT4gZGVjb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBuc2VjRW5jb2RlXG59KTtcbmltcG9ydCAqIGFzIHNlY3AyNTZrMTUgZnJvbSBcIkBub2JsZS9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIEJlY2gzMk1heFNpemUgPSA1ZTM7XG5mdW5jdGlvbiBkZWNvZGUobmlwMTkpIHtcbiAgbGV0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMyLmRlY29kZShuaXAxOSwgQmVjaDMyTWF4U2l6ZSk7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYmVjaDMyLmZyb21Xb3Jkcyh3b3JkcykpO1xuICBpZiAocHJlZml4ID09PSBcIm5wcm9maWxlXCIpIHtcbiAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJucHJvZmlsZVwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBwdWJrZXk6IHNlY3AyNTZrMTUudXRpbHMuYnl0ZXNUb0hleCh0bHZbMF1bMF0pLFxuICAgICAgICByZWxheXM6IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmIChwcmVmaXggPT09IFwibmV2ZW50XCIpIHtcbiAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibmV2ZW50XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBzZWNwMjU2azE1LnV0aWxzLmJ5dGVzVG9IZXgodGx2WzBdWzBdKSxcbiAgICAgICAgcmVsYXlzOiB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpZiAocHJlZml4ID09PSBcIm5zZWNcIiB8fCBwcmVmaXggPT09IFwibnB1YlwiIHx8IHByZWZpeCA9PT0gXCJub3RlXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IHNlY3AyNTZrMTUudXRpbHMuYnl0ZXNUb0hleChkYXRhKSB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcmVmaXggJHtwcmVmaXh9YCk7XG59XG5mdW5jdGlvbiBwYXJzZVRMVihkYXRhKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgbGV0IHJlc3QgPSBkYXRhO1xuICB3aGlsZSAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHQgPSByZXN0WzBdO1xuICAgIGxldCBsID0gcmVzdFsxXTtcbiAgICBsZXQgdiA9IHJlc3Quc2xpY2UoMiwgMiArIGwpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDIgKyBsKTtcbiAgICBpZiAodi5sZW5ndGggPCBsKVxuICAgICAgY29udGludWU7XG4gICAgcmVzdWx0W3RdID0gcmVzdWx0W3RdIHx8IFtdO1xuICAgIHJlc3VsdFt0XS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuc2VjRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuc2VjXCIsIGhleCk7XG59XG5mdW5jdGlvbiBucHViRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJucHViXCIsIGhleCk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleCk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGhleCkge1xuICBsZXQgZGF0YSA9IHNlY3AyNTZrMTUudXRpbHMuaGV4VG9CeXRlcyhoZXgpO1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBucHJvZmlsZUVuY29kZShwcm9maWxlKSB7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbc2VjcDI1NmsxNS51dGlscy5oZXhUb0J5dGVzKHByb2ZpbGUucHVia2V5KV0sXG4gICAgMTogKHByb2ZpbGUucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUoXCJucHJvZmlsZVwiLCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBuZXZlbnRFbmNvZGUoZXZlbnQpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtzZWNwMjU2azE1LnV0aWxzLmhleFRvQnl0ZXMoZXZlbnQuaWQpXSxcbiAgICAxOiAoZXZlbnQucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUoXCJuZXZlbnRcIiwgd29yZHMsIEJlY2gzMk1heFNpemUpO1xufVxuZnVuY3Rpb24gZW5jb2RlVExWKHRsdikge1xuICBsZXQgZW50cmllcyA9IFtdO1xuICBPYmplY3QuZW50cmllcyh0bHYpLmZvckVhY2goKFt0LCB2c10pID0+IHtcbiAgICB2cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSBuZXcgVWludDhBcnJheSh2Lmxlbmd0aCArIDIpO1xuICAgICAgZW50cnkuc2V0KFtwYXJzZUludCh0KV0sIDApO1xuICAgICAgZW50cnkuc2V0KFt2Lmxlbmd0aF0sIDEpO1xuICAgICAgZW50cnkuc2V0KHYsIDIpO1xuICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzZWNwMjU2azE1LnV0aWxzLmNvbmNhdEJ5dGVzKC4uLmVudHJpZXMpO1xufVxuXG4vLyBuaXAyNi50c1xudmFyIG5pcDI2X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI2X2V4cG9ydHMsIHtcbiAgY3JlYXRlRGVsZWdhdGlvbjogKCkgPT4gY3JlYXRlRGVsZWdhdGlvbixcbiAgZ2V0RGVsZWdhdG9yOiAoKSA9PiBnZXREZWxlZ2F0b3Jcbn0pO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxNiBmcm9tIFwiQG5vYmxlL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmZ1bmN0aW9uIGNyZWF0ZURlbGVnYXRpb24ocHJpdmF0ZUtleSwgcGFyYW1ldGVycykge1xuICBsZXQgY29uZGl0aW9ucyA9IFtdO1xuICBpZiAoKHBhcmFtZXRlcnMua2luZCB8fCAtMSkgPj0gMClcbiAgICBjb25kaXRpb25zLnB1c2goYGtpbmQ9JHtwYXJhbWV0ZXJzLmtpbmR9YCk7XG4gIGlmIChwYXJhbWV0ZXJzLnVudGlsKVxuICAgIGNvbmRpdGlvbnMucHVzaChgY3JlYXRlZF9hdDwke3BhcmFtZXRlcnMudW50aWx9YCk7XG4gIGlmIChwYXJhbWV0ZXJzLnNpbmNlKVxuICAgIGNvbmRpdGlvbnMucHVzaChgY3JlYXRlZF9hdD4ke3BhcmFtZXRlcnMuc2luY2V9YCk7XG4gIGxldCBjb25kID0gY29uZGl0aW9ucy5qb2luKFwiJlwiKTtcbiAgaWYgKGNvbmQgPT09IFwiXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVmdXNpbmcgdG8gY3JlYXRlIGEgZGVsZWdhdGlvbiB3aXRob3V0IGFueSBjb25kaXRpb25zXCIpO1xuICBsZXQgc2lnaGFzaCA9IHNoYTI1NjIoXG4gICAgdXRmOEVuY29kZXIuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7cGFyYW1ldGVycy5wdWJrZXl9OiR7Y29uZH1gKVxuICApO1xuICBsZXQgc2lnID0gc2VjcDI1NmsxNi51dGlscy5ieXRlc1RvSGV4KFxuICAgIHNlY3AyNTZrMTYuc2Nobm9yci5zaWduU3luYyhzaWdoYXNoLCBwcml2YXRlS2V5KVxuICApO1xuICByZXR1cm4ge1xuICAgIGZyb206IGdldFB1YmxpY0tleShwcml2YXRlS2V5KSxcbiAgICB0bzogcGFyYW1ldGVycy5wdWJrZXksXG4gICAgY29uZCxcbiAgICBzaWdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlbGVnYXRvcihldmVudCkge1xuICBsZXQgdGFnID0gZXZlbnQudGFncy5maW5kKCh0YWcyKSA9PiB0YWcyWzBdID09PSBcImRlbGVnYXRpb25cIiAmJiB0YWcyLmxlbmd0aCA+PSA0KTtcbiAgaWYgKCF0YWcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwdWJrZXkgPSB0YWdbMV07XG4gIGxldCBjb25kID0gdGFnWzJdO1xuICBsZXQgc2lnID0gdGFnWzNdO1xuICBsZXQgY29uZGl0aW9ucyA9IGNvbmQuc3BsaXQoXCImXCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2tleSwgb3BlcmF0b3IsIHZhbHVlXSA9IGNvbmRpdGlvbnNbaV0uc3BsaXQoL1xcYi8pO1xuICAgIGlmIChrZXkgPT09IFwia2luZFwiICYmIG9wZXJhdG9yID09PSBcIj1cIiAmJiBldmVudC5raW5kID09PSBwYXJzZUludCh2YWx1ZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBlbHNlIGlmIChrZXkgPT09IFwiY3JlYXRlZF9hdFwiICYmIG9wZXJhdG9yID09PSBcIjxcIiAmJiBldmVudC5jcmVhdGVkX2F0IDwgcGFyc2VJbnQodmFsdWUpKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZSBpZiAoa2V5ID09PSBcImNyZWF0ZWRfYXRcIiAmJiBvcGVyYXRvciA9PT0gXCI+XCIgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IHBhcnNlSW50KHZhbHVlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzaWdoYXNoID0gc2hhMjU2MihcbiAgICB1dGY4RW5jb2Rlci5lbmNvZGUoYG5vc3RyOmRlbGVnYXRpb246JHtldmVudC5wdWJrZXl9OiR7Y29uZH1gKVxuICApO1xuICBpZiAoIXNlY3AyNTZrMTYuc2Nobm9yci52ZXJpZnlTeW5jKHNpZywgc2lnaGFzaCwgcHVia2V5KSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHB1YmtleTtcbn1cblxuLy8gaW5kZXgudHNcbmltcG9ydCAqIGFzIHNlY3AyNTZrMTcgZnJvbSBcIkBub2JsZS9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuc2VjcDI1NmsxNy51dGlscy5obWFjU2hhMjU2U3luYyA9IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoc2hhMjU2Mywga2V5LCBzZWNwMjU2azE3LnV0aWxzLmNvbmNhdEJ5dGVzKC4uLm1zZ3MpKTtcbnNlY3AyNTZrMTcudXRpbHMuc2hhMjU2U3luYyA9ICguLi5tc2dzKSA9PiBzaGEyNTYzKHNlY3AyNTZrMTcudXRpbHMuY29uY2F0Qnl0ZXMoLi4ubXNncykpO1xuZXhwb3J0IHtcbiAgS2luZCxcbiAgU2ltcGxlUG9vbCxcbiAgZmFrZWpzb25fZXhwb3J0cyBhcyBmaixcbiAgZ2VuZXJhdGVQcml2YXRlS2V5LFxuICBnZXRCbGFua0V2ZW50LFxuICBnZXRFdmVudEhhc2gsXG4gIGdldFB1YmxpY0tleSxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1hdGNoRmlsdGVycyxcbiAgbmlwMDRfZXhwb3J0cyBhcyBuaXAwNCxcbiAgbmlwMDVfZXhwb3J0cyBhcyBuaXAwNSxcbiAgbmlwMDZfZXhwb3J0cyBhcyBuaXAwNixcbiAgbmlwMTlfZXhwb3J0cyBhcyBuaXAxOSxcbiAgbmlwMjZfZXhwb3J0cyBhcyBuaXAyNixcbiAgcmVsYXlJbml0LFxuICBzZXJpYWxpemVFdmVudCxcbiAgc2lnbkV2ZW50LFxuICB1dGlsc19leHBvcnRzIGFzIHV0aWxzLFxuICB2YWxpZGF0ZUV2ZW50LFxuICB2ZXJpZnlTaWduYXR1cmVcbn07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuIiwgImV4cG9ydCBjb25zdCBjcnlwdG8gPSB7XG4gICAgbm9kZTogdW5kZWZpbmVkLFxuICAgIHdlYjogdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIHNlbGYgPyBzZWxmLmNyeXB0byA6IHVuZGVmaW5lZCxcbn07XG4iLCAiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVGhlIGltcG9ydCBoZXJlIGlzIHZpYSB0aGUgcGFja2FnZSBuYW1lLiBUaGlzIGlzIHRvIGVuc3VyZVxuLy8gdGhhdCBleHBvcnRzIG1hcHBpbmcvcmVzb2x1dGlvbiBkb2VzIGZhbGwgaW50byBwbGFjZS5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGVyZSBpcyBhbG1vc3Qgbm8gYmlnIGVuZGlhbiBoYXJkd2FyZSwgYnV0IGpzIHR5cGVkIGFycmF5cyB1c2VzIHBsYXRmb3JtIHNwZWNpZmljIGVuZGlhbm5lc3MuXG4vLyBTbywganVzdCB0byBiZSBzdXJlIG5vdCB0byBjb3JydXB0IGFueXRoaW5nLlxuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGhhc2hDID0gKG1lc3NhZ2UpID0+IGhhc2hDb25zdHJ1Y3RvcigpLnVwZGF0ZSh0b0J5dGVzKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5ub2RlLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydC5oYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbi8vIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG5jb25zdCBSaG8gPSBuZXcgVWludDhBcnJheShbNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOF0pO1xuY29uc3QgSWQgPSBVaW50OEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sIChfLCBpKSA9PiBpKTtcbmNvbnN0IFBpID0gSWQubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KTtcbmxldCBpZHhMID0gW0lkXTtcbmxldCBpZHhSID0gW1BpXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAobGV0IGogb2YgW2lkeEwsIGlkeFJdKVxuICAgICAgICBqLnB1c2goaltpXS5tYXAoKGspID0+IFJob1trXSkpO1xuY29uc3Qgc2hpZnRzID0gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IG5ldyBVaW50OEFycmF5KGkpKTtcbmNvbnN0IHNoaWZ0c0wgPSBpZHhMLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IHNoaWZ0c1IgPSBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHNbaV1bal0pKTtcbmNvbnN0IEtsID0gbmV3IFVpbnQzMkFycmF5KFsweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlXSk7XG5jb25zdCBLciA9IG5ldyBVaW50MzJBcnJheShbMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMF0pO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSk7XG4vLyBJdCdzIGNhbGxlZCBmKCkgaW4gc3BlYy5cbmZ1bmN0aW9uIGYoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDEpXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDIpXG4gICAgICAgIHJldHVybiAoeCB8IH55KSBeIHo7XG4gICAgZWxzZSBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4geCBeICh5IHwgfnopO1xufVxuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBCVUYgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuZXhwb3J0IGNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2xbZ3JvdXBdLCBoYnIgPSBLcltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0xbZ3JvdXBdLCBzciA9IHNoaWZ0c1JbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyBmKGdyb3VwLCBibCwgY2wsIGRsKSArIEJVRltybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyBmKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gcm90bChjciwgMTApIHwgMCwgY3IgPSBiciwgYnIgPSB0cjsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgdGhpcy5zZXQoKHRoaXMuaDEgKyBjbCArIGRyKSB8IDAsICh0aGlzLmgyICsgZGwgKyBlcikgfCAwLCAodGhpcy5oMyArIGVsICsgYXIpIHwgMCwgKHRoaXMuaDQgKyBhbCArIGJyKSB8IDAsICh0aGlzLmgwICsgYmwgKyBjcikgfCAwKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1zZyB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4iLCAiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbiIsICJjb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnQgY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZXhwb3J0IGZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4iLCAiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4iLCAiaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyByaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTUxMic7XG5pbXBvcnQgeyBieXRlcyBhcyBhc3NlcnRCeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvX2Fzc2VydCc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBjb25jYXRCeXRlcywgY3JlYXRlVmlldywgaGV4VG9CeXRlcywgdXRmOFRvQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCAqIGFzIHNlY3AgZnJvbSAnQG5vYmxlL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBiYXNlNThjaGVjayBhcyBiYXNlNThjaGVja2VyIH0gZnJvbSAnQHNjdXJlL2Jhc2UnO1xuc2VjcC51dGlscy5obWFjU2hhMjU2U3luYyA9IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoc2hhMjU2LCBrZXksIHNlY3AudXRpbHMuY29uY2F0Qnl0ZXMoLi4ubXNncykpO1xuY29uc3QgYmFzZTU4Y2hlY2sgPSBiYXNlNThjaGVja2VyKHNoYTI1Nik7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke2J5dGVzVG9IZXgoYnl0ZXMpfWApO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyhudW0pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpKTtcbn1cbmNvbnN0IE1BU1RFUl9TRUNSRVQgPSB1dGY4VG9CeXRlcygnQml0Y29pbiBzZWVkJyk7XG5jb25zdCBCSVRDT0lOX1ZFUlNJT05TID0geyBwcml2YXRlOiAweDA0ODhhZGU0LCBwdWJsaWM6IDB4MDQ4OGIyMWUgfTtcbmV4cG9ydCBjb25zdCBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuY29uc3QgaGFzaDE2MCA9IChkYXRhKSA9PiByaXBlbWQxNjAoc2hhMjU2KGRhdGEpKTtcbmNvbnN0IGZyb21VMzIgPSAoZGF0YSkgPT4gY3JlYXRlVmlldyhkYXRhKS5nZXRVaW50MzIoMCwgZmFsc2UpO1xuY29uc3QgdG9VMzIgPSAobikgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDIgKiogMzIgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXI9JHtufS4gU2hvdWxkIGJlIGZyb20gMCB0byAyICoqIDMyIC0gMWApO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjcmVhdGVWaWV3KGJ1Zikuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydCBjbGFzcyBIREtleSB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG9wdC5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gb3B0LnBhcmVudEZpbmdlcnByaW50IHx8IDA7XG4gICAgICAgIGlmICghdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnB1YmxpY0tleSAmJiBvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogcHVibGljS2V5IGFuZCBwcml2YXRlS2V5IGF0IHNhbWUgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkob3B0LnByaXZhdGVLZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5Qb2ludC5mcm9tSGV4KG9wdC5wdWJsaWNLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBubyBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ykhhc2ggPSBoYXNoMTYwKHRoaXMucHViS2V5KTtcbiAgICB9XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucHViSGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVTMyKHRoaXMucHViSGFzaCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICAgIH1cbiAgICBnZXQgcHViS2V5SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZLZXlCeXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCFwcml2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnByaXZhdGUsIGNvbmNhdEJ5dGVzKG5ldyBVaW50OEFycmF5KFswXSksIHByaXYpKSk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJLZXkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NYXN0ZXJTZWVkKHNlZWQsIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICBhc3NlcnRCeXRlcyhzZWVkKTtcbiAgICAgICAgaWYgKDggKiBzZWVkLmxlbmd0aCA8IDEyOCB8fCA4ICogc2VlZC5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSERLZXk6IHdyb25nIHNlZWQgbGVuZ3RoPSR7c2VlZC5sZW5ndGh9LiBTaG91bGQgYmUgYmV0d2VlbiAxMjggYW5kIDUxMiBiaXRzOyAyNTYgYml0cyBpcyBhZHZpc2VkKWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgTUFTVEVSX1NFQ1JFVCwgc2VlZCk7XG4gICAgICAgIHJldHVybiBuZXcgSERLZXkoe1xuICAgICAgICAgICAgdmVyc2lvbnMsXG4gICAgICAgICAgICBjaGFpbkNvZGU6IEkuc2xpY2UoMzIpLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogSS5zbGljZSgwLCAzMiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGJhc2U1OGtleSwgdmVyc2lvbnMgPSBCSVRDT0lOX1ZFUlNJT05TKSB7XG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IGJhc2U1OGNoZWNrLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gY3JlYXRlVmlldyhrZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0ga2V5Vmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGRlcHRoOiBrZXlCdWZmZXJbNF0sXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDoga2V5Vmlldy5nZXRVaW50MzIoNSwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZXg6IGtleVZpZXcuZ2V0VWludDMyKDksIGZhbHNlKSxcbiAgICAgICAgICAgIGNoYWluQ29kZToga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSk7XG4gICAgICAgIGNvbnN0IGlzUHJpdiA9IGtleVswXSA9PT0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHZlcnNpb25zW2lzUHJpdiA/ICdwcml2YXRlJyA6ICdwdWJsaWMnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpdikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHVibGljS2V5OiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShqc29uLnhwcml2KTtcbiAgICB9XG4gICAgZGVyaXZlKHBhdGgpIHtcbiAgICAgICAgaWYgKCEvXlttTV0nPy8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3Qgc3RhcnQgd2l0aCBcIm1cIiBvciBcIk1cIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlttTV0nPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5yZXBsYWNlKC9eW21NXSc/XFwvLywgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgbSA9IC9eKFxcZCspKCc/KSQvLmV4ZWMoYyk7XG4gICAgICAgICAgICBpZiAoIW0gfHwgbS5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hpbGQgaW5kZXg6ICR7Y31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHggPSArbVsxXTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaWR4KSB8fCBpZHggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsyXSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gSEFSREVORURfT0ZGU0VUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5kZXJpdmVDaGlsZChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgZGVyaXZlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSB8fCAhdGhpcy5jaGFpbkNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljS2V5IG9yIGNoYWluQ29kZSBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHRvVTMyKGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4ID49IEhBUkRFTkVEX09GRlNFVCkge1xuICAgICAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRCeXRlcyh0aGlzLnB1YktleSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSSA9IGhtYWMoc2hhNTEyLCB0aGlzLmNoYWluQ29kZSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNoaWxkVHdlYWsgPSBieXRlc1RvTnVtYmVyKEkuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gSS5zbGljZSgzMik7XG4gICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShjaGlsZFR3ZWFrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUd2VhayBiaWdnZXIgdGhhbiBjdXJ2ZSBvcmRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgICAgIHZlcnNpb25zOiB0aGlzLnZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlLFxuICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IHNlY3AudXRpbHMubW9kKHRoaXMucHJpdktleSArIGNoaWxkVHdlYWssIHNlY3AuQ1VSVkUubik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWNwLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGFkZGVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdC5wcml2YXRlS2V5ID0gYWRkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IHNlY3AuUG9pbnQuZnJvbUhleCh0aGlzLnB1YktleSkuYWRkKHNlY3AuUG9pbnQuZnJvbVByaXZhdGVLZXkoY2hpbGRUd2VhaykpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRlZC5lcXVhbHMoc2VjcC5Qb2ludC5aRVJPKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0d2VhayB3YXMgZXF1YWwgdG8gbmVnYXRpdmUgUCwgd2hpY2ggbWFkZSB0aGUgcmVzdWx0IGtleSBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdC5wdWJsaWNLZXkgPSBhZGRlZC50b1Jhd0J5dGVzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleShvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcml2ZUNoaWxkKGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2lnbihoYXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGVLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEJ5dGVzKGhhc2gsIDMyKTtcbiAgICAgICAgcmV0dXJuIHNlY3Auc2lnblN5bmMoaGFzaCwgdGhpcy5wcml2S2V5LCB7XG4gICAgICAgICAgICBjYW5vbmljYWw6IHRydWUsXG4gICAgICAgICAgICBkZXI6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRCeXRlcyhoYXNoLCAzMik7XG4gICAgICAgIGFzc2VydEJ5dGVzKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoa2V5LCAzMyk7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyh0b1UzMih2ZXJzaW9uKSwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuZGVwdGhdKSwgdG9VMzIodGhpcy5wYXJlbnRGaW5nZXJwcmludCksIHRvVTMyKHRoaXMuaW5kZXgpLCB0aGlzLmNoYWluQ29kZSwga2V5KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0SGFzaCwgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAoISh0aGlzLmlIYXNoIGluc3RhbmNlb2YgSGFzaCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSAodGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gdGhpcy5pSGFzaC5ibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2UgaXMgZGVzdHJveWVkJyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3RhbmNlIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgICBpZiAoIShvdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCBvdXQubGVuZ3RoICE9PSB0aGlzLm91dHB1dExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSE1BQzogSW52YWxpZCBvdXRwdXQgYnVmZmVyJyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuaG1hYy5pbml0ID0gaG1hYy5jcmVhdGU7XG4iLCAiaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XG5pbXBvcnQge1xuICAgIGdlbmVyYXRlUHJvZmlsZSxcbiAgICBnZXRQcm9maWxlcyxcbiAgICB2YWxpZGF0ZUtleSxcbn0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL3V0aWxzJztcbmltcG9ydCB7IGdldFB1YmxpY0tleSwgbmlwMjYsIG5pcDE5IH0gZnJvbSAnbm9zdHItdG9vbHMnO1xuXG5jb25zdCBzdG9yYWdlID0gYnJvd3Nlci5zdG9yYWdlLmxvY2FsO1xuXG5BbHBpbmUuZGF0YSgnZGVsZWdhdGVkJywgKCkgPT4gKHtcbiAgICBwcml2S2V5OiAnJyxcbiAgICBkdXJhdGlvbjogNyxcbiAgICBwcm9maWxlOiB7fSxcblxuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IGF3YWl0IGdlbmVyYXRlUHJvZmlsZSgnTmV3IERlbGVnYXRlJyk7XG4gICAgICAgIHRoaXMucHJvZmlsZS5kZWxlZ2F0ZSA9IHRydWU7XG4gICAgfSxcblxuICAgIG9wZW5OaXAoZXZlbnQpIHtcbiAgICAgICAgYnJvd3Nlci50YWJzLmNyZWF0ZSh7IHVybDogZXZlbnQudGFyZ2V0LmhyZWYsIGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgZ29CYWNrKCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBicm93c2VyLnJ1bnRpbWUuZ2V0VVJMKCdvcHRpb25zLmh0bWwnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgc2F2ZSgpIHtcbiAgICAgICAgbGV0IHByb2ZpbGVzID0gYXdhaXQgZ2V0UHJvZmlsZXMoKTtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGphbmtpZnkgdGhpcyBBbHBpbmUgcHJveHkgb2JqZWN0IHNvIGl0J3MgaW4gdGhlIHJpZ2h0IGZvcm1hdFxuICAgICAgICAvLyB3aGVuIHdlIHNhdmUgaXQgdG8gc3RvcmFnZVxuICAgICAgICBsZXQgcHJvZmlsZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9maWxlKSk7XG4gICAgICAgIHByb2ZpbGUuZGVsZWdhdG9yID0gZ2V0UHVibGljS2V5KHRoaXMuZGVjb2RlZFByaXZLZXkpO1xuICAgICAgICBwcm9maWxlLmRlbGVnYXRpb24gPSB0aGlzLmdldERlbGVnYXRpb24oKTtcblxuICAgICAgICBwcm9maWxlcy5wdXNoKHByb2ZpbGUpO1xuICAgICAgICBsZXQgcHJvZmlsZUluZGV4ID0gcHJvZmlsZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoeyBwcm9maWxlcywgcHJvZmlsZUluZGV4IH0pO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IGAke2Jyb3dzZXIucnVudGltZS5nZXRVUkwoXG4gICAgICAgICAgICAnb3B0aW9ucy5odG1sJ1xuICAgICAgICApfT9pbmRleD0ke3Byb2ZpbGVJbmRleH1gO1xuICAgIH0sXG5cbiAgICBnZXREZWxlZ2F0aW9uKCkge1xuICAgICAgICBsZXQgcHVia2V5ID0gZ2V0UHVibGljS2V5KHRoaXMucHJvZmlsZS5wcml2S2V5KTtcblxuICAgICAgICBsZXQgZGVsZWdhdGlvbiA9IG5pcDI2LmNyZWF0ZURlbGVnYXRpb24odGhpcy5kZWNvZGVkUHJpdktleSwge1xuICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgdW50aWw6IHRoaXMudW50aWwsXG4gICAgICAgICAgICBzaW5jZTogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgLSAxLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coZGVsZWdhdGlvbik7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0aW9uO1xuICAgIH0sXG5cbiAgICAvLyBQcm9wZXJ0aWVzXG5cbiAgICBnZXQgaXNLZXlWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlS2V5KHRoaXMucHJpdktleSk7XG4gICAgfSxcblxuICAgIGdldCB2YWxpZEtleUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0tleVZhbGlkXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6ICdyaW5nLTIgcmluZy1yb3NlLTUwMCBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1yb3NlLTUwMCBib3JkZXItdHJhbnNwYXJlbnQgZm9jdXM6Ym9yZGVyLXRyYW5zcGFyZW50JztcbiAgICB9LFxuXG4gICAgZ2V0IHVudGlsKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiB0aGlzLmR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgZGVjb2RlZFByaXZLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0tleVZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcml2S2V5LnN0YXJ0c1dpdGgoJ25zZWMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5pcDE5LmRlY29kZSh0aGlzLnByaXZLZXkpLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdktleTtcbiAgICB9LFxufSkpO1xuXG5BbHBpbmUuc3RhcnQoKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUFPLGVBQWUsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFLLENBQUM7QUFDNUQsY0FBUSxXQUFXO0FBQ25CLGNBQVEsV0FBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7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RjlELE1BQU1DLE9BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTyxJQUFJLElBQU0sQ0FBQyxJQUFJO0FBRXpDLE1BQU1DLE9BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTyxJQUFJLElBQU0sSUFBSSxJQUFNLElBQUk7QUFJbEQsTUFBTUMsWUFBVyxJQUFJLFlBQVk7QUFBQSxJQUM3QjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUNwRjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxFQUN4RixDQUFDO0FBR0QsTUFBTUMsTUFBSyxJQUFJLFlBQVk7QUFBQSxJQUN2QjtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEsSUFBWTtBQUFBLElBQVk7QUFBQSxJQUFZO0FBQUEs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QSxJQUN4QjtBQUFBLElBQVM7QUFBQSxJQUNUO0FBQUEsSUFBUTtBQUFBLElBQVE7QUFBQSxJQUFRO0FBQUEsSUFDeEIsS0FBQUE7QUFBQSxJQUFLO0FBQUEsSUFBTztBQUFBLElBQU87QUFBQSxJQUFPO0FBQUEsSUFBTztBQUFBLElBQU87QUFBQSxFQUM1QztBQUNBLE1BQU8sY0FBUTs7O0FDdERmLE1BQU0sQ0FBQyxXQUFXLFNBQVMsSUFBSSxZQUFJLE1BQU07QUFBQSxJQUNyQztBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQ2xFO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFDbEU7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUNsRTtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQ2xFO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFDbEU7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUNsRTtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQ2xFO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFDbEU7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUNsRTtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQ2xFO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFDbEU7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUNsRTtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQ2xFO0FBQUEsSUFBc0I7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFDbEU7QUFBQSxJQUFzQjtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFBQSxJQUNsRTtBQUFBLElBQXNCO0FBQUEsSUFBc0I7QUFB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QUFJLEdBQUcsR0FBRyxJQUFJLFlBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFHLElBQUksWUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsT0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLEdBQUcsSUFBSSxZQUFJLElBQUksS0FBSyxLQUFLLEdBQUcsS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNwRSxPQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRyxJQUFJLFlBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFHLElBQUksWUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsT0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLEdBQUcsSUFBSSxZQUFJLElBQUksS0FBSyxLQUFLLEdBQUcsS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNwRSxPQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRyxJQUFJLFlBQUksSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFHLElBQUksWUFBSSxJQUFJLEtBQUssS0FBSyxHQUFHLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDcEUsV0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxJQUMzRTtBQUFBLElB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LFFBQVEsT0FBTztBQUU5QyxVQUFJLGFBQWEsY0FBTSxpQkFBaUIsS0FBSyxnQkFBZ0I7QUFBQSxRQUN6RDtBQUFBLFFBQ0EsT0FBTyxLQUFLO0FBQUEsUUFDWixPQUFPLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxHQUFJLElBQUk7QUFBQSxNQUMzQyxDQUFDO0FBQ0QsY0FBUSxJQUFJLFVBQVU7QUFDdEIsYUFBTztBQUFBLElBQ1g7QUFBQTtBQUFBLElBSUEsSUFBSSxhQUFhO0FBQ2IsYUFBTyxZQUFZLEtBQUssT0FBTztBQUFBLElBQ25DO0FBQUEsSUFFQSxJQUFJLGdCQUFnQjtBQUNoQixhQUFPLEtBQUssYUFDTixLQUNBO0FBQUEsSUFDVjtBQUFBLElBRUEsSUFBSSxRQUFRO0FBQ1IsYUFBTyxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksR0FBSSxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFBQSxJQUMvRDtBQUFBLElBRUEsSUFBSSxpQkFBaUI7QUFDakIsVUFBSSxDQUFDLEtBQUssWUFBWTtBQUNsQixlQUFPO0FBQUEsTUFDWDtBQUNBLFVBQUksS0FBSyxRQUFRLFdBQVcsTUFBTSxHQUFHO0FBQ2pDLGVBQU8sY0FBTSxPQUFPLEtBQUssT0FBTyxFQUFFO0FBQUEsTUFDdEM7QUFDQSxhQUFPLEtBQUs7QUFBQSxJQUNoQjtBQUFBLEVBQ0osRUFBRTtBQUVGLGlCQUFPLE1BQU07IiwKICAibmFtZXMiOiBbIm51bWJlciIsICJib29sIiwgImJ5dGVzIiwgImhhc2giLCAiZXhpc3RzIiwgIm91dHB1dCIsICJhc3NlcnQiLCAiY3JlYXRlVmlldyIsICJyb3RyIiwgImhleGVzIiwgImJ5dGVzVG9IZXgiLCAiaGV4IiwgImhleFRvQnl0ZXMiLCAibmV4dFRpY2siLCAidXRmOFRvQnl0ZXMiLCAidG9CeXRlcyIsICJkYXRhIiwgImNvbmNhdEJ5dGVzIiwgIkhhc2giLCAid3JhcENvbnN0cnVjdG9yIiwgInJhbmRvbUJ5dGVzIiwgIkhNQUMiLCAiaGFzaCIsICJobWFjIiwgImhhc2giLCAiaSIsICJzZXRCaWdVaW50NjQiLCAiaXNMRSIsICJfMzJuIiwgIlNIQTIiLCAiZGF0YSIsICJDaGkiLCAiTWFqIiwgIlNIQTI1Nl9LIiwgIklWIiwgIlNIQTI1Nl9XIiwgIlNIQTI1NiIsICJTSEEyMjQiLCAiVTMyX01BU0s2NCIsICJfMzJuIiwgImZyb21CaWciLCAic3BsaXQiLCAidG9CaWciLCAic2hyU0giLCAic2hyU0wiLCAicm90clNIIiwgInJvdHJTTCIsICJyb3RyQkgiLCAicm90ckJMIiwgInJvdHIzMkgiLCAicm90cjMyTCIsICJyb3RsU0giLCAicm90bFNMIiwgInJvdGxCSCIsICJyb3RsQkwiLCAiYWRkIiwgImFkZDNMIiwgImFkZDNIIiwgImFkZDRMIiwgImFkZDRIIiwgImFkZDVMIiwgImFkZDVIIiwgInU2NCIsICJTSEE1MTJfS2giLCAiU0hBNTEyX0tsIiwgIlNIQTUxMl9XX0giLCAiU0hBNTEyX1dfTCIsICJTSEE1MTIiLCAiU0hBNTEyXzIyNCIsICJTSEE1MTJfMjU2IiwgIlNIQTM4NCIsICJhc3NlcnROdW1iZXIiLCAiY2hhaW4iLCAiZGVjb2RlIiwgImFscGhhYmV0IiwgImpvaW4iLCAicGFkZGluZyIsICJkYXRhIiwgIm5vcm1hbGl6ZSIsICJjb252ZXJ0UmFkaXgiLCAiZ2NkIiwgInJhZGl4MmNhcnJ5IiwgImNvbnZlcnRSYWRpeDIiLCAicmFkaXgiLCAiYnl0ZXMiLCAicmFkaXgyIiwgInVuc2FmZVdyYXBwZXIiLCAiY2hlY2tzdW0iLCAiZ2VuQmFzZTU4IiwgIlhNUl9CTE9DS19MRU4iLCAiYmFzZTU4Y2hlY2siLCAic2hhMjU2IiwgIkJFQ0hfQUxQSEFCRVQiLCAiUE9MWU1PRF9HRU5FUkFUT1JTIiwgImJlY2gzMlBvbHltb2QiLCAiYmVjaENoZWNrc3VtIiwgInByZWZpeCIsICJnZW5CZWNoMzIiLCAiX3dvcmRzIiwgIkNPREVSUyIsICJjb2RlclR5cGVFcnJvciIsICJ3b3JkbGlzdCIsICJub3JtYWxpemUiLCAiZ2VuZXJhdGVNbmVtb25pYyIsICJ2YWxpZGF0ZU1uZW1vbmljIiwgIm1uZW1vbmljVG9TZWVkU3luYyIsICJhZGQyIiwgInNwbGl0IiwgImJvb2wiLCAibmV4dFRpY2syIiwgImFkZDIiLCAibnVtYmVyIiwgImQiLCAid2luZG93IiwgImYiLCAiYnl0ZXMiLCAiaGV4IiwgInByZWZpeCIsICJkYXRhIiwgIm51bWJlciIsICJnY2QiLCAiaGFzaCIsICJoYXNoTGVuIiwgImVycm9yIiwgImJ5dGVzIiwgImVycm9yIiwgImhleCIsICJieXRlcyIsICJyYXciLCAiY3J5cHRvIiwgImhhc2giLCAicmFuZG9tQnl0ZXMiLCAiY3J5cHRvIiwgImhleGVzIiwgIm5leHRUaWNrIiwgImRhdGEiLCAiaGFzaCIsICJjcnlwdG8iLCAiaXNMRSIsICJfMzJuIiwgImRhdGEiLCAiYXNzZXJ0TnVtYmVyIiwgImRlY29kZSIsICJhbHBoYWJldCIsICJkYXRhIiwgInBhZGRpbmciLCAiYnl0ZXMiLCAiY2hlY2tzdW0iLCAiZGF0YSIsICJzaGEyNTYiLCAicHJlZml4IiwgImRlY29kZSIsICJfd29yZHMiLCAiaGFzaCIsICJjcnlwdG8iLCAiY3JlYXRlVmlldyIsICJyb3RyIiwgImlzTEUiLCAiaGV4ZXMiLCAiYnl0ZXNUb0hleCIsICJoZXgiLCAiaGV4VG9CeXRlcyIsICJ1dGY4VG9CeXRlcyIsICJ0b0J5dGVzIiwgImRhdGEiLCAiY29uY2F0Qnl0ZXMiLCAiSGFzaCIsICJ3cmFwQ29uc3RydWN0b3IiLCAidG9CeXRlcyIsICJIYXNoIiwgImhhc2giLCAidG9CeXRlcyIsICJzZXRCaWdVaW50NjQiLCAiaXNMRSIsICJfMzJuIiwgIlNIQTIiLCAiSGFzaCIsICJjcmVhdGVWaWV3IiwgImRhdGEiLCAidG9CeXRlcyIsICJTSEEyIiwgIndyYXBDb25zdHJ1Y3RvciIsICJDaGkiLCAiTWFqIiwgIlNIQTI1Nl9LIiwgIklWIiwgIlNIQTI1Nl9XIiwgIlNIQTI1NiIsICJTSEEyIiwgInJvdHIiLCAic2hhMjU2IiwgIndyYXBDb25zdHJ1Y3RvciIsICJhZGQiLCAiU0hBMiIsICJ3cmFwQ29uc3RydWN0b3IiLCAic2hhMjU2IiwgImJhc2U1OGNoZWNrIiwgImJ5dGVzVG9OdW1iZXIiLCAiYnl0ZXMiLCAiYnl0ZXNUb0hleCIsICJoZXhUb0J5dGVzIiwgInV0ZjhUb0J5dGVzIiwgImRhdGEiLCAiY3JlYXRlVmlldyIsICJjb25jYXRCeXRlcyIsICJoYXNoIiwgImVycm9yIiwgIkhNQUMiLCAiaGFzaCIsICJobWFjIiwgIl9fZGVmUHJvcCIsICJnZXRQdWJsaWNLZXkiLCAic3RhcnQiLCAic3RhcnQiLCAiZGF0YSIsICJwcmVmaXgiLCAiaGV4IiwgImdldFB1YmxpY0tleSIsICJobWFjIiwgInN0b3JhZ2UiLCAiZ2V0UHVibGljS2V5Il0KfQo=
